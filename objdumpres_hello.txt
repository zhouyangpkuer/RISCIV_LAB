
hello:     file format elf64-littleriscv


Disassembly of section .text:

0000000000010000 <_ftext>:
   10000:	0000c197          	auipc	gp,0xc
   10004:	ad018193          	addi	gp,gp,-1328 # 1bad0 <_gp>
   10008:	0000b297          	auipc	t0,0xb
   1000c:	36028293          	addi	t0,t0,864 # 1b368 <_PathLocale>
   10010:	0000b317          	auipc	t1,0xb
   10014:	3f830313          	addi	t1,t1,1016 # 1b408 <_end>
   10018:	0002b023          	sd	zero,0(t0)
   1001c:	00828293          	addi	t0,t0,8
   10020:	fe62ece3          	bltu	t0,t1,10018 <_ftext+0x18>
   10024:	00000517          	auipc	a0,0x0
   10028:	1c850513          	addi	a0,a0,456 # 101ec <__libc_fini_array>
   1002c:	17c000ef          	jal	101a8 <atexit>
   10030:	218000ef          	jal	10248 <__libc_init_array>
   10034:	00012503          	lw	a0,0(sp)
   10038:	00810593          	addi	a1,sp,8
   1003c:	00000613          	li	a2,0
   10040:	124000ef          	jal	10164 <main>
   10044:	1780006f          	j	101bc <exit>

0000000000010048 <_fini>:
   10048:	00008067          	ret

000000000001004c <deregister_tm_clones>:
   1004c:	0001b537          	lui	a0,0x1b
   10050:	0001b7b7          	lui	a5,0x1b
   10054:	2c850713          	addi	a4,a0,712 # 1b2c8 <__TMC_END__>
   10058:	2cf78793          	addi	a5,a5,719 # 1b2cf <__TMC_END__+0x7>
   1005c:	40e787b3          	sub	a5,a5,a4
   10060:	00e00713          	li	a4,14
   10064:	00f77c63          	bleu	a5,a4,1007c <deregister_tm_clones+0x30>
   10068:	00000337          	lui	t1,0x0
   1006c:	00030313          	mv	t1,t1
   10070:	00030663          	beqz	t1,1007c <deregister_tm_clones+0x30>
   10074:	2c850513          	addi	a0,a0,712
   10078:	00030067          	jr	t1
   1007c:	00008067          	ret

0000000000010080 <register_tm_clones>:
   10080:	0001b537          	lui	a0,0x1b
   10084:	0001b7b7          	lui	a5,0x1b
   10088:	2c850593          	addi	a1,a0,712 # 1b2c8 <__TMC_END__>
   1008c:	2c878793          	addi	a5,a5,712 # 1b2c8 <__TMC_END__>
   10090:	40b787b3          	sub	a5,a5,a1
   10094:	4037d793          	srai	a5,a5,0x3
   10098:	03f7d593          	srli	a1,a5,0x3f
   1009c:	00f585b3          	add	a1,a1,a5
   100a0:	4015d593          	srai	a1,a1,0x1
   100a4:	00058c63          	beqz	a1,100bc <register_tm_clones+0x3c>
   100a8:	00000337          	lui	t1,0x0
   100ac:	00030313          	mv	t1,t1
   100b0:	00030663          	beqz	t1,100bc <register_tm_clones+0x3c>
   100b4:	2c850513          	addi	a0,a0,712
   100b8:	00030067          	jr	t1
   100bc:	00008067          	ret

00000000000100c0 <__do_global_dtors_aux>:
   100c0:	ff010113          	addi	sp,sp,-16
   100c4:	00813023          	sd	s0,0(sp)
   100c8:	8c81c783          	lbu	a5,-1848(gp) # 1b398 <_bss_start>
   100cc:	00113423          	sd	ra,8(sp)
   100d0:	02079663          	bnez	a5,100fc <__do_global_dtors_aux+0x3c>
   100d4:	f79ff0ef          	jal	1004c <deregister_tm_clones>
   100d8:	000007b7          	lui	a5,0x0
   100dc:	00078793          	mv	a5,a5
   100e0:	00078a63          	beqz	a5,100f4 <__do_global_dtors_aux+0x34>
   100e4:	00019537          	lui	a0,0x19
   100e8:	2a050513          	addi	a0,a0,672 # 192a0 <__fini_array_end>
   100ec:	ffff0317          	auipc	t1,0xffff0
   100f0:	f14300e7          	jalr	t1,-236 # 0 <_ftext-0x10000>
   100f4:	00100793          	li	a5,1
   100f8:	8cf18423          	sb	a5,-1848(gp) # 1b398 <_bss_start>
   100fc:	00813083          	ld	ra,8(sp)
   10100:	00013403          	ld	s0,0(sp)
   10104:	01010113          	addi	sp,sp,16
   10108:	00008067          	ret

000000000001010c <frame_dummy>:
   1010c:	ff010113          	addi	sp,sp,-16
   10110:	000007b7          	lui	a5,0x0
   10114:	00113423          	sd	ra,8(sp)
   10118:	00078793          	mv	a5,a5
   1011c:	00078c63          	beqz	a5,10134 <frame_dummy+0x28>
   10120:	00019537          	lui	a0,0x19
   10124:	8d018593          	addi	a1,gp,-1840 # 1b3a0 <object.3092>
   10128:	2a050513          	addi	a0,a0,672 # 192a0 <__fini_array_end>
   1012c:	ffff0317          	auipc	t1,0xffff0
   10130:	ed4300e7          	jalr	t1,-300 # 0 <_ftext-0x10000>
   10134:	0001a7b7          	lui	a5,0x1a
   10138:	2c878513          	addi	a0,a5,712 # 1a2c8 <__JCR_END__>
   1013c:	00053783          	ld	a5,0(a0)
   10140:	00079863          	bnez	a5,10150 <frame_dummy+0x44>
   10144:	00813083          	ld	ra,8(sp)
   10148:	01010113          	addi	sp,sp,16
   1014c:	f35ff06f          	j	10080 <register_tm_clones>
   10150:	000007b7          	lui	a5,0x0
   10154:	00078793          	mv	a5,a5
   10158:	fe0786e3          	beqz	a5,10144 <frame_dummy+0x38>
   1015c:	000780e7          	jalr	a5
   10160:	fe5ff06f          	j	10144 <frame_dummy+0x38>

0000000000010164 <main>:
   10164:	fe010113          	addi	sp,sp,-32
   10168:	00113c23          	sd	ra,24(sp)
   1016c:	00813823          	sd	s0,16(sp)
   10170:	02010413          	addi	s0,sp,32
   10174:	000197b7          	lui	a5,0x19
   10178:	dc07b787          	fld	fa5,-576(a5) # 18dc0 <__errno+0x10>
   1017c:	fef43427          	fsd	fa5,-24(s0)
   10180:	fe843583          	ld	a1,-24(s0)
   10184:	000197b7          	lui	a5,0x19
   10188:	db878513          	addi	a0,a5,-584 # 18db8 <__errno+0x8>
   1018c:	1a0000ef          	jal	1032c <printf>
   10190:	00000793          	li	a5,0
   10194:	00078513          	mv	a0,a5
   10198:	01813083          	ld	ra,24(sp)
   1019c:	01013403          	ld	s0,16(sp)
   101a0:	02010113          	addi	sp,sp,32
   101a4:	00008067          	ret

00000000000101a8 <atexit>:
int
_DEFUN (atexit,
	(fn),
	_VOID _EXFNPTR(fn, (_VOID)))
{
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
   101a8:	00050593          	mv	a1,a0
   101ac:	00000693          	li	a3,0
   101b0:	00000613          	li	a2,0
   101b4:	00000513          	li	a0,0
   101b8:	0840206f          	j	1223c <__register_exitproc>

00000000000101bc <exit>:
 */

void
_DEFUN (exit, (code),
	int code)
{
   101bc:	ff010113          	addi	sp,sp,-16
#ifdef _LITE_EXIT
  /* Refer to comments in __atexit.c for more details of lite exit.  */
  void __call_exitprocs _PARAMS ((int, _PTR)) __attribute__((weak));
  if (__call_exitprocs)
#endif
    __call_exitprocs (code, NULL);
   101c0:	00000593          	li	a1,0
 */

void
_DEFUN (exit, (code),
	int code)
{
   101c4:	00813023          	sd	s0,0(sp)
   101c8:	00113423          	sd	ra,8(sp)
   101cc:	00050413          	mv	s0,a0
#ifdef _LITE_EXIT
  /* Refer to comments in __atexit.c for more details of lite exit.  */
  void __call_exitprocs _PARAMS ((int, _PTR)) __attribute__((weak));
  if (__call_exitprocs)
#endif
    __call_exitprocs (code, NULL);
   101d0:	180020ef          	jal	12350 <__call_exitprocs>

  if (_GLOBAL_REENT->__cleanup)
   101d4:	8081b503          	ld	a0,-2040(gp) # 1b2d8 <_global_impure_ptr>
   101d8:	05853783          	ld	a5,88(a0)
   101dc:	00078463          	beqz	a5,101e4 <exit+0x28>
    (*_GLOBAL_REENT->__cleanup) (_GLOBAL_REENT);
   101e0:	000780e7          	jalr	a5
  _exit (code);
   101e4:	00040513          	mv	a0,s0
   101e8:	3ad080ef          	jal	18d94 <_exit>

00000000000101ec <__libc_fini_array>:
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   101ec:	fe010113          	addi	sp,sp,-32
   101f0:	00813823          	sd	s0,16(sp)
   101f4:	00913423          	sd	s1,8(sp)
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
   101f8:	00019437          	lui	s0,0x19
   101fc:	000194b7          	lui	s1,0x19
   10200:	29848493          	addi	s1,s1,664 # 19298 <__init_array_end>
   10204:	2a040413          	addi	s0,s0,672 # 192a0 <__fini_array_end>
   10208:	40940433          	sub	s0,s0,s1
   1020c:	ff840793          	addi	a5,s0,-8
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   10210:	00113c23          	sd	ra,24(sp)
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
   10214:	40345413          	srai	s0,s0,0x3
   10218:	009784b3          	add	s1,a5,s1
  for (i = count; i > 0; i--)
   1021c:	00040c63          	beqz	s0,10234 <__libc_fini_array+0x48>
    __fini_array_start[i-1] ();
   10220:	0004b783          	ld	a5,0(s1)
   10224:	fff40413          	addi	s0,s0,-1
   10228:	ff848493          	addi	s1,s1,-8
   1022c:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
   10230:	fe0418e3          	bnez	s0,10220 <__libc_fini_array+0x34>
    __fini_array_start[i-1] ();

  _fini ();
}
   10234:	01813083          	ld	ra,24(sp)
   10238:	01013403          	ld	s0,16(sp)
   1023c:	00813483          	ld	s1,8(sp)
   10240:	02010113          	addi	sp,sp,32
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
    __fini_array_start[i-1] ();

  _fini ();
   10244:	e05ff06f          	j	10048 <_fini>

0000000000010248 <__libc_init_array>:
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   10248:	fe010113          	addi	sp,sp,-32
   1024c:	00813823          	sd	s0,16(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   10250:	000197b7          	lui	a5,0x19
   10254:	00019437          	lui	s0,0x19
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   10258:	01213023          	sd	s2,0(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   1025c:	29078793          	addi	a5,a5,656 # 19290 <_etext>
   10260:	29040913          	addi	s2,s0,656 # 19290 <_etext>
   10264:	41278933          	sub	s2,a5,s2
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   10268:	00913423          	sd	s1,8(sp)
   1026c:	00113c23          	sd	ra,24(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   10270:	40395913          	srai	s2,s2,0x3
   10274:	29040413          	addi	s0,s0,656
   10278:	00000493          	li	s1,0
  for (i = 0; i < count; i++)
   1027c:	00090c63          	beqz	s2,10294 <__libc_init_array+0x4c>
    __preinit_array_start[i] ();
   10280:	00043783          	ld	a5,0(s0)
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   10284:	00148493          	addi	s1,s1,1
   10288:	00840413          	addi	s0,s0,8
    __preinit_array_start[i] ();
   1028c:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   10290:	fe9918e3          	bne	s2,s1,10280 <__libc_init_array+0x38>
    __preinit_array_start[i] ();

  _init ();
   10294:	db5ff0ef          	jal	10048 <_fini>

  count = __init_array_end - __init_array_start;
   10298:	00019437          	lui	s0,0x19
   1029c:	000197b7          	lui	a5,0x19
   102a0:	29040913          	addi	s2,s0,656 # 19290 <_etext>
   102a4:	29878793          	addi	a5,a5,664 # 19298 <__init_array_end>
   102a8:	41278933          	sub	s2,a5,s2
   102ac:	40395913          	srai	s2,s2,0x3
   102b0:	29040413          	addi	s0,s0,656
  for (i = 0; i < count; i++)
   102b4:	00000493          	li	s1,0
   102b8:	00090c63          	beqz	s2,102d0 <__libc_init_array+0x88>
    __init_array_start[i] ();
   102bc:	00043783          	ld	a5,0(s0)
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   102c0:	00148493          	addi	s1,s1,1
   102c4:	00840413          	addi	s0,s0,8
    __init_array_start[i] ();
   102c8:	000780e7          	jalr	a5
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   102cc:	fe9918e3          	bne	s2,s1,102bc <__libc_init_array+0x74>
    __init_array_start[i] ();
}
   102d0:	01813083          	ld	ra,24(sp)
   102d4:	01013403          	ld	s0,16(sp)
   102d8:	00813483          	ld	s1,8(sp)
   102dc:	00013903          	ld	s2,0(sp)
   102e0:	02010113          	addi	sp,sp,32
   102e4:	00008067          	ret

00000000000102e8 <_printf_r>:

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *__restrict fmt _DOTS)
{
   102e8:	fb010113          	addi	sp,sp,-80
   102ec:	02c13023          	sd	a2,32(sp)
   102f0:	02d13423          	sd	a3,40(sp)
   102f4:	02f13c23          	sd	a5,56(sp)
   102f8:	02e13823          	sd	a4,48(sp)
   102fc:	05013023          	sd	a6,64(sp)
   10300:	05113423          	sd	a7,72(sp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   10304:	00058613          	mv	a2,a1
   10308:	01053583          	ld	a1,16(a0)
{
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   1030c:	02010793          	addi	a5,sp,32
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   10310:	00078693          	mv	a3,a5

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *__restrict fmt _DOTS)
{
   10314:	00113c23          	sd	ra,24(sp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   10318:	00f13423          	sd	a5,8(sp)
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   1031c:	060000ef          	jal	1037c <_vfprintf_r>
  va_end (ap);
  return ret;
}
   10320:	01813083          	ld	ra,24(sp)
   10324:	05010113          	addi	sp,sp,80
   10328:	00008067          	ret

000000000001032c <printf>:
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;
   1032c:	8101b303          	ld	t1,-2032(gp) # 1b2e0 <_impure_ptr>
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
   10330:	fa010113          	addi	sp,sp,-96
   10334:	02c13823          	sd	a2,48(sp)
   10338:	02d13c23          	sd	a3,56(sp)
   1033c:	04f13423          	sd	a5,72(sp)
   10340:	02b13423          	sd	a1,40(sp)
   10344:	04e13023          	sd	a4,64(sp)
   10348:	05013823          	sd	a6,80(sp)
   1034c:	05113c23          	sd	a7,88(sp)
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   10350:	01033583          	ld	a1,16(t1)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   10354:	02810793          	addi	a5,sp,40
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   10358:	00050613          	mv	a2,a0
   1035c:	00078693          	mv	a3,a5
   10360:	00030513          	mv	a0,t1
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
   10364:	00113c23          	sd	ra,24(sp)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   10368:	00f13423          	sd	a5,8(sp)
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   1036c:	010000ef          	jal	1037c <_vfprintf_r>
  va_end (ap);
  return ret;
}
   10370:	01813083          	ld	ra,24(sp)
   10374:	06010113          	addi	sp,sp,96
   10378:	00008067          	ret

000000000001037c <_vfprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   1037c:	e1010113          	addi	sp,sp,-496
   10380:	1e113423          	sd	ra,488(sp)
   10384:	1d313423          	sd	s3,456(sp)
   10388:	1d413023          	sd	s4,448(sp)
   1038c:	1b713423          	sd	s7,424(sp)
   10390:	00058a13          	mv	s4,a1
   10394:	00060993          	mv	s3,a2
   10398:	02d13423          	sd	a3,40(sp)
   1039c:	1e813023          	sd	s0,480(sp)
   103a0:	1c913c23          	sd	s1,472(sp)
   103a4:	1d213823          	sd	s2,464(sp)
   103a8:	1b513c23          	sd	s5,440(sp)
   103ac:	1b613823          	sd	s6,432(sp)
   103b0:	1b813023          	sd	s8,416(sp)
   103b4:	19913c23          	sd	s9,408(sp)
   103b8:	19a13823          	sd	s10,400(sp)
   103bc:	19b13423          	sd	s11,392(sp)
   103c0:	16813c27          	fsd	fs0,376(sp)
   103c4:	00050b93          	mv	s7,a0
	char *thousands_sep = NULL;
	size_t thsnd_len = 0;
	const char *grouping = NULL;
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
   103c8:	094040ef          	jal	1445c <_localeconv_r>
   103cc:	00053783          	ld	a5,0(a0)
	size_t decp_len = strlen (decimal_point);
   103d0:	00078513          	mv	a0,a5
	char *thousands_sep = NULL;
	size_t thsnd_len = 0;
	const char *grouping = NULL;
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
   103d4:	06f13023          	sd	a5,96(sp)
	size_t decp_len = strlen (decimal_point);
   103d8:	00c060ef          	jal	163e4 <strlen>
   103dc:	06a13423          	sd	a0,104(sp)
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   103e0:	000b8663          	beqz	s7,103ec <_vfprintf_r+0x70>
   103e4:	050ba783          	lw	a5,80(s7)
   103e8:	2e078c63          	beqz	a5,106e0 <_vfprintf_r+0x364>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
   103ec:	010a1683          	lh	a3,16(s4)
   103f0:	03069793          	slli	a5,a3,0x30
   103f4:	0307d793          	srli	a5,a5,0x30
   103f8:	03279713          	slli	a4,a5,0x32
   103fc:	02074a63          	bltz	a4,10430 <_vfprintf_r+0xb4>
   10400:	000027b7          	lui	a5,0x2
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
	_newlib_flockfile_start (fp);
   10404:	0aca2603          	lw	a2,172(s4)

	ORIENT(fp, -1);
   10408:	00f6e7b3          	or	a5,a3,a5
   1040c:	0107979b          	slliw	a5,a5,0x10
   10410:	ffffe737          	lui	a4,0xffffe
   10414:	4107d79b          	sraiw	a5,a5,0x10
   10418:	fff7071b          	addiw	a4,a4,-1
   1041c:	00e67733          	and	a4,a2,a4
   10420:	00fa1823          	sh	a5,16(s4)
   10424:	03079793          	slli	a5,a5,0x30
   10428:	0aea2623          	sw	a4,172(s4)
   1042c:	0307d793          	srli	a5,a5,0x30

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   10430:	0087f713          	andi	a4,a5,8
   10434:	1e070063          	beqz	a4,10614 <_vfprintf_r+0x298>
   10438:	018a3703          	ld	a4,24(s4)
   1043c:	1c070c63          	beqz	a4,10614 <_vfprintf_r+0x298>
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   10440:	01a7f793          	andi	a5,a5,26
   10444:	00a00713          	li	a4,10
   10448:	1ee78863          	beq	a5,a4,10638 <_vfprintf_r+0x2bc>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   1044c:	000197b7          	lui	a5,0x19
   10450:	dc878793          	addi	a5,a5,-568 # 18dc8 <__errno+0x18>
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   10454:	0f010b13          	addi	s6,sp,240
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   10458:	02f13823          	sd	a5,48(sp)
   1045c:	0ef10793          	addi	a5,sp,239
   10460:	00019ab7          	lui	s5,0x19
   10464:	000194b7          	lui	s1,0x19
   10468:	40fb07b3          	sub	a5,s6,a5
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
	size_t decp_len = strlen (decimal_point);
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
   1046c:	04013c23          	sd	zero,88(sp)
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   10470:	0b613823          	sd	s6,176(sp)
	uio.uio_resid = 0;
   10474:	0c013023          	sd	zero,192(sp)
	uio.uio_iovcnt = 0;
   10478:	0a012c23          	sw	zero,184(sp)
	int expsize = 0;	/* character count for expstr */
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   1047c:	06012823          	sw	zero,112(sp)
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   10480:	000b0893          	mv	a7,s6
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   10484:	02013c23          	sd	zero,56(sp)
	size_t decp_len = strlen (decimal_point);
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
   10488:	06012a23          	sw	zero,116(sp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
	uio.uio_resid = 0;
	uio.uio_iovcnt = 0;
#endif
	ret = 0;
   1048c:	00012e23          	sw	zero,28(sp)
   10490:	f30a8a93          	addi	s5,s5,-208 # 18f30 <blanks.4193>
   10494:	f4048493          	addi	s1,s1,-192 # 18f40 <zeroes.4194>
   10498:	06f13c23          	sd	a5,120(sp)
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   1049c:	0009c783          	lbu	a5,0(s3)
   104a0:	0e0782e3          	beqz	a5,10d84 <_vfprintf_r+0xa08>
   104a4:	02500713          	li	a4,37
   104a8:	00098413          	mv	s0,s3
   104ac:	00e79663          	bne	a5,a4,104b8 <_vfprintf_r+0x13c>
   104b0:	0580006f          	j	10508 <_vfprintf_r+0x18c>
   104b4:	00e78863          	beq	a5,a4,104c4 <_vfprintf_r+0x148>
                    fmt += 1;
   104b8:	00140413          	addi	s0,s0,1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   104bc:	00044783          	lbu	a5,0(s0)
   104c0:	fe079ae3          	bnez	a5,104b4 <_vfprintf_r+0x138>
   104c4:	4134093b          	subw	s2,s0,s3
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   104c8:	04090063          	beqz	s2,10508 <_vfprintf_r+0x18c>
			PRINT (cp, m);
   104cc:	0c013703          	ld	a4,192(sp)
   104d0:	0b812783          	lw	a5,184(sp)
   104d4:	00090693          	mv	a3,s2
   104d8:	00d70733          	add	a4,a4,a3
   104dc:	0017879b          	addiw	a5,a5,1
   104e0:	0138b023          	sd	s3,0(a7)
   104e4:	00d8b423          	sd	a3,8(a7)
   104e8:	0ce13023          	sd	a4,192(sp)
   104ec:	0af12c23          	sw	a5,184(sp)
   104f0:	00700713          	li	a4,7
   104f4:	01088893          	addi	a7,a7,16
   104f8:	16f74063          	blt	a4,a5,10658 <_vfprintf_r+0x2dc>
			ret += m;
   104fc:	01c12783          	lw	a5,28(sp)
   10500:	012787bb          	addw	a5,a5,s2
   10504:	00f12e23          	sw	a5,28(sp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   10508:	00044783          	lbu	a5,0(s0)
   1050c:	16078463          	beqz	a5,10674 <_vfprintf_r+0x2f8>
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */
   10510:	00140993          	addi	s3,s0,1

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
   10514:	080107a3          	sb	zero,143(sp)
   10518:	00000613          	li	a2,0
   1051c:	00000593          	li	a1,0
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
   10520:	fff00413          	li	s0,-1
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
   10524:	00012c23          	sw	zero,24(sp)
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
   10528:	00000c13          	li	s8,0
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   1052c:	05800713          	li	a4,88
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			} while (is_digit (ch));
   10530:	00900693          	li	a3,9
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   10534:	02a00513          	li	a0,42
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   10538:	0009cd03          	lbu	s10,0(s3)
   1053c:	00198993          	addi	s3,s3,1
reswitch:	switch (ch) {
   10540:	fe0d079b          	addiw	a5,s10,-32
   10544:	1cf762e3          	bltu	a4,a5,10f08 <_vfprintf_r+0xb8c>
   10548:	03013803          	ld	a6,48(sp)
   1054c:	02079793          	slli	a5,a5,0x20
   10550:	01e7d793          	srli	a5,a5,0x1e
   10554:	010787b3          	add	a5,a5,a6
   10558:	0007a783          	lw	a5,0(a5)
   1055c:	00078067          	jr	a5
			} else
#endif
				flags |= LONGINT;
			goto rflag;
		case 'q': /* extension */
			flags |= QUADINT;
   10560:	010c6c13          	ori	s8,s8,16
			goto rflag;
   10564:	fd5ff06f          	j	10538 <_vfprintf_r+0x1bc>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   10568:	02813783          	ld	a5,40(sp)
   1056c:	0007a803          	lw	a6,0(a5)
   10570:	00878793          	addi	a5,a5,8
   10574:	02f13423          	sd	a5,40(sp)
   10578:	01012c23          	sw	a6,24(sp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   1057c:	fa085ee3          	bgez	a6,10538 <_vfprintf_r+0x1bc>
				goto rflag;
			width = -width;
   10580:	410007bb          	negw	a5,a6
   10584:	00f12c23          	sw	a5,24(sp)
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   10588:	004c6c13          	ori	s8,s8,4
			goto rflag;
   1058c:	fadff06f          	j	10538 <_vfprintf_r+0x1bc>
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
			ox[0] = '0';
   10590:	03000793          	li	a5,48
   10594:	08f10823          	sb	a5,144(sp)
			ox[1] = ch = 'x';
   10598:	07800793          	li	a5,120
   1059c:	08f108a3          	sb	a5,145(sp)
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   105a0:	02813783          	ld	a5,40(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   105a4:	080107a3          	sb	zero,143(sp)
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
   105a8:	002c6693          	ori	a3,s8,2
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   105ac:	00878713          	addi	a4,a5,8
   105b0:	0007b783          	ld	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   105b4:	180444e3          	bltz	s0,10f3c <_vfprintf_r+0xbc0>
   105b8:	f7fc7c13          	andi	s8,s8,-129
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   105bc:	02e13423          	sd	a4,40(sp)
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
				flags &= ~ZEROPAD;
   105c0:	002c6c13          	ori	s8,s8,2
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   105c4:	120796e3          	bnez	a5,10ef0 <_vfprintf_r+0xb74>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   105c8:	000197b7          	lui	a5,0x19
   105cc:	24078793          	addi	a5,a5,576 # 19240 <zeroes.4137+0x50>
   105d0:	02f13c23          	sd	a5,56(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   105d4:	07800d13          	li	s10,120
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   105d8:	00000613          	li	a2,0
   105dc:	7e040463          	beqz	s0,10dc4 <_vfprintf_r+0xa48>
   105e0:	00000793          	li	a5,0
   105e4:	000b0913          	mv	s2,s6
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   105e8:	03813683          	ld	a3,56(sp)
   105ec:	00f7f713          	andi	a4,a5,15
   105f0:	fff90913          	addi	s2,s2,-1
   105f4:	00e68733          	add	a4,a3,a4
   105f8:	00074703          	lbu	a4,0(a4) # ffffffffffffe000 <_gp+0xfffffffffffe2530>
						_uquad >>= 4;
   105fc:	0047d793          	srli	a5,a5,0x4
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   10600:	00e90023          	sb	a4,0(s2)
						_uquad >>= 4;
					} while (_uquad);
   10604:	fe0792e3          	bnez	a5,105e8 <_vfprintf_r+0x26c>
   10608:	412b07b3          	sub	a5,s6,s2
   1060c:	02f12023          	sw	a5,32(sp)
   10610:	1680006f          	j	10778 <_vfprintf_r+0x3fc>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   10614:	000a0593          	mv	a1,s4
   10618:	000b8513          	mv	a0,s7
   1061c:	2bd010ef          	jal	120d8 <__swsetup_r>
   10620:	00050463          	beqz	a0,10628 <_vfprintf_r+0x2ac>
   10624:	3940106f          	j	119b8 <_vfprintf_r+0x163c>
   10628:	010a5783          	lhu	a5,16(s4)
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   1062c:	00a00713          	li	a4,10
   10630:	01a7f793          	andi	a5,a5,26
   10634:	e0e79ce3          	bne	a5,a4,1044c <_vfprintf_r+0xd0>
   10638:	012a1783          	lh	a5,18(s4)
   1063c:	e007c8e3          	bltz	a5,1044c <_vfprintf_r+0xd0>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
   10640:	02813683          	ld	a3,40(sp)
   10644:	00098613          	mv	a2,s3
   10648:	000a0593          	mv	a1,s4
   1064c:	000b8513          	mv	a0,s7
   10650:	1c9010ef          	jal	12018 <__sbprintf>
   10654:	04c0006f          	j	106a0 <_vfprintf_r+0x324>
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   10658:	0b010613          	addi	a2,sp,176
   1065c:	000a0593          	mv	a1,s4
   10660:	000b8513          	mv	a0,s7
   10664:	73d050ef          	jal	165a0 <__sprint_r>
   10668:	02051263          	bnez	a0,1068c <_vfprintf_r+0x310>
   1066c:	000b0893          	mv	a7,s6
   10670:	e8dff06f          	j	104fc <_vfprintf_r+0x180>
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
   10674:	0c013783          	ld	a5,192(sp)
   10678:	00078a63          	beqz	a5,1068c <_vfprintf_r+0x310>
   1067c:	0b010613          	addi	a2,sp,176
   10680:	000a0593          	mv	a1,s4
   10684:	000b8513          	mv	a0,s7
   10688:	719050ef          	jal	165a0 <__sprint_r>
	if (malloc_buf != NULL)
		_free_r (data, malloc_buf);
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   1068c:	010a5783          	lhu	a5,16(s4)
   10690:	0407f793          	andi	a5,a5,64
   10694:	00078463          	beqz	a5,1069c <_vfprintf_r+0x320>
   10698:	3200106f          	j	119b8 <_vfprintf_r+0x163c>
   1069c:	01c12503          	lw	a0,28(sp)
	/* NOTREACHED */
}
   106a0:	1e813083          	ld	ra,488(sp)
   106a4:	1e013403          	ld	s0,480(sp)
   106a8:	1d813483          	ld	s1,472(sp)
   106ac:	1d013903          	ld	s2,464(sp)
   106b0:	1c813983          	ld	s3,456(sp)
   106b4:	1c013a03          	ld	s4,448(sp)
   106b8:	1b813a83          	ld	s5,440(sp)
   106bc:	1b013b03          	ld	s6,432(sp)
   106c0:	1a813b83          	ld	s7,424(sp)
   106c4:	1a013c03          	ld	s8,416(sp)
   106c8:	19813c83          	ld	s9,408(sp)
   106cc:	19013d03          	ld	s10,400(sp)
   106d0:	18813d83          	ld	s11,392(sp)
   106d4:	17813407          	fld	fs0,376(sp)
   106d8:	1f010113          	addi	sp,sp,496
   106dc:	00008067          	ret
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   106e0:	000b8513          	mv	a0,s7
   106e4:	700030ef          	jal	13de4 <__sinit>
   106e8:	d05ff06f          	j	103ec <_vfprintf_r+0x70>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   106ec:	00100613          	li	a2,1
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
   106f0:	02b00593          	li	a1,43
   106f4:	e45ff06f          	j	10538 <_vfprintf_r+0x1bc>
   106f8:	00060463          	beqz	a2,10700 <_vfprintf_r+0x384>
   106fc:	0d90106f          	j	11fd4 <_vfprintf_r+0x1c58>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   10700:	010c7793          	andi	a5,s8,16
   10704:	22078263          	beqz	a5,10928 <_vfprintf_r+0x5ac>
   10708:	02813783          	ld	a5,40(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1070c:	080107a3          	sb	zero,143(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   10710:	00878713          	addi	a4,a5,8
   10714:	0007b783          	ld	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   10718:	22044663          	bltz	s0,10944 <_vfprintf_r+0x5c8>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   1071c:	02e13423          	sd	a4,40(sp)
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
				flags &= ~ZEROPAD;
   10720:	f7fc7c13          	andi	s8,s8,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   10724:	22079663          	bnez	a5,10950 <_vfprintf_r+0x5d4>
   10728:	00000613          	li	a2,0
   1072c:	00000793          	li	a5,0
   10730:	00041463          	bnez	s0,10738 <_vfprintf_r+0x3bc>
   10734:	3680106f          	j	11a9c <_vfprintf_r+0x1720>
   10738:	000b0913          	mv	s2,s6
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   1073c:	0077f713          	andi	a4,a5,7
   10740:	fff90913          	addi	s2,s2,-1
   10744:	0307071b          	addiw	a4,a4,48
   10748:	00e90023          	sb	a4,0(s2)
						_uquad >>= 3;
   1074c:	0037d793          	srli	a5,a5,0x3
					} while (_uquad);
   10750:	fe0796e3          	bnez	a5,1073c <_vfprintf_r+0x3c0>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   10754:	001c7793          	andi	a5,s8,1
   10758:	ea0788e3          	beqz	a5,10608 <_vfprintf_r+0x28c>
   1075c:	03000793          	li	a5,48
   10760:	eaf704e3          	beq	a4,a5,10608 <_vfprintf_r+0x28c>
						*--cp = '0';
   10764:	fff90713          	addi	a4,s2,-1
   10768:	40eb06b3          	sub	a3,s6,a4
   1076c:	fef90fa3          	sb	a5,-1(s2)
   10770:	02d12023          	sw	a3,32(sp)
   10774:	00070913          	mv	s2,a4
   10778:	02012783          	lw	a5,32(sp)
   1077c:	00078d93          	mv	s11,a5
   10780:	0087d463          	ble	s0,a5,10788 <_vfprintf_r+0x40c>
   10784:	00040d93          	mv	s11,s0
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   10788:	01b12423          	sw	s11,8(sp)
   1078c:	04012623          	sw	zero,76(sp)
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
		if (sign)
   10790:	2a060263          	beqz	a2,10a34 <_vfprintf_r+0x6b8>
			realsz++;
   10794:	00812783          	lw	a5,8(sp)
   10798:	0017879b          	addiw	a5,a5,1
   1079c:	00f12423          	sw	a5,8(sp)
   107a0:	2940006f          	j	10a34 <_vfprintf_r+0x6b8>
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   107a4:	0009cd03          	lbu	s10,0(s3)
   107a8:	00198993          	addi	s3,s3,1
   107ac:	00ad1463          	bne	s10,a0,107b4 <_vfprintf_r+0x438>
   107b0:	75c0106f          	j	11f0c <_vfprintf_r+0x1b90>
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   107b4:	fd0d079b          	addiw	a5,s10,-48
   107b8:	00000413          	li	s0,0
   107bc:	d8f6e2e3          	bltu	a3,a5,10540 <_vfprintf_r+0x1c4>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   107c0:	00198993          	addi	s3,s3,1
   107c4:	fff9cd03          	lbu	s10,-1(s3)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
				n = 10 * n + to_digit (ch);
   107c8:	0014181b          	slliw	a6,s0,0x1
   107cc:	0034141b          	slliw	s0,s0,0x3
   107d0:	0088043b          	addw	s0,a6,s0
   107d4:	00f4043b          	addw	s0,s0,a5
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   107d8:	fd0d079b          	addiw	a5,s10,-48
   107dc:	fef6f2e3          	bleu	a5,a3,107c0 <_vfprintf_r+0x444>
   107e0:	d60450e3          	bgez	s0,10540 <_vfprintf_r+0x1c4>
   107e4:	fff00413          	li	s0,-1
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
			goto reswitch;
   107e8:	d59ff06f          	j	10540 <_vfprintf_r+0x1c4>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   107ec:	080c6c13          	ori	s8,s8,128
			goto rflag;
   107f0:	d49ff06f          	j	10538 <_vfprintf_r+0x1bc>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   107f4:	d40592e3          	bnez	a1,10538 <_vfprintf_r+0x1bc>
   107f8:	00100613          	li	a2,1
				sign = ' ';
   107fc:	02000593          	li	a1,32
   10800:	d39ff06f          	j	10538 <_vfprintf_r+0x1bc>
			goto rflag;
		case '#':
			flags |= ALT;
   10804:	001c6c13          	ori	s8,s8,1
			goto rflag;
   10808:	d31ff06f          	j	10538 <_vfprintf_r+0x1bc>
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   1080c:	02813783          	ld	a5,40(sp)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   10810:	080107a3          	sb	zero,143(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   10814:	0007b903          	ld	s2,0(a5)
   10818:	00878c93          	addi	s9,a5,8
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   1081c:	00091463          	bnez	s2,10824 <_vfprintf_r+0x4a8>
   10820:	39c0106f          	j	11bbc <_vfprintf_r+0x1840>
   10824:	01113023          	sd	a7,0(sp)
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   10828:	00045463          	bgez	s0,10830 <_vfprintf_r+0x4b4>
   1082c:	3240106f          	j	11b50 <_vfprintf_r+0x17d4>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   10830:	00040613          	mv	a2,s0
   10834:	00000593          	li	a1,0
   10838:	00090513          	mv	a0,s2
   1083c:	564040ef          	jal	14da0 <memchr>

				if (p != NULL)
   10840:	00013883          	ld	a7,0(sp)
   10844:	00051463          	bnez	a0,1084c <_vfprintf_r+0x4d0>
   10848:	4c00106f          	j	11d08 <_vfprintf_r+0x198c>
					size = p - cp;
   1084c:	412507bb          	subw	a5,a0,s2
   10850:	02f12023          	sw	a5,32(sp)
   10854:	00078d93          	mv	s11,a5
   10858:	0007d463          	bgez	a5,10860 <_vfprintf_r+0x4e4>
   1085c:	3140106f          	j	11b70 <_vfprintf_r+0x17f4>
   10860:	08f14603          	lbu	a2,143(sp)
				else
					size = prec;
			} else
				size = strlen (cp);
   10864:	01b12423          	sw	s11,8(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   10868:	03913423          	sd	s9,40(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   1086c:	00000413          	li	s0,0
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   10870:	04012623          	sw	zero,76(sp)
   10874:	f1dff06f          	j	10790 <_vfprintf_r+0x414>
   10878:	00060463          	beqz	a2,10880 <_vfprintf_r+0x504>
   1087c:	7800106f          	j	11ffc <_vfprintf_r+0x1c80>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   10880:	010c7793          	andi	a5,s8,16
   10884:	0e078463          	beqz	a5,1096c <_vfprintf_r+0x5f0>
   10888:	02813783          	ld	a5,40(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1088c:	080107a3          	sb	zero,143(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   10890:	00878713          	addi	a4,a5,8
   10894:	0007b783          	ld	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   10898:	0e044863          	bltz	s0,10988 <_vfprintf_r+0x60c>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   1089c:	02e13423          	sd	a4,40(sp)
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
				flags &= ~ZEROPAD;
   108a0:	f7fc7c13          	andi	s8,s8,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   108a4:	00000613          	li	a2,0
   108a8:	50078c63          	beqz	a5,10dc0 <_vfprintf_r+0xa44>
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   108ac:	00900713          	li	a4,9
   108b0:	000b0913          	mv	s2,s6
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   108b4:	00a00693          	li	a3,10
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   108b8:	40f770e3          	bleu	a5,a4,114b8 <_vfprintf_r+0x113c>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   108bc:	02d7f733          	remu	a4,a5,a3
   108c0:	fff90913          	addi	s2,s2,-1
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
   108c4:	02d7d7b3          	divu	a5,a5,a3
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   108c8:	0307071b          	addiw	a4,a4,48
   108cc:	00e90023          	sb	a4,0(s2)
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
					} while (_uquad != 0);
   108d0:	fe0796e3          	bnez	a5,108bc <_vfprintf_r+0x540>
   108d4:	412b07b3          	sub	a5,s6,s2
   108d8:	02f12023          	sw	a5,32(sp)
   108dc:	e9dff06f          	j	10778 <_vfprintf_r+0x3fc>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   108e0:	00012c23          	sw	zero,24(sp)
   108e4:	fd0d079b          	addiw	a5,s10,-48
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
   108e8:	01812303          	lw	t1,24(sp)
				ch = *fmt++;
   108ec:	00198993          	addi	s3,s3,1
   108f0:	fff9cd03          	lbu	s10,-1(s3)
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
   108f4:	0013181b          	slliw	a6,t1,0x1
   108f8:	00331c9b          	slliw	s9,t1,0x3
   108fc:	01980cbb          	addw	s9,a6,s9
   10900:	019787bb          	addw	a5,a5,s9
   10904:	00f12c23          	sw	a5,24(sp)
				ch = *fmt++;
			} while (is_digit (ch));
   10908:	fd0d079b          	addiw	a5,s10,-48
   1090c:	fcf6fee3          	bleu	a5,a3,108e8 <_vfprintf_r+0x56c>
   10910:	c31ff06f          	j	10540 <_vfprintf_r+0x1c4>
   10914:	00060463          	beqz	a2,1091c <_vfprintf_r+0x5a0>
   10918:	6d80106f          	j	11ff0 <_vfprintf_r+0x1c74>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   1091c:	010c6c13          	ori	s8,s8,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   10920:	010c7793          	andi	a5,s8,16
   10924:	de0792e3          	bnez	a5,10708 <_vfprintf_r+0x38c>
   10928:	040c7793          	andi	a5,s8,64

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1092c:	080107a3          	sb	zero,143(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   10930:	580780e3          	beqz	a5,116b0 <_vfprintf_r+0x1334>
   10934:	02813783          	ld	a5,40(sp)
   10938:	00878713          	addi	a4,a5,8
   1093c:	0007d783          	lhu	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   10940:	dc045ee3          	bgez	s0,1071c <_vfprintf_r+0x3a0>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   10944:	02e13423          	sd	a4,40(sp)
   10948:	00000613          	li	a2,0
   1094c:	60078a63          	beqz	a5,10f60 <_vfprintf_r+0xbe4>
   10950:	00000613          	li	a2,0
   10954:	de5ff06f          	j	10738 <_vfprintf_r+0x3bc>
   10958:	00060463          	beqz	a2,10960 <_vfprintf_r+0x5e4>
   1095c:	6880106f          	j	11fe4 <_vfprintf_r+0x1c68>
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   10960:	010c6c13          	ori	s8,s8,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   10964:	010c7793          	andi	a5,s8,16
   10968:	f20790e3          	bnez	a5,10888 <_vfprintf_r+0x50c>
   1096c:	040c7793          	andi	a5,s8,64

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   10970:	080107a3          	sb	zero,143(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   10974:	500780e3          	beqz	a5,11674 <_vfprintf_r+0x12f8>
   10978:	02813783          	ld	a5,40(sp)
   1097c:	00878713          	addi	a4,a5,8
   10980:	0007d783          	lhu	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   10984:	f0045ce3          	bgez	s0,1089c <_vfprintf_r+0x520>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   10988:	02e13423          	sd	a4,40(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1098c:	00000613          	li	a2,0
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   10990:	f0079ee3          	bnez	a5,108ac <_vfprintf_r+0x530>
   10994:	00100793          	li	a5,1
   10998:	5c80006f          	j	10f60 <_vfprintf_r+0xbe4>
   1099c:	00060463          	beqz	a2,109a4 <_vfprintf_r+0x628>
   109a0:	63c0106f          	j	11fdc <_vfprintf_r+0x1c60>
		case 'u':
			_uquad = UARG ();
			base = DEC;
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
   109a4:	000197b7          	lui	a5,0x19
   109a8:	22878793          	addi	a5,a5,552 # 19228 <zeroes.4137+0x38>
   109ac:	02f13c23          	sd	a5,56(sp)
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   109b0:	010c7793          	andi	a5,s8,16
   109b4:	4c078263          	beqz	a5,10e78 <_vfprintf_r+0xafc>
   109b8:	02813703          	ld	a4,40(sp)
   109bc:	00073783          	ld	a5,0(a4)
   109c0:	00870713          	addi	a4,a4,8
   109c4:	02e13423          	sd	a4,40(sp)
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   109c8:	001c7713          	andi	a4,s8,1
   109cc:	120706e3          	beqz	a4,112f8 <_vfprintf_r+0xf7c>
   109d0:	6a078ee3          	beqz	a5,1188c <_vfprintf_r+0x1510>
				ox[0] = '0';
   109d4:	03000713          	li	a4,48
   109d8:	08e10823          	sb	a4,144(sp)
				ox[1] = ch;
   109dc:	09a108a3          	sb	s10,145(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   109e0:	080107a3          	sb	zero,143(sp)
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
				ox[1] = ch;
				flags |= HEXPREFIX;
   109e4:	002c6713          	ori	a4,s8,2
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   109e8:	00045463          	bgez	s0,109f0 <_vfprintf_r+0x674>
   109ec:	2140106f          	j	11c00 <_vfprintf_r+0x1884>
   109f0:	f7fc7c13          	andi	s8,s8,-129
				flags &= ~ZEROPAD;
   109f4:	002c6c13          	ori	s8,s8,2
   109f8:	00000613          	li	a2,0
   109fc:	be9ff06f          	j	105e4 <_vfprintf_r+0x268>
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   10a00:	02813703          	ld	a4,40(sp)
				size = 1;
			}
			sign = '\0';
			break;
   10a04:	00100693          	li	a3,1
   10a08:	00d12423          	sw	a3,8(sp)
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   10a0c:	00072783          	lw	a5,0(a4)
				size = 1;
			}
			sign = '\0';
   10a10:	080107a3          	sb	zero,143(sp)
			break;
   10a14:	00000613          	li	a2,0
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   10a18:	0cf10423          	sb	a5,200(sp)
   10a1c:	00870793          	addi	a5,a4,8
   10a20:	02f13423          	sd	a5,40(sp)
				size = 1;
   10a24:	02d12023          	sw	a3,32(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   10a28:	00000413          	li	s0,0
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   10a2c:	04012623          	sw	zero,76(sp)
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   10a30:	0c810913          	addi	s2,sp,200
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
		if (sign)
			realsz++;
		if (flags & HEXPREFIX)
   10a34:	002c7793          	andi	a5,s8,2
   10a38:	04f12023          	sw	a5,64(sp)
   10a3c:	00078863          	beqz	a5,10a4c <_vfprintf_r+0x6d0>
			realsz+= 2;
   10a40:	00812783          	lw	a5,8(sp)
   10a44:	0027879b          	addiw	a5,a5,2
   10a48:	00f12423          	sw	a5,8(sp)

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   10a4c:	084c7793          	andi	a5,s8,132
   10a50:	04f12423          	sw	a5,72(sp)
   10a54:	52079263          	bnez	a5,10f78 <_vfprintf_r+0xbfc>
			PAD (width - realsz, blanks);
   10a58:	01812783          	lw	a5,24(sp)
   10a5c:	00812703          	lw	a4,8(sp)
   10a60:	40e78cbb          	subw	s9,a5,a4
   10a64:	51905a63          	blez	s9,10f78 <_vfprintf_r+0xbfc>
   10a68:	01000793          	li	a5,16
   10a6c:	0197c463          	blt	a5,s9,10a74 <_vfprintf_r+0x6f8>
   10a70:	1080106f          	j	11b78 <_vfprintf_r+0x17fc>
   10a74:	01000813          	li	a6,16
   10a78:	0c013783          	ld	a5,192(sp)
   10a7c:	0b812703          	lw	a4,184(sp)
   10a80:	05513823          	sd	s5,80(sp)
   10a84:	00700313          	li	t1,7
   10a88:	00080d93          	mv	s11,a6
   10a8c:	00c0006f          	j	10a98 <_vfprintf_r+0x71c>
   10a90:	ff0c8c9b          	addiw	s9,s9,-16
   10a94:	059dde63          	ble	s9,s11,10af0 <_vfprintf_r+0x774>
   10a98:	01078793          	addi	a5,a5,16
   10a9c:	0017071b          	addiw	a4,a4,1
   10aa0:	0158b023          	sd	s5,0(a7)
   10aa4:	0108b423          	sd	a6,8(a7)
   10aa8:	0cf13023          	sd	a5,192(sp)
   10aac:	0ae12c23          	sw	a4,184(sp)
   10ab0:	01088893          	addi	a7,a7,16
   10ab4:	fce35ee3          	ble	a4,t1,10a90 <_vfprintf_r+0x714>
   10ab8:	0b010613          	addi	a2,sp,176
   10abc:	000a0593          	mv	a1,s4
   10ac0:	000b8513          	mv	a0,s7
   10ac4:	00613823          	sd	t1,16(sp)
   10ac8:	01013023          	sd	a6,0(sp)
   10acc:	2d5050ef          	jal	165a0 <__sprint_r>
   10ad0:	ba051ee3          	bnez	a0,1068c <_vfprintf_r+0x310>
   10ad4:	ff0c8c9b          	addiw	s9,s9,-16
   10ad8:	0c013783          	ld	a5,192(sp)
   10adc:	0b812703          	lw	a4,184(sp)
   10ae0:	000b0893          	mv	a7,s6
   10ae4:	01013303          	ld	t1,16(sp)
   10ae8:	00013803          	ld	a6,0(sp)
   10aec:	fb9dc6e3          	blt	s11,s9,10a98 <_vfprintf_r+0x71c>
   10af0:	05013603          	ld	a2,80(sp)
   10af4:	00fc87b3          	add	a5,s9,a5
   10af8:	0017071b          	addiw	a4,a4,1
   10afc:	00c8b023          	sd	a2,0(a7)
   10b00:	0198b423          	sd	s9,8(a7)
   10b04:	0cf13023          	sd	a5,192(sp)
   10b08:	0ae12c23          	sw	a4,184(sp)
   10b0c:	00700693          	li	a3,7
   10b10:	0ce6cae3          	blt	a3,a4,113e4 <_vfprintf_r+0x1068>
   10b14:	08f14603          	lbu	a2,143(sp)
   10b18:	01088893          	addi	a7,a7,16

		/* prefix */
		if (sign)
   10b1c:	02060a63          	beqz	a2,10b50 <_vfprintf_r+0x7d4>
			PRINT (&sign, 1);
   10b20:	0b812703          	lw	a4,184(sp)
   10b24:	08f10693          	addi	a3,sp,143
   10b28:	00d8b023          	sd	a3,0(a7)
   10b2c:	00178793          	addi	a5,a5,1
   10b30:	00100693          	li	a3,1
   10b34:	0017071b          	addiw	a4,a4,1
   10b38:	00d8b423          	sd	a3,8(a7)
   10b3c:	0cf13023          	sd	a5,192(sp)
   10b40:	0ae12c23          	sw	a4,184(sp)
   10b44:	00700693          	li	a3,7
   10b48:	01088893          	addi	a7,a7,16
   10b4c:	76e6c663          	blt	a3,a4,112b8 <_vfprintf_r+0xf3c>
		if (flags & HEXPREFIX)
   10b50:	04012703          	lw	a4,64(sp)
   10b54:	02070a63          	beqz	a4,10b88 <_vfprintf_r+0x80c>
			PRINT (ox, 2);
   10b58:	0b812703          	lw	a4,184(sp)
   10b5c:	09010693          	addi	a3,sp,144
   10b60:	00d8b023          	sd	a3,0(a7)
   10b64:	00278793          	addi	a5,a5,2
   10b68:	00200693          	li	a3,2
   10b6c:	0017071b          	addiw	a4,a4,1
   10b70:	00d8b423          	sd	a3,8(a7)
   10b74:	0cf13023          	sd	a5,192(sp)
   10b78:	0ae12c23          	sw	a4,184(sp)
   10b7c:	00700693          	li	a3,7
   10b80:	01088893          	addi	a7,a7,16
   10b84:	74e6ca63          	blt	a3,a4,112d8 <_vfprintf_r+0xf5c>

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   10b88:	04812683          	lw	a3,72(sp)
   10b8c:	08000713          	li	a4,128
   10b90:	5ee68663          	beq	a3,a4,1117c <_vfprintf_r+0xe00>
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   10b94:	02012703          	lw	a4,32(sp)
   10b98:	40e4043b          	subw	s0,s0,a4
   10b9c:	0c805063          	blez	s0,10c5c <_vfprintf_r+0x8e0>
   10ba0:	01000713          	li	a4,16
   10ba4:	4e875ce3          	ble	s0,a4,1189c <_vfprintf_r+0x1520>
   10ba8:	01000c93          	li	s9,16
   10bac:	0b812703          	lw	a4,184(sp)
   10bb0:	00913823          	sd	s1,16(sp)
   10bb4:	00700813          	li	a6,7
   10bb8:	000c8d93          	mv	s11,s9
   10bbc:	00c0006f          	j	10bc8 <_vfprintf_r+0x84c>
   10bc0:	ff04041b          	addiw	s0,s0,-16
   10bc4:	048dda63          	ble	s0,s11,10c18 <_vfprintf_r+0x89c>
   10bc8:	01078793          	addi	a5,a5,16
   10bcc:	0017071b          	addiw	a4,a4,1
   10bd0:	0098b023          	sd	s1,0(a7)
   10bd4:	0198b423          	sd	s9,8(a7)
   10bd8:	0cf13023          	sd	a5,192(sp)
   10bdc:	0ae12c23          	sw	a4,184(sp)
   10be0:	01088893          	addi	a7,a7,16
   10be4:	fce85ee3          	ble	a4,a6,10bc0 <_vfprintf_r+0x844>
   10be8:	0b010613          	addi	a2,sp,176
   10bec:	000a0593          	mv	a1,s4
   10bf0:	000b8513          	mv	a0,s7
   10bf4:	01013023          	sd	a6,0(sp)
   10bf8:	1a9050ef          	jal	165a0 <__sprint_r>
   10bfc:	a80518e3          	bnez	a0,1068c <_vfprintf_r+0x310>
   10c00:	ff04041b          	addiw	s0,s0,-16
   10c04:	0c013783          	ld	a5,192(sp)
   10c08:	0b812703          	lw	a4,184(sp)
   10c0c:	000b0893          	mv	a7,s6
   10c10:	00013803          	ld	a6,0(sp)
   10c14:	fa8dcae3          	blt	s11,s0,10bc8 <_vfprintf_r+0x84c>
   10c18:	01013683          	ld	a3,16(sp)
   10c1c:	008787b3          	add	a5,a5,s0
   10c20:	0017071b          	addiw	a4,a4,1
   10c24:	00d8b023          	sd	a3,0(a7)
   10c28:	0088b423          	sd	s0,8(a7)
   10c2c:	0cf13023          	sd	a5,192(sp)
   10c30:	0ae12c23          	sw	a4,184(sp)
   10c34:	00700693          	li	a3,7
   10c38:	01088893          	addi	a7,a7,16
   10c3c:	02e6d063          	ble	a4,a3,10c5c <_vfprintf_r+0x8e0>
   10c40:	0b010613          	addi	a2,sp,176
   10c44:	000a0593          	mv	a1,s4
   10c48:	000b8513          	mv	a0,s7
   10c4c:	155050ef          	jal	165a0 <__sprint_r>
   10c50:	a2051ee3          	bnez	a0,1068c <_vfprintf_r+0x310>
   10c54:	0c013783          	ld	a5,192(sp)
   10c58:	000b0893          	mv	a7,s6

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
   10c5c:	100c7713          	andi	a4,s8,256
   10c60:	40071663          	bnez	a4,1106c <_vfprintf_r+0xcf0>
			PRINT (cp, size);
   10c64:	02012703          	lw	a4,32(sp)
   10c68:	0b812683          	lw	a3,184(sp)
   10c6c:	0128b023          	sd	s2,0(a7)
   10c70:	00e787b3          	add	a5,a5,a4
   10c74:	0016869b          	addiw	a3,a3,1
   10c78:	00e8b423          	sd	a4,8(a7)
   10c7c:	0cf13023          	sd	a5,192(sp)
   10c80:	0ad12c23          	sw	a3,184(sp)
   10c84:	00700713          	li	a4,7
   10c88:	3cd74263          	blt	a4,a3,1104c <_vfprintf_r+0xcd0>
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
				PRINT (expstr, expsize);
   10c8c:	01088893          	addi	a7,a7,16
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   10c90:	004c7c13          	andi	s8,s8,4
   10c94:	0c0c0063          	beqz	s8,10d54 <_vfprintf_r+0x9d8>
			PAD (width - realsz, blanks);
   10c98:	01812703          	lw	a4,24(sp)
   10c9c:	00812683          	lw	a3,8(sp)
   10ca0:	40d7043b          	subw	s0,a4,a3
   10ca4:	0a805863          	blez	s0,10d54 <_vfprintf_r+0x9d8>
   10ca8:	01000713          	li	a4,16
   10cac:	748754e3          	ble	s0,a4,11bf4 <_vfprintf_r+0x1878>
   10cb0:	01000913          	li	s2,16
   10cb4:	0b812703          	lw	a4,184(sp)
   10cb8:	05513823          	sd	s5,80(sp)
   10cbc:	00700c13          	li	s8,7
   10cc0:	00090d13          	mv	s10,s2
   10cc4:	00c0006f          	j	10cd0 <_vfprintf_r+0x954>
   10cc8:	ff04041b          	addiw	s0,s0,-16
   10ccc:	048d5663          	ble	s0,s10,10d18 <_vfprintf_r+0x99c>
   10cd0:	01078793          	addi	a5,a5,16
   10cd4:	0017071b          	addiw	a4,a4,1
   10cd8:	0158b023          	sd	s5,0(a7)
   10cdc:	0128b423          	sd	s2,8(a7)
   10ce0:	0cf13023          	sd	a5,192(sp)
   10ce4:	0ae12c23          	sw	a4,184(sp)
   10ce8:	01088893          	addi	a7,a7,16
   10cec:	fcec5ee3          	ble	a4,s8,10cc8 <_vfprintf_r+0x94c>
   10cf0:	0b010613          	addi	a2,sp,176
   10cf4:	000a0593          	mv	a1,s4
   10cf8:	000b8513          	mv	a0,s7
   10cfc:	0a5050ef          	jal	165a0 <__sprint_r>
   10d00:	980516e3          	bnez	a0,1068c <_vfprintf_r+0x310>
   10d04:	ff04041b          	addiw	s0,s0,-16
   10d08:	0c013783          	ld	a5,192(sp)
   10d0c:	0b812703          	lw	a4,184(sp)
   10d10:	000b0893          	mv	a7,s6
   10d14:	fa8d4ee3          	blt	s10,s0,10cd0 <_vfprintf_r+0x954>
   10d18:	05013683          	ld	a3,80(sp)
   10d1c:	008787b3          	add	a5,a5,s0
   10d20:	0017071b          	addiw	a4,a4,1
   10d24:	00d8b023          	sd	a3,0(a7)
   10d28:	0088b423          	sd	s0,8(a7)
   10d2c:	0cf13023          	sd	a5,192(sp)
   10d30:	0ae12c23          	sw	a4,184(sp)
   10d34:	00700693          	li	a3,7
   10d38:	00e6de63          	ble	a4,a3,10d54 <_vfprintf_r+0x9d8>
   10d3c:	0b010613          	addi	a2,sp,176
   10d40:	000a0593          	mv	a1,s4
   10d44:	000b8513          	mv	a0,s7
   10d48:	059050ef          	jal	165a0 <__sprint_r>
   10d4c:	940510e3          	bnez	a0,1068c <_vfprintf_r+0x310>
   10d50:	0c013783          	ld	a5,192(sp)

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   10d54:	01812c83          	lw	s9,24(sp)
   10d58:	00812703          	lw	a4,8(sp)
   10d5c:	00ecd463          	ble	a4,s9,10d64 <_vfprintf_r+0x9e8>
   10d60:	00070c93          	mv	s9,a4
   10d64:	01c12703          	lw	a4,28(sp)
   10d68:	0197073b          	addw	a4,a4,s9
   10d6c:	00e12e23          	sw	a4,28(sp)

		FLUSH ();	/* copy out the I/O vectors */
   10d70:	52079863          	bnez	a5,112a0 <_vfprintf_r+0xf24>
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   10d74:	0009c783          	lbu	a5,0(s3)
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

		FLUSH ();	/* copy out the I/O vectors */
   10d78:	0a012c23          	sw	zero,184(sp)
   10d7c:	000b0893          	mv	a7,s6
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   10d80:	f2079263          	bnez	a5,104a4 <_vfprintf_r+0x128>
   10d84:	00098413          	mv	s0,s3
   10d88:	f80ff06f          	j	10508 <_vfprintf_r+0x18c>
   10d8c:	00060463          	beqz	a2,10d94 <_vfprintf_r+0xa18>
   10d90:	22c0106f          	j	11fbc <_vfprintf_r+0x1c40>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   10d94:	010c7793          	andi	a5,s8,16
   10d98:	12078e63          	beqz	a5,10ed4 <_vfprintf_r+0xb58>
   10d9c:	02813703          	ld	a4,40(sp)
   10da0:	00073783          	ld	a5,0(a4)
   10da4:	00870713          	addi	a4,a4,8
   10da8:	02e13423          	sd	a4,40(sp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
#else
			if ((long) _uquad < 0)
   10dac:	1407c0e3          	bltz	a5,116ec <_vfprintf_r+0x1370>
   10db0:	08f14603          	lbu	a2,143(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   10db4:	bc044ee3          	bltz	s0,10990 <_vfprintf_r+0x614>
				flags &= ~ZEROPAD;
   10db8:	f7fc7c13          	andi	s8,s8,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   10dbc:	ae0798e3          	bnez	a5,108ac <_vfprintf_r+0x530>
   10dc0:	6e041a63          	bnez	s0,114b4 <_vfprintf_r+0x1138>
   10dc4:	00000413          	li	s0,0
   10dc8:	02012023          	sw	zero,32(sp)
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   10dcc:	000b0913          	mv	s2,s6
   10dd0:	9a9ff06f          	j	10778 <_vfprintf_r+0x3fc>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
   10dd4:	040c6c13          	ori	s8,s8,64
			goto rflag;
   10dd8:	f60ff06f          	j	10538 <_vfprintf_r+0x1bc>
   10ddc:	00060463          	beqz	a2,10de4 <_vfprintf_r+0xa68>
   10de0:	1d40106f          	j	11fb4 <_vfprintf_r+0x1c38>
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
			} else {
				_fpvalue = GET_ARG (N, ap, double);
   10de4:	02813783          	ld	a5,40(sp)

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
   10de8:	00100913          	li	s2,1
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
			} else {
				_fpvalue = GET_ARG (N, ap, double);
   10dec:	0007b787          	fld	fa5,0(a5)
   10df0:	00878793          	addi	a5,a5,8
   10df4:	01113023          	sd	a7,0(sp)
   10df8:	04f13c27          	fsd	fa5,88(sp)

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
   10dfc:	05813c83          	ld	s9,88(sp)
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
			} else {
				_fpvalue = GET_ARG (N, ap, double);
   10e00:	02f13423          	sd	a5,40(sp)

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
   10e04:	f20c8553          	fmv.d.x	fa0,s9
   10e08:	2e8050ef          	jal	160f0 <__fpclassifyd>
   10e0c:	00013883          	ld	a7,0(sp)
   10e10:	0f251ce3          	bne	a0,s2,11708 <_vfprintf_r+0x138c>
				if (_fpvalue < 0)
   10e14:	f20007d3          	fmv.d.x	fa5,zero
   10e18:	f20c8753          	fmv.d.x	fa4,s9
   10e1c:	a2f717d3          	flt.d	a5,fa4,fa5
   10e20:	600792e3          	bnez	a5,11c24 <_vfprintf_r+0x18a8>
   10e24:	08f14603          	lbu	a2,143(sp)
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   10e28:	04700793          	li	a5,71
   10e2c:	3da7d8e3          	ble	s10,a5,119fc <_vfprintf_r+0x1680>
					cp = "INF";
				else
					cp = "inf";
   10e30:	00019937          	lui	s2,0x19
   10e34:	21090913          	addi	s2,s2,528 # 19210 <zeroes.4137+0x20>
				size = 3;
				flags &= ~ZEROPAD;
				break;
   10e38:	00300793          	li	a5,3
   10e3c:	00f12423          	sw	a5,8(sp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
				else
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
   10e40:	f7fc7c13          	andi	s8,s8,-129
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
				else
					cp = "inf";
				size = 3;
   10e44:	02f12023          	sw	a5,32(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   10e48:	00000413          	li	s0,0
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   10e4c:	04012623          	sw	zero,76(sp)
					cp = "INF";
				else
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   10e50:	941ff06f          	j	10790 <_vfprintf_r+0x414>
#endif /* !_NO_POS_ARGS */
			width = n;
			goto reswitch;
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
   10e54:	008c6c13          	ori	s8,s8,8
			goto rflag;
   10e58:	ee0ff06f          	j	10538 <_vfprintf_r+0x1bc>
   10e5c:	00060463          	beqz	a2,10e64 <_vfprintf_r+0xae8>
   10e60:	1280106f          	j	11f88 <_vfprintf_r+0x1c0c>
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
   10e64:	000197b7          	lui	a5,0x19
   10e68:	24078793          	addi	a5,a5,576 # 19240 <zeroes.4137+0x50>
   10e6c:	02f13c23          	sd	a5,56(sp)
hex:			_uquad = UARG ();
   10e70:	010c7793          	andi	a5,s8,16
   10e74:	b40792e3          	bnez	a5,109b8 <_vfprintf_r+0x63c>
   10e78:	040c7793          	andi	a5,s8,64
   10e7c:	02813703          	ld	a4,40(sp)
   10e80:	1c0784e3          	beqz	a5,11848 <_vfprintf_r+0x14cc>
   10e84:	00075783          	lhu	a5,0(a4)
   10e88:	00870713          	addi	a4,a4,8
   10e8c:	02e13423          	sd	a4,40(sp)
   10e90:	b39ff06f          	j	109c8 <_vfprintf_r+0x64c>
   10e94:	00060463          	beqz	a2,10e9c <_vfprintf_r+0xb20>
   10e98:	10c0106f          	j	11fa4 <_vfprintf_r+0x1c28>
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
   10e9c:	010c7793          	andi	a5,s8,16
   10ea0:	1a078ce3          	beqz	a5,11858 <_vfprintf_r+0x14dc>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   10ea4:	02813683          	ld	a3,40(sp)
   10ea8:	01c12703          	lw	a4,28(sp)
   10eac:	0006b783          	ld	a5,0(a3)
   10eb0:	00868693          	addi	a3,a3,8
   10eb4:	02d13423          	sd	a3,40(sp)
   10eb8:	00e7b023          	sd	a4,0(a5)
   10ebc:	de0ff06f          	j	1049c <_vfprintf_r+0x120>
   10ec0:	00060463          	beqz	a2,10ec8 <_vfprintf_r+0xb4c>
   10ec4:	0d40106f          	j	11f98 <_vfprintf_r+0x1c1c>
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   10ec8:	010c6c13          	ori	s8,s8,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   10ecc:	010c7793          	andi	a5,s8,16
   10ed0:	ec0796e3          	bnez	a5,10d9c <_vfprintf_r+0xa20>
   10ed4:	040c7793          	andi	a5,s8,64
   10ed8:	02813703          	ld	a4,40(sp)
   10edc:	1a0780e3          	beqz	a5,1187c <_vfprintf_r+0x1500>
   10ee0:	00071783          	lh	a5,0(a4)
   10ee4:	00870713          	addi	a4,a4,8
   10ee8:	02e13423          	sd	a4,40(sp)
   10eec:	ec1ff06f          	j	10dac <_vfprintf_r+0xa30>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   10ef0:	00019737          	lui	a4,0x19
   10ef4:	24070713          	addi	a4,a4,576 # 19240 <zeroes.4137+0x50>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   10ef8:	00000613          	li	a2,0
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   10efc:	02e13c23          	sd	a4,56(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   10f00:	07800d13          	li	s10,120
   10f04:	ee0ff06f          	j	105e4 <_vfprintf_r+0x268>
   10f08:	00060463          	beqz	a2,10f10 <_vfprintf_r+0xb94>
   10f0c:	0c00106f          	j	11fcc <_vfprintf_r+0x1c50>

			size = buf + BUF - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   10f10:	f60d0263          	beqz	s10,10674 <_vfprintf_r+0x2f8>
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   10f14:	00100793          	li	a5,1
   10f18:	00f12423          	sw	a5,8(sp)
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
   10f1c:	0da10423          	sb	s10,200(sp)
			size = 1;
			sign = '\0';
   10f20:	080107a3          	sb	zero,143(sp)
			break;
   10f24:	00000613          	li	a2,0
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
   10f28:	02f12023          	sw	a5,32(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   10f2c:	00000413          	li	s0,0
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   10f30:	04012623          	sw	zero,76(sp)
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
   10f34:	0c810913          	addi	s2,sp,200
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   10f38:	afdff06f          	j	10a34 <_vfprintf_r+0x6b8>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   10f3c:	02e13423          	sd	a4,40(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
   10f40:	00019737          	lui	a4,0x19
   10f44:	24070713          	addi	a4,a4,576 # 19240 <zeroes.4137+0x50>
			flags |= HEXPREFIX;
   10f48:	00068c13          	mv	s8,a3
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   10f4c:	02e13c23          	sd	a4,56(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   10f50:	07800d13          	li	s10,120
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   10f54:	3a079a63          	bnez	a5,11308 <_vfprintf_r+0xf8c>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   10f58:	00000613          	li	a2,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   10f5c:	00200793          	li	a5,2
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   10f60:	00100713          	li	a4,1
   10f64:	54e78863          	beq	a5,a4,114b4 <_vfprintf_r+0x1138>
   10f68:	00200713          	li	a4,2
   10f6c:	e6e78a63          	beq	a5,a4,105e0 <_vfprintf_r+0x264>
   10f70:	00000793          	li	a5,0
   10f74:	fc4ff06f          	j	10738 <_vfprintf_r+0x3bc>
   10f78:	0c013783          	ld	a5,192(sp)
   10f7c:	ba1ff06f          	j	10b1c <_vfprintf_r+0x7a0>
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   10f80:	07012683          	lw	a3,112(sp)
   10f84:	00100713          	li	a4,1
					PRINT (cp, 1);
   10f88:	00178793          	addi	a5,a5,1
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   10f8c:	6cd75663          	ble	a3,a4,11658 <_vfprintf_r+0x12dc>
					PRINT (cp, 1);
   10f90:	0b812703          	lw	a4,184(sp)
   10f94:	00100693          	li	a3,1
   10f98:	00d8b423          	sd	a3,8(a7)
   10f9c:	0017071b          	addiw	a4,a4,1
   10fa0:	0128b023          	sd	s2,0(a7)
   10fa4:	0cf13023          	sd	a5,192(sp)
   10fa8:	0ae12c23          	sw	a4,184(sp)
   10fac:	00700693          	li	a3,7
   10fb0:	01088893          	addi	a7,a7,16
   10fb4:	6ce6ca63          	blt	a3,a4,11688 <_vfprintf_r+0x130c>
					cp++;
					PRINT (decimal_point, decp_len);
   10fb8:	06813683          	ld	a3,104(sp)
   10fbc:	06013603          	ld	a2,96(sp)
   10fc0:	0017071b          	addiw	a4,a4,1
   10fc4:	00f687b3          	add	a5,a3,a5
   10fc8:	00d8b423          	sd	a3,8(a7)
   10fcc:	00c8b023          	sd	a2,0(a7)
   10fd0:	0cf13023          	sd	a5,192(sp)
   10fd4:	0ae12c23          	sw	a4,184(sp)
   10fd8:	00700693          	li	a3,7
   10fdc:	01088893          	addi	a7,a7,16
   10fe0:	6ee6c263          	blt	a3,a4,116c4 <_vfprintf_r+0x1348>
					if (_fpvalue) {
   10fe4:	f20007d3          	fmv.d.x	fa5,zero
   10fe8:	05813707          	fld	fa4,88(sp)
   10fec:	a2f726d3          	feq.d	a3,fa4,fa5
   10ff0:	40069c63          	bnez	a3,11408 <_vfprintf_r+0x108c>
						PRINT (cp, ndig - 1);
   10ff4:	07012683          	lw	a3,112(sp)
   10ff8:	00190913          	addi	s2,s2,1
   10ffc:	0017071b          	addiw	a4,a4,1
   11000:	fff6869b          	addiw	a3,a3,-1
   11004:	00d787b3          	add	a5,a5,a3
   11008:	0128b023          	sd	s2,0(a7)
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
   1100c:	00d8b423          	sd	a3,8(a7)
   11010:	0cf13023          	sd	a5,192(sp)
   11014:	0ae12c23          	sw	a4,184(sp)
   11018:	00700693          	li	a3,7
   1101c:	26e6c063          	blt	a3,a4,1127c <_vfprintf_r+0xf00>
   11020:	01088893          	addi	a7,a7,16
				PRINT (expstr, expsize);
   11024:	07412683          	lw	a3,116(sp)
   11028:	0a010613          	addi	a2,sp,160
   1102c:	0017071b          	addiw	a4,a4,1
   11030:	00f687b3          	add	a5,a3,a5
   11034:	00c8b023          	sd	a2,0(a7)
   11038:	00d8b423          	sd	a3,8(a7)
   1103c:	0cf13023          	sd	a5,192(sp)
   11040:	0ae12c23          	sw	a4,184(sp)
   11044:	00700693          	li	a3,7
   11048:	c4e6d2e3          	ble	a4,a3,10c8c <_vfprintf_r+0x910>
   1104c:	0b010613          	addi	a2,sp,176
   11050:	000a0593          	mv	a1,s4
   11054:	000b8513          	mv	a0,s7
   11058:	548050ef          	jal	165a0 <__sprint_r>
   1105c:	e2051863          	bnez	a0,1068c <_vfprintf_r+0x310>
   11060:	0c013783          	ld	a5,192(sp)
   11064:	000b0893          	mv	a7,s6
   11068:	c29ff06f          	j	10c90 <_vfprintf_r+0x914>
		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
			PRINT (cp, size);
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
   1106c:	06500713          	li	a4,101
   11070:	f1a758e3          	ble	s10,a4,10f80 <_vfprintf_r+0xc04>
				if (_fpvalue == 0) {
   11074:	f20007d3          	fmv.d.x	fa5,zero
   11078:	05813707          	fld	fa4,88(sp)
   1107c:	a2f72753          	feq.d	a4,fa4,fa5
   11080:	28070863          	beqz	a4,11310 <_vfprintf_r+0xf94>
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   11084:	0b812703          	lw	a4,184(sp)
   11088:	000196b7          	lui	a3,0x19
   1108c:	26068693          	addi	a3,a3,608 # 19260 <zeroes.4137+0x70>
   11090:	00d8b023          	sd	a3,0(a7)
   11094:	00178793          	addi	a5,a5,1
   11098:	00100693          	li	a3,1
   1109c:	0017071b          	addiw	a4,a4,1
   110a0:	00d8b423          	sd	a3,8(a7)
   110a4:	0cf13023          	sd	a5,192(sp)
   110a8:	0ae12c23          	sw	a4,184(sp)
   110ac:	00700693          	li	a3,7
   110b0:	01088893          	addi	a7,a7,16
   110b4:	7ee6ca63          	blt	a3,a4,118a8 <_vfprintf_r+0x152c>
					if (expt < ndig || flags & ALT) {
   110b8:	09812703          	lw	a4,152(sp)
   110bc:	07012683          	lw	a3,112(sp)
   110c0:	00d74663          	blt	a4,a3,110cc <_vfprintf_r+0xd50>
   110c4:	001c7713          	andi	a4,s8,1
   110c8:	bc0704e3          	beqz	a4,10c90 <_vfprintf_r+0x914>
						PRINT (decimal_point, decp_len);
   110cc:	06013703          	ld	a4,96(sp)
   110d0:	06813683          	ld	a3,104(sp)
   110d4:	01088893          	addi	a7,a7,16
   110d8:	fee8b823          	sd	a4,-16(a7)
   110dc:	0b812703          	lw	a4,184(sp)
   110e0:	00d787b3          	add	a5,a5,a3
   110e4:	fed8bc23          	sd	a3,-8(a7)
   110e8:	0017071b          	addiw	a4,a4,1
   110ec:	0cf13023          	sd	a5,192(sp)
   110f0:	0ae12c23          	sw	a4,184(sp)
   110f4:	00700693          	li	a3,7
   110f8:	1ce6c8e3          	blt	a3,a4,11ac8 <_vfprintf_r+0x174c>
						PAD (ndig - 1, zeroes);
   110fc:	07012703          	lw	a4,112(sp)
   11100:	fff7041b          	addiw	s0,a4,-1
   11104:	b88056e3          	blez	s0,10c90 <_vfprintf_r+0x914>
   11108:	01000713          	li	a4,16
   1110c:	36875c63          	ble	s0,a4,11484 <_vfprintf_r+0x1108>
   11110:	01000913          	li	s2,16
   11114:	0b812703          	lw	a4,184(sp)
   11118:	00913823          	sd	s1,16(sp)
   1111c:	00700d13          	li	s10,7
   11120:	00090693          	mv	a3,s2
   11124:	00c0006f          	j	11130 <_vfprintf_r+0xdb4>
   11128:	ff04041b          	addiw	s0,s0,-16
   1112c:	3686d063          	ble	s0,a3,1148c <_vfprintf_r+0x1110>
   11130:	01078793          	addi	a5,a5,16
   11134:	0017071b          	addiw	a4,a4,1
   11138:	0098b023          	sd	s1,0(a7)
   1113c:	0128b423          	sd	s2,8(a7)
   11140:	0cf13023          	sd	a5,192(sp)
   11144:	0ae12c23          	sw	a4,184(sp)
   11148:	01088893          	addi	a7,a7,16
   1114c:	fced5ee3          	ble	a4,s10,11128 <_vfprintf_r+0xdac>
   11150:	0b010613          	addi	a2,sp,176
   11154:	000a0593          	mv	a1,s4
   11158:	000b8513          	mv	a0,s7
   1115c:	00d13023          	sd	a3,0(sp)
   11160:	440050ef          	jal	165a0 <__sprint_r>
   11164:	d2051463          	bnez	a0,1068c <_vfprintf_r+0x310>
   11168:	0c013783          	ld	a5,192(sp)
   1116c:	0b812703          	lw	a4,184(sp)
   11170:	000b0893          	mv	a7,s6
   11174:	00013683          	ld	a3,0(sp)
   11178:	fb1ff06f          	j	11128 <_vfprintf_r+0xdac>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   1117c:	01812703          	lw	a4,24(sp)
   11180:	00812683          	lw	a3,8(sp)
   11184:	40d70cbb          	subw	s9,a4,a3
   11188:	a19056e3          	blez	s9,10b94 <_vfprintf_r+0x818>
   1118c:	01000713          	li	a4,16
   11190:	2f975ee3          	ble	s9,a4,11c8c <_vfprintf_r+0x1910>
   11194:	01000813          	li	a6,16
   11198:	0b812703          	lw	a4,184(sp)
   1119c:	00913823          	sd	s1,16(sp)
   111a0:	00700313          	li	t1,7
   111a4:	00080d93          	mv	s11,a6
   111a8:	00c0006f          	j	111b4 <_vfprintf_r+0xe38>
   111ac:	ff0c8c9b          	addiw	s9,s9,-16
   111b0:	059dde63          	ble	s9,s11,1120c <_vfprintf_r+0xe90>
   111b4:	01078793          	addi	a5,a5,16
   111b8:	0017071b          	addiw	a4,a4,1
   111bc:	0098b023          	sd	s1,0(a7)
   111c0:	0108b423          	sd	a6,8(a7)
   111c4:	0cf13023          	sd	a5,192(sp)
   111c8:	0ae12c23          	sw	a4,184(sp)
   111cc:	01088893          	addi	a7,a7,16
   111d0:	fce35ee3          	ble	a4,t1,111ac <_vfprintf_r+0xe30>
   111d4:	0b010613          	addi	a2,sp,176
   111d8:	000a0593          	mv	a1,s4
   111dc:	000b8513          	mv	a0,s7
   111e0:	04613023          	sd	t1,64(sp)
   111e4:	01013023          	sd	a6,0(sp)
   111e8:	3b8050ef          	jal	165a0 <__sprint_r>
   111ec:	ca051063          	bnez	a0,1068c <_vfprintf_r+0x310>
   111f0:	ff0c8c9b          	addiw	s9,s9,-16
   111f4:	0c013783          	ld	a5,192(sp)
   111f8:	0b812703          	lw	a4,184(sp)
   111fc:	000b0893          	mv	a7,s6
   11200:	04013303          	ld	t1,64(sp)
   11204:	00013803          	ld	a6,0(sp)
   11208:	fb9dc6e3          	blt	s11,s9,111b4 <_vfprintf_r+0xe38>
   1120c:	01013603          	ld	a2,16(sp)
   11210:	019787b3          	add	a5,a5,s9
   11214:	0017071b          	addiw	a4,a4,1
   11218:	00c8b023          	sd	a2,0(a7)
   1121c:	0198b423          	sd	s9,8(a7)
   11220:	0cf13023          	sd	a5,192(sp)
   11224:	0ae12c23          	sw	a4,184(sp)
   11228:	00700693          	li	a3,7
   1122c:	01088893          	addi	a7,a7,16
   11230:	96e6d2e3          	ble	a4,a3,10b94 <_vfprintf_r+0x818>
   11234:	0b010613          	addi	a2,sp,176
   11238:	000a0593          	mv	a1,s4
   1123c:	000b8513          	mv	a0,s7
   11240:	360050ef          	jal	165a0 <__sprint_r>
   11244:	c4051463          	bnez	a0,1068c <_vfprintf_r+0x310>
   11248:	0c013783          	ld	a5,192(sp)
   1124c:	000b0893          	mv	a7,s6
   11250:	945ff06f          	j	10b94 <_vfprintf_r+0x818>
   11254:	00913823          	sd	s1,16(sp)
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   11258:	01013683          	ld	a3,16(sp)
   1125c:	008787b3          	add	a5,a5,s0
   11260:	0017071b          	addiw	a4,a4,1
   11264:	00d8b023          	sd	a3,0(a7)
   11268:	0088b423          	sd	s0,8(a7)
   1126c:	0cf13023          	sd	a5,192(sp)
   11270:	0ae12c23          	sw	a4,184(sp)
   11274:	00700693          	li	a3,7
   11278:	dae6d4e3          	ble	a4,a3,11020 <_vfprintf_r+0xca4>
				} else	/* XeYYY */
					PRINT (cp, 1);
   1127c:	0b010613          	addi	a2,sp,176
   11280:	000a0593          	mv	a1,s4
   11284:	000b8513          	mv	a0,s7
   11288:	318050ef          	jal	165a0 <__sprint_r>
   1128c:	c0051063          	bnez	a0,1068c <_vfprintf_r+0x310>
   11290:	0c013783          	ld	a5,192(sp)
   11294:	0b812703          	lw	a4,184(sp)
   11298:	000b0893          	mv	a7,s6
   1129c:	d89ff06f          	j	11024 <_vfprintf_r+0xca8>
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

		FLUSH ();	/* copy out the I/O vectors */
   112a0:	0b010613          	addi	a2,sp,176
   112a4:	000a0593          	mv	a1,s4
   112a8:	000b8513          	mv	a0,s7
   112ac:	2f4050ef          	jal	165a0 <__sprint_r>
   112b0:	ac0502e3          	beqz	a0,10d74 <_vfprintf_r+0x9f8>
   112b4:	bd8ff06f          	j	1068c <_vfprintf_r+0x310>
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   112b8:	0b010613          	addi	a2,sp,176
   112bc:	000a0593          	mv	a1,s4
   112c0:	000b8513          	mv	a0,s7
   112c4:	2dc050ef          	jal	165a0 <__sprint_r>
   112c8:	bc051263          	bnez	a0,1068c <_vfprintf_r+0x310>
   112cc:	0c013783          	ld	a5,192(sp)
   112d0:	000b0893          	mv	a7,s6
   112d4:	87dff06f          	j	10b50 <_vfprintf_r+0x7d4>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   112d8:	0b010613          	addi	a2,sp,176
   112dc:	000a0593          	mv	a1,s4
   112e0:	000b8513          	mv	a0,s7
   112e4:	2bc050ef          	jal	165a0 <__sprint_r>
   112e8:	ba051263          	bnez	a0,1068c <_vfprintf_r+0x310>
   112ec:	0c013783          	ld	a5,192(sp)
   112f0:	000b0893          	mv	a7,s6
   112f4:	895ff06f          	j	10b88 <_vfprintf_r+0x80c>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   112f8:	080107a3          	sb	zero,143(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   112fc:	c4044ce3          	bltz	s0,10f54 <_vfprintf_r+0xbd8>
				flags &= ~ZEROPAD;
   11300:	f7fc7c13          	andi	s8,s8,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   11304:	ac078a63          	beqz	a5,105d8 <_vfprintf_r+0x25c>
   11308:	00000613          	li	a2,0
   1130c:	ad8ff06f          	j	105e4 <_vfprintf_r+0x268>
					PRINT ("0", 1);
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
   11310:	09812403          	lw	s0,152(sp)
   11314:	5a805c63          	blez	s0,118cc <_vfprintf_r+0x1550>
   11318:	04c12703          	lw	a4,76(sp)
   1131c:	07012683          	lw	a3,112(sp)
   11320:	00070413          	mv	s0,a4
   11324:	00e6d463          	ble	a4,a3,1132c <_vfprintf_r+0xfb0>
   11328:	00068413          	mv	s0,a3
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   1132c:	02805663          	blez	s0,11358 <_vfprintf_r+0xfdc>
   11330:	0b812703          	lw	a4,184(sp)
   11334:	008787b3          	add	a5,a5,s0
   11338:	0128b023          	sd	s2,0(a7)
   1133c:	0017071b          	addiw	a4,a4,1
   11340:	0088b423          	sd	s0,8(a7)
   11344:	0cf13023          	sd	a5,192(sp)
   11348:	0ae12c23          	sw	a4,184(sp)
   1134c:	00700693          	li	a3,7
   11350:	01088893          	addi	a7,a7,16
   11354:	6ae6ca63          	blt	a3,a4,11a08 <_vfprintf_r+0x168c>
   11358:	020448e3          	bltz	s0,11b88 <_vfprintf_r+0x180c>
   1135c:	04c12703          	lw	a4,76(sp)
   11360:	4087043b          	subw	s0,a4,s0
   11364:	1a805c63          	blez	s0,1151c <_vfprintf_r+0x11a0>
   11368:	01000713          	li	a4,16
   1136c:	16875263          	ble	s0,a4,114d0 <_vfprintf_r+0x1154>
   11370:	01000d13          	li	s10,16
   11374:	0b812703          	lw	a4,184(sp)
   11378:	00913823          	sd	s1,16(sp)
   1137c:	00700693          	li	a3,7
   11380:	000d0813          	mv	a6,s10
   11384:	00c0006f          	j	11390 <_vfprintf_r+0x1014>
   11388:	ff04041b          	addiw	s0,s0,-16
   1138c:	14885663          	ble	s0,a6,114d8 <_vfprintf_r+0x115c>
   11390:	01078793          	addi	a5,a5,16
   11394:	0017071b          	addiw	a4,a4,1
   11398:	0098b023          	sd	s1,0(a7)
   1139c:	01a8b423          	sd	s10,8(a7)
   113a0:	0cf13023          	sd	a5,192(sp)
   113a4:	0ae12c23          	sw	a4,184(sp)
   113a8:	01088893          	addi	a7,a7,16
   113ac:	fce6dee3          	ble	a4,a3,11388 <_vfprintf_r+0x100c>
   113b0:	0b010613          	addi	a2,sp,176
   113b4:	000a0593          	mv	a1,s4
   113b8:	000b8513          	mv	a0,s7
   113bc:	03013023          	sd	a6,32(sp)
   113c0:	00d13023          	sd	a3,0(sp)
   113c4:	1dc050ef          	jal	165a0 <__sprint_r>
   113c8:	ac051263          	bnez	a0,1068c <_vfprintf_r+0x310>
   113cc:	0c013783          	ld	a5,192(sp)
   113d0:	0b812703          	lw	a4,184(sp)
   113d4:	000b0893          	mv	a7,s6
   113d8:	02013803          	ld	a6,32(sp)
   113dc:	00013683          	ld	a3,0(sp)
   113e0:	fa9ff06f          	j	11388 <_vfprintf_r+0x100c>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   113e4:	0b010613          	addi	a2,sp,176
   113e8:	000a0593          	mv	a1,s4
   113ec:	000b8513          	mv	a0,s7
   113f0:	1b0050ef          	jal	165a0 <__sprint_r>
   113f4:	a8051c63          	bnez	a0,1068c <_vfprintf_r+0x310>
   113f8:	08f14603          	lbu	a2,143(sp)
   113fc:	0c013783          	ld	a5,192(sp)
   11400:	000b0893          	mv	a7,s6
   11404:	f18ff06f          	j	10b1c <_vfprintf_r+0x7a0>
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   11408:	07012683          	lw	a3,112(sp)
   1140c:	fff6841b          	addiw	s0,a3,-1
   11410:	c0805ae3          	blez	s0,11024 <_vfprintf_r+0xca8>
   11414:	01000693          	li	a3,16
   11418:	e286dee3          	ble	s0,a3,11254 <_vfprintf_r+0xed8>
   1141c:	01000913          	li	s2,16
   11420:	00913823          	sd	s1,16(sp)
   11424:	00700d13          	li	s10,7
   11428:	00090693          	mv	a3,s2
   1142c:	00c0006f          	j	11438 <_vfprintf_r+0x10bc>
   11430:	ff04041b          	addiw	s0,s0,-16
   11434:	e286d2e3          	ble	s0,a3,11258 <_vfprintf_r+0xedc>
   11438:	01078793          	addi	a5,a5,16
   1143c:	0017071b          	addiw	a4,a4,1
   11440:	0098b023          	sd	s1,0(a7)
   11444:	0128b423          	sd	s2,8(a7)
   11448:	0cf13023          	sd	a5,192(sp)
   1144c:	0ae12c23          	sw	a4,184(sp)
   11450:	01088893          	addi	a7,a7,16
   11454:	fced5ee3          	ble	a4,s10,11430 <_vfprintf_r+0x10b4>
   11458:	0b010613          	addi	a2,sp,176
   1145c:	000a0593          	mv	a1,s4
   11460:	000b8513          	mv	a0,s7
   11464:	00d13023          	sd	a3,0(sp)
   11468:	138050ef          	jal	165a0 <__sprint_r>
   1146c:	a2051063          	bnez	a0,1068c <_vfprintf_r+0x310>
   11470:	0c013783          	ld	a5,192(sp)
   11474:	0b812703          	lw	a4,184(sp)
   11478:	000b0893          	mv	a7,s6
   1147c:	00013683          	ld	a3,0(sp)
   11480:	fb1ff06f          	j	11430 <_vfprintf_r+0x10b4>
   11484:	0b812703          	lw	a4,184(sp)
   11488:	00913823          	sd	s1,16(sp)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   1148c:	01013683          	ld	a3,16(sp)
   11490:	008787b3          	add	a5,a5,s0
   11494:	0088b423          	sd	s0,8(a7)
   11498:	00d8b023          	sd	a3,0(a7)
   1149c:	0017071b          	addiw	a4,a4,1
   114a0:	0cf13023          	sd	a5,192(sp)
   114a4:	0ae12c23          	sw	a4,184(sp)
   114a8:	00700693          	li	a3,7
   114ac:	fee6d063          	ble	a4,a3,10c8c <_vfprintf_r+0x910>
   114b0:	b9dff06f          	j	1104c <_vfprintf_r+0xcd0>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   114b4:	00000793          	li	a5,0
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
						*--cp = to_char(_uquad);
   114b8:	0307879b          	addiw	a5,a5,48
   114bc:	0ef107a3          	sb	a5,239(sp)
   114c0:	07813783          	ld	a5,120(sp)
   114c4:	0ef10913          	addi	s2,sp,239
   114c8:	02f12023          	sw	a5,32(sp)
						break;
   114cc:	aacff06f          	j	10778 <_vfprintf_r+0x3fc>
   114d0:	0b812703          	lw	a4,184(sp)
   114d4:	00913823          	sd	s1,16(sp)
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   114d8:	01013683          	ld	a3,16(sp)
   114dc:	008787b3          	add	a5,a5,s0
   114e0:	0017071b          	addiw	a4,a4,1
   114e4:	00d8b023          	sd	a3,0(a7)
   114e8:	0088b423          	sd	s0,8(a7)
   114ec:	0cf13023          	sd	a5,192(sp)
   114f0:	0ae12c23          	sw	a4,184(sp)
   114f4:	00700693          	li	a3,7
   114f8:	01088893          	addi	a7,a7,16
   114fc:	02e6d063          	ble	a4,a3,1151c <_vfprintf_r+0x11a0>
   11500:	0b010613          	addi	a2,sp,176
   11504:	000a0593          	mv	a1,s4
   11508:	000b8513          	mv	a0,s7
   1150c:	094050ef          	jal	165a0 <__sprint_r>
   11510:	96051e63          	bnez	a0,1068c <_vfprintf_r+0x310>
   11514:	0c013783          	ld	a5,192(sp)
   11518:	000b0893          	mv	a7,s6
						    lead, zeroes);
					cp += lead;
   1151c:	04c12d03          	lw	s10,76(sp)
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
   11520:	09812703          	lw	a4,152(sp)
   11524:	07012683          	lw	a3,112(sp)
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
						    lead, zeroes);
					cp += lead;
   11528:	01a90d33          	add	s10,s2,s10
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
   1152c:	0cd74a63          	blt	a4,a3,11600 <_vfprintf_r+0x1284>
   11530:	001c7693          	andi	a3,s8,1
   11534:	0c069663          	bnez	a3,11600 <_vfprintf_r+0x1284>
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   11538:	07012683          	lw	a3,112(sp)
   1153c:	00d90433          	add	s0,s2,a3
   11540:	41a40433          	sub	s0,s0,s10
   11544:	40e6873b          	subw	a4,a3,a4
   11548:	0004041b          	sext.w	s0,s0
   1154c:	00875463          	ble	s0,a4,11554 <_vfprintf_r+0x11d8>
   11550:	00070413          	mv	s0,a4
   11554:	02805663          	blez	s0,11580 <_vfprintf_r+0x1204>
   11558:	0b812683          	lw	a3,184(sp)
   1155c:	008787b3          	add	a5,a5,s0
   11560:	01a8b023          	sd	s10,0(a7)
   11564:	0016869b          	addiw	a3,a3,1
   11568:	0088b423          	sd	s0,8(a7)
   1156c:	0cf13023          	sd	a5,192(sp)
   11570:	0ad12c23          	sw	a3,184(sp)
   11574:	00700613          	li	a2,7
   11578:	01088893          	addi	a7,a7,16
   1157c:	4cd64263          	blt	a2,a3,11a40 <_vfprintf_r+0x16c4>
   11580:	60044863          	bltz	s0,11b90 <_vfprintf_r+0x1814>
   11584:	4087043b          	subw	s0,a4,s0
   11588:	f0805463          	blez	s0,10c90 <_vfprintf_r+0x914>
   1158c:	01000713          	li	a4,16
   11590:	ee875ae3          	ble	s0,a4,11484 <_vfprintf_r+0x1108>
   11594:	01000913          	li	s2,16
   11598:	0b812703          	lw	a4,184(sp)
   1159c:	00913823          	sd	s1,16(sp)
   115a0:	00700d13          	li	s10,7
   115a4:	00090693          	mv	a3,s2
   115a8:	00c0006f          	j	115b4 <_vfprintf_r+0x1238>
   115ac:	ff04041b          	addiw	s0,s0,-16
   115b0:	ec86dee3          	ble	s0,a3,1148c <_vfprintf_r+0x1110>
   115b4:	01078793          	addi	a5,a5,16
   115b8:	0017071b          	addiw	a4,a4,1
   115bc:	0098b023          	sd	s1,0(a7)
   115c0:	0128b423          	sd	s2,8(a7)
   115c4:	0cf13023          	sd	a5,192(sp)
   115c8:	0ae12c23          	sw	a4,184(sp)
   115cc:	01088893          	addi	a7,a7,16
   115d0:	fced5ee3          	ble	a4,s10,115ac <_vfprintf_r+0x1230>
   115d4:	0b010613          	addi	a2,sp,176
   115d8:	000a0593          	mv	a1,s4
   115dc:	000b8513          	mv	a0,s7
   115e0:	00d13023          	sd	a3,0(sp)
   115e4:	7bd040ef          	jal	165a0 <__sprint_r>
   115e8:	8a051263          	bnez	a0,1068c <_vfprintf_r+0x310>
   115ec:	0c013783          	ld	a5,192(sp)
   115f0:	0b812703          	lw	a4,184(sp)
   115f4:	000b0893          	mv	a7,s6
   115f8:	00013683          	ld	a3,0(sp)
   115fc:	fb1ff06f          	j	115ac <_vfprintf_r+0x1230>
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
   11600:	06013683          	ld	a3,96(sp)
   11604:	06813603          	ld	a2,104(sp)
   11608:	01088893          	addi	a7,a7,16
   1160c:	fed8b823          	sd	a3,-16(a7)
   11610:	0b812683          	lw	a3,184(sp)
   11614:	00c787b3          	add	a5,a5,a2
   11618:	fec8bc23          	sd	a2,-8(a7)
   1161c:	0016869b          	addiw	a3,a3,1
   11620:	0cf13023          	sd	a5,192(sp)
   11624:	0ad12c23          	sw	a3,184(sp)
   11628:	00700613          	li	a2,7
   1162c:	f0d656e3          	ble	a3,a2,11538 <_vfprintf_r+0x11bc>
   11630:	0b010613          	addi	a2,sp,176
   11634:	000a0593          	mv	a1,s4
   11638:	000b8513          	mv	a0,s7
   1163c:	765040ef          	jal	165a0 <__sprint_r>
   11640:	00050463          	beqz	a0,11648 <_vfprintf_r+0x12cc>
   11644:	848ff06f          	j	1068c <_vfprintf_r+0x310>
   11648:	09812703          	lw	a4,152(sp)
   1164c:	0c013783          	ld	a5,192(sp)
   11650:	000b0893          	mv	a7,s6
   11654:	ee5ff06f          	j	11538 <_vfprintf_r+0x11bc>
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   11658:	00ec7733          	and	a4,s8,a4
   1165c:	92071ae3          	bnez	a4,10f90 <_vfprintf_r+0xc14>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
   11660:	0b812703          	lw	a4,184(sp)
   11664:	0128b023          	sd	s2,0(a7)
   11668:	00100693          	li	a3,1
   1166c:	0017071b          	addiw	a4,a4,1
   11670:	99dff06f          	j	1100c <_vfprintf_r+0xc90>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   11674:	02813783          	ld	a5,40(sp)
   11678:	00878713          	addi	a4,a5,8
   1167c:	0007e783          	lwu	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   11680:	a0045e63          	bgez	s0,1089c <_vfprintf_r+0x520>
   11684:	b04ff06f          	j	10988 <_vfprintf_r+0x60c>
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
   11688:	0b010613          	addi	a2,sp,176
   1168c:	000a0593          	mv	a1,s4
   11690:	000b8513          	mv	a0,s7
   11694:	70d040ef          	jal	165a0 <__sprint_r>
   11698:	00050463          	beqz	a0,116a0 <_vfprintf_r+0x1324>
   1169c:	ff1fe06f          	j	1068c <_vfprintf_r+0x310>
   116a0:	0c013783          	ld	a5,192(sp)
   116a4:	0b812703          	lw	a4,184(sp)
   116a8:	000b0893          	mv	a7,s6
   116ac:	90dff06f          	j	10fb8 <_vfprintf_r+0xc3c>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   116b0:	02813783          	ld	a5,40(sp)
   116b4:	00878713          	addi	a4,a5,8
   116b8:	0007e783          	lwu	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   116bc:	86045063          	bgez	s0,1071c <_vfprintf_r+0x3a0>
   116c0:	a84ff06f          	j	10944 <_vfprintf_r+0x5c8>
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
   116c4:	0b010613          	addi	a2,sp,176
   116c8:	000a0593          	mv	a1,s4
   116cc:	000b8513          	mv	a0,s7
   116d0:	6d1040ef          	jal	165a0 <__sprint_r>
   116d4:	00050463          	beqz	a0,116dc <_vfprintf_r+0x1360>
   116d8:	fb5fe06f          	j	1068c <_vfprintf_r+0x310>
   116dc:	0c013783          	ld	a5,192(sp)
   116e0:	0b812703          	lw	a4,184(sp)
   116e4:	000b0893          	mv	a7,s6
   116e8:	8fdff06f          	j	10fe4 <_vfprintf_r+0xc68>
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
				sign = '-';
   116ec:	02d00713          	li	a4,45
   116f0:	08e107a3          	sb	a4,143(sp)
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   116f4:	40f007b3          	neg	a5,a5
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   116f8:	4a044063          	bltz	s0,11b98 <_vfprintf_r+0x181c>
				flags &= ~ZEROPAD;
   116fc:	f7fc7c13          	andi	s8,s8,-129
   11700:	02d00613          	li	a2,45
   11704:	9a8ff06f          	j	108ac <_vfprintf_r+0x530>
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
			if (isnan (_fpvalue)) {
   11708:	05813507          	fld	fa0,88(sp)
   1170c:	01113023          	sd	a7,0(sp)
   11710:	1e1040ef          	jal	160f0 <__fpclassifyd>
   11714:	00013883          	ld	a7,0(sp)
   11718:	2a050463          	beqz	a0,119c0 <_vfprintf_r+0x1644>
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
   1171c:	fff00793          	li	a5,-1
   11720:	fdfd7d93          	andi	s11,s10,-33
   11724:	62f40c63          	beq	s0,a5,11d5c <_vfprintf_r+0x19e0>
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   11728:	04700793          	li	a5,71
   1172c:	62fd8263          	beq	s11,a5,11d50 <_vfprintf_r+0x19d4>
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
   11730:	05813703          	ld	a4,88(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   11734:	100c6693          	ori	a3,s8,256
   11738:	00d12023          	sw	a3,0(sp)
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   1173c:	42075793          	srai	a5,a4,0x20
   11740:	f2070453          	fmv.d.x	fs0,a4
		value = -value;
		*sign = '-';
	} else
		*sign = '\000';
   11744:	00000c93          	li	s9,0
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   11748:	6607c663          	bltz	a5,11db4 <_vfprintf_r+0x1a38>
		}
		*length = bp - buf;
		return buf;
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
   1174c:	06600793          	li	a5,102
   11750:	60fd0a63          	beq	s10,a5,11d64 <_vfprintf_r+0x19e8>
   11754:	04600793          	li	a5,70
   11758:	72fd0863          	beq	s10,a5,11e88 <_vfprintf_r+0x1b0c>
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
			ndigits++;
   1175c:	fbbd859b          	addiw	a1,s11,-69
   11760:	0015b593          	seqz	a1,a1
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   11764:	228405d3          	fmv.d	fa1,fs0
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
			ndigits++;
   11768:	00b405bb          	addw	a1,s0,a1
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   1176c:	09c10793          	addi	a5,sp,156
   11770:	00058693          	mv	a3,a1
   11774:	0a810813          	addi	a6,sp,168
   11778:	09810713          	addi	a4,sp,152
   1177c:	00200613          	li	a2,2
   11780:	000b8513          	mv	a0,s7
   11784:	01113823          	sd	a7,16(sp)
   11788:	00b13423          	sd	a1,8(sp)
   1178c:	745000ef          	jal	126d0 <_dtoa_r>

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   11790:	06700793          	li	a5,103
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   11794:	00050913          	mv	s2,a0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   11798:	00813583          	ld	a1,8(sp)
   1179c:	01013883          	ld	a7,16(sp)
   117a0:	46fd0863          	beq	s10,a5,11c10 <_vfprintf_r+0x1894>
   117a4:	04700793          	li	a5,71
		bp = digits + ndigits;
   117a8:	00b50733          	add	a4,a0,a1
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   117ac:	48fd0a63          	beq	s10,a5,11c40 <_vfprintf_r+0x18c4>
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
   117b0:	f20007d3          	fmv.d.x	fa5,zero
   117b4:	00070793          	mv	a5,a4
   117b8:	a2f426d3          	feq.d	a3,fs0,fa5
   117bc:	02069263          	bnez	a3,117e0 <_vfprintf_r+0x1464>
			rve = bp;
		while (rve < bp)
   117c0:	0a813783          	ld	a5,168(sp)
   117c4:	00e7fe63          	bleu	a4,a5,117e0 <_vfprintf_r+0x1464>
			*rve++ = '0';
   117c8:	03000613          	li	a2,48
   117cc:	00178693          	addi	a3,a5,1
   117d0:	0ad13423          	sd	a3,168(sp)
   117d4:	00c78023          	sb	a2,0(a5)
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
   117d8:	0a813783          	ld	a5,168(sp)
   117dc:	fee7e8e3          	bltu	a5,a4,117cc <_vfprintf_r+0x1450>
			*rve++ = '0';
	}
	*length = rve - digits;
   117e0:	412787b3          	sub	a5,a5,s2
   117e4:	06f12823          	sw	a5,112(sp)
			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   117e8:	04700793          	li	a5,71
   117ec:	46fd8663          	beq	s11,a5,11c58 <_vfprintf_r+0x18dc>
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
   117f0:	06500793          	li	a5,101
   117f4:	7ba7dc63          	ble	s10,a5,11fac <_vfprintf_r+0x1c30>
					++size;
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
   117f8:	06600793          	li	a5,102
   117fc:	60fd0263          	beq	s10,a5,11e00 <_vfprintf_r+0x1a84>
   11800:	09812783          	lw	a5,152(sp)
   11804:	04f12623          	sw	a5,76(sp)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
   11808:	04c12703          	lw	a4,76(sp)
   1180c:	07012683          	lw	a3,112(sp)
   11810:	00070793          	mv	a5,a4
   11814:	5ad74663          	blt	a4,a3,11dc0 <_vfprintf_r+0x1a44>
					size = expt;
					if (flags & ALT)
   11818:	001c7c13          	andi	s8,s8,1
   1181c:	5c0c1463          	bnez	s8,11de4 <_vfprintf_r+0x1a68>
   11820:	76074863          	bltz	a4,11f90 <_vfprintf_r+0x1c14>
   11824:	04c12703          	lw	a4,76(sp)
   11828:	06700d13          	li	s10,103
   1182c:	02e12023          	sw	a4,32(sp)
				} else
# endif
					lead = expt;
			}

			if (softsign)
   11830:	440c9063          	bnez	s9,11c70 <_vfprintf_r+0x18f4>
   11834:	08f14603          	lbu	a2,143(sp)
   11838:	00f12423          	sw	a5,8(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   1183c:	00012c03          	lw	s8,0(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   11840:	00000413          	li	s0,0
   11844:	f4dfe06f          	j	10790 <_vfprintf_r+0x414>
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   11848:	00076783          	lwu	a5,0(a4)
   1184c:	00870713          	addi	a4,a4,8
   11850:	02e13423          	sd	a4,40(sp)
   11854:	974ff06f          	j	109c8 <_vfprintf_r+0x64c>
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
				*GET_ARG (N, ap, short_ptr_t) = ret;
   11858:	02813703          	ld	a4,40(sp)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
   1185c:	040c7c13          	andi	s8,s8,64
				*GET_ARG (N, ap, short_ptr_t) = ret;
   11860:	00073783          	ld	a5,0(a4)
   11864:	00870713          	addi	a4,a4,8
   11868:	02e13423          	sd	a4,40(sp)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
   1186c:	180c0263          	beqz	s8,119f0 <_vfprintf_r+0x1674>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   11870:	01c15703          	lhu	a4,28(sp)
   11874:	00e79023          	sh	a4,0(a5)
   11878:	c25fe06f          	j	1049c <_vfprintf_r+0x120>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   1187c:	00072783          	lw	a5,0(a4)
   11880:	00870713          	addi	a4,a4,8
   11884:	02e13423          	sd	a4,40(sp)
   11888:	d24ff06f          	j	10dac <_vfprintf_r+0xa30>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1188c:	080107a3          	sb	zero,143(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   11890:	ec044463          	bltz	s0,10f58 <_vfprintf_r+0xbdc>
				flags &= ~ZEROPAD;
   11894:	f7fc7c13          	andi	s8,s8,-129
   11898:	d41fe06f          	j	105d8 <_vfprintf_r+0x25c>
   1189c:	0b812703          	lw	a4,184(sp)
   118a0:	00913823          	sd	s1,16(sp)
   118a4:	b74ff06f          	j	10c18 <_vfprintf_r+0x89c>
			PRINT (cp, size);
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
				if (_fpvalue == 0) {
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   118a8:	0b010613          	addi	a2,sp,176
   118ac:	000a0593          	mv	a1,s4
   118b0:	000b8513          	mv	a0,s7
   118b4:	4ed040ef          	jal	165a0 <__sprint_r>
   118b8:	00050463          	beqz	a0,118c0 <_vfprintf_r+0x1544>
   118bc:	dd1fe06f          	j	1068c <_vfprintf_r+0x310>
   118c0:	0c013783          	ld	a5,192(sp)
   118c4:	000b0893          	mv	a7,s6
   118c8:	ff0ff06f          	j	110b8 <_vfprintf_r+0xd3c>
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
   118cc:	0b812703          	lw	a4,184(sp)
   118d0:	000196b7          	lui	a3,0x19
   118d4:	26068693          	addi	a3,a3,608 # 19260 <zeroes.4137+0x70>
   118d8:	00d8b023          	sd	a3,0(a7)
   118dc:	00178793          	addi	a5,a5,1
   118e0:	00100693          	li	a3,1
   118e4:	0017071b          	addiw	a4,a4,1
   118e8:	00d8b423          	sd	a3,8(a7)
   118ec:	0cf13023          	sd	a5,192(sp)
   118f0:	0ae12c23          	sw	a4,184(sp)
   118f4:	00700693          	li	a3,7
   118f8:	01088893          	addi	a7,a7,16
   118fc:	16e6ca63          	blt	a3,a4,11a70 <_vfprintf_r+0x16f4>
					if (expt || ndig || flags & ALT) {
   11900:	12040663          	beqz	s0,11a2c <_vfprintf_r+0x16b0>
						PRINT (decimal_point, decp_len);
   11904:	06013703          	ld	a4,96(sp)
   11908:	06813683          	ld	a3,104(sp)
   1190c:	01088893          	addi	a7,a7,16
   11910:	fee8b823          	sd	a4,-16(a7)
   11914:	0b812703          	lw	a4,184(sp)
   11918:	00f687b3          	add	a5,a3,a5
   1191c:	fed8bc23          	sd	a3,-8(a7)
   11920:	0017071b          	addiw	a4,a4,1
   11924:	0cf13023          	sd	a5,192(sp)
   11928:	0ae12c23          	sw	a4,184(sp)
   1192c:	00700693          	li	a3,7
   11930:	3ee6ca63          	blt	a3,a4,11d24 <_vfprintf_r+0x19a8>
						PAD (-expt, zeroes);
   11934:	4080043b          	negw	s0,s0
   11938:	20805263          	blez	s0,11b3c <_vfprintf_r+0x17c0>
   1193c:	01000693          	li	a3,16
   11940:	1a86d663          	ble	s0,a3,11aec <_vfprintf_r+0x1770>
   11944:	01000d13          	li	s10,16
   11948:	00913823          	sd	s1,16(sp)
   1194c:	00700813          	li	a6,7
   11950:	000d0693          	mv	a3,s10
   11954:	00c0006f          	j	11960 <_vfprintf_r+0x15e4>
   11958:	ff04041b          	addiw	s0,s0,-16
   1195c:	1886da63          	ble	s0,a3,11af0 <_vfprintf_r+0x1774>
   11960:	01078793          	addi	a5,a5,16
   11964:	0017071b          	addiw	a4,a4,1
   11968:	0098b023          	sd	s1,0(a7)
   1196c:	01a8b423          	sd	s10,8(a7)
   11970:	0cf13023          	sd	a5,192(sp)
   11974:	0ae12c23          	sw	a4,184(sp)
   11978:	01088893          	addi	a7,a7,16
   1197c:	fce85ee3          	ble	a4,a6,11958 <_vfprintf_r+0x15dc>
   11980:	0b010613          	addi	a2,sp,176
   11984:	000a0593          	mv	a1,s4
   11988:	000b8513          	mv	a0,s7
   1198c:	02d13023          	sd	a3,32(sp)
   11990:	01013023          	sd	a6,0(sp)
   11994:	40d040ef          	jal	165a0 <__sprint_r>
   11998:	00050463          	beqz	a0,119a0 <_vfprintf_r+0x1624>
   1199c:	cf1fe06f          	j	1068c <_vfprintf_r+0x310>
   119a0:	0c013783          	ld	a5,192(sp)
   119a4:	0b812703          	lw	a4,184(sp)
   119a8:	000b0893          	mv	a7,s6
   119ac:	02013683          	ld	a3,32(sp)
   119b0:	00013803          	ld	a6,0(sp)
   119b4:	fa5ff06f          	j	11958 <_vfprintf_r+0x15dc>
	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
		_newlib_flockfile_exit (fp);
		return (EOF);
   119b8:	fff00513          	li	a0,-1
   119bc:	ce5fe06f          	j	106a0 <_vfprintf_r+0x324>
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   119c0:	04700793          	li	a5,71
   119c4:	27a7c863          	blt	a5,s10,11c34 <_vfprintf_r+0x18b8>
					cp = "NAN";
   119c8:	00019937          	lui	s2,0x19
   119cc:	21890913          	addi	s2,s2,536 # 19218 <zeroes.4137+0x28>
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   119d0:	00300793          	li	a5,3
   119d4:	00f12423          	sw	a5,8(sp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
   119d8:	f7fc7c13          	andi	s8,s8,-129
   119dc:	08f14603          	lbu	a2,143(sp)
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
   119e0:	02f12023          	sw	a5,32(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   119e4:	00000413          	li	s0,0
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   119e8:	04012623          	sw	zero,76(sp)
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   119ec:	da5fe06f          	j	10790 <_vfprintf_r+0x414>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   119f0:	01c12703          	lw	a4,28(sp)
   119f4:	00e7a023          	sw	a4,0(a5)
   119f8:	aa5fe06f          	j	1049c <_vfprintf_r+0x120>
			 */
			if (isinf (_fpvalue)) {
				if (_fpvalue < 0)
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
   119fc:	00019937          	lui	s2,0x19
   11a00:	20890913          	addi	s2,s2,520 # 19208 <zeroes.4137+0x18>
   11a04:	c34ff06f          	j	10e38 <_vfprintf_r+0xabc>
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   11a08:	0b010613          	addi	a2,sp,176
   11a0c:	000a0593          	mv	a1,s4
   11a10:	000b8513          	mv	a0,s7
   11a14:	38d040ef          	jal	165a0 <__sprint_r>
   11a18:	00050463          	beqz	a0,11a20 <_vfprintf_r+0x16a4>
   11a1c:	c71fe06f          	j	1068c <_vfprintf_r+0x310>
   11a20:	0c013783          	ld	a5,192(sp)
   11a24:	000b0893          	mv	a7,s6
   11a28:	931ff06f          	j	11358 <_vfprintf_r+0xfdc>
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
   11a2c:	07012703          	lw	a4,112(sp)
   11a30:	ec071ae3          	bnez	a4,11904 <_vfprintf_r+0x1588>
   11a34:	001c7713          	andi	a4,s8,1
   11a38:	a4070c63          	beqz	a4,10c90 <_vfprintf_r+0x914>
   11a3c:	ec9ff06f          	j	11904 <_vfprintf_r+0x1588>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   11a40:	0b010613          	addi	a2,sp,176
   11a44:	000a0593          	mv	a1,s4
   11a48:	000b8513          	mv	a0,s7
   11a4c:	355040ef          	jal	165a0 <__sprint_r>
   11a50:	00050463          	beqz	a0,11a58 <_vfprintf_r+0x16dc>
   11a54:	c39fe06f          	j	1068c <_vfprintf_r+0x310>
   11a58:	09812703          	lw	a4,152(sp)
   11a5c:	07012683          	lw	a3,112(sp)
   11a60:	0c013783          	ld	a5,192(sp)
   11a64:	000b0893          	mv	a7,s6
   11a68:	40e6873b          	subw	a4,a3,a4
   11a6c:	b15ff06f          	j	11580 <_vfprintf_r+0x1204>
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
   11a70:	0b010613          	addi	a2,sp,176
   11a74:	000a0593          	mv	a1,s4
   11a78:	000b8513          	mv	a0,s7
   11a7c:	325040ef          	jal	165a0 <__sprint_r>
   11a80:	00050463          	beqz	a0,11a88 <_vfprintf_r+0x170c>
   11a84:	c09fe06f          	j	1068c <_vfprintf_r+0x310>
   11a88:	09812403          	lw	s0,152(sp)
   11a8c:	0c013783          	ld	a5,192(sp)
   11a90:	000b0893          	mv	a7,s6
					if (expt || ndig || flags & ALT) {
   11a94:	e60418e3          	bnez	s0,11904 <_vfprintf_r+0x1588>
   11a98:	f95ff06f          	j	11a2c <_vfprintf_r+0x16b0>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   11a9c:	001c7793          	andi	a5,s8,1
   11aa0:	00078e63          	beqz	a5,11abc <_vfprintf_r+0x1740>
                         *--cp = '0';
   11aa4:	03000793          	li	a5,48
   11aa8:	0ef107a3          	sb	a5,239(sp)
   11aac:	07813783          	ld	a5,120(sp)
   11ab0:	0ef10913          	addi	s2,sp,239
   11ab4:	02f12023          	sw	a5,32(sp)
   11ab8:	cc1fe06f          	j	10778 <_vfprintf_r+0x3fc>
   11abc:	02012023          	sw	zero,32(sp)
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   11ac0:	000b0913          	mv	s2,s6
   11ac4:	cb5fe06f          	j	10778 <_vfprintf_r+0x3fc>
			if (ch >= 'f') {	/* 'f' or 'g' */
				if (_fpvalue == 0) {
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
   11ac8:	0b010613          	addi	a2,sp,176
   11acc:	000a0593          	mv	a1,s4
   11ad0:	000b8513          	mv	a0,s7
   11ad4:	2cd040ef          	jal	165a0 <__sprint_r>
   11ad8:	00050463          	beqz	a0,11ae0 <_vfprintf_r+0x1764>
   11adc:	bb1fe06f          	j	1068c <_vfprintf_r+0x310>
   11ae0:	0c013783          	ld	a5,192(sp)
   11ae4:	000b0893          	mv	a7,s6
   11ae8:	e14ff06f          	j	110fc <_vfprintf_r+0xd80>
   11aec:	00913823          	sd	s1,16(sp)
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (-expt, zeroes);
   11af0:	01013683          	ld	a3,16(sp)
   11af4:	008787b3          	add	a5,a5,s0
   11af8:	0017071b          	addiw	a4,a4,1
   11afc:	00d8b023          	sd	a3,0(a7)
   11b00:	0088b423          	sd	s0,8(a7)
   11b04:	0cf13023          	sd	a5,192(sp)
   11b08:	0ae12c23          	sw	a4,184(sp)
   11b0c:	00700693          	li	a3,7
   11b10:	01088893          	addi	a7,a7,16
   11b14:	02e6d463          	ble	a4,a3,11b3c <_vfprintf_r+0x17c0>
   11b18:	0b010613          	addi	a2,sp,176
   11b1c:	000a0593          	mv	a1,s4
   11b20:	000b8513          	mv	a0,s7
   11b24:	27d040ef          	jal	165a0 <__sprint_r>
   11b28:	00050463          	beqz	a0,11b30 <_vfprintf_r+0x17b4>
   11b2c:	b61fe06f          	j	1068c <_vfprintf_r+0x310>
   11b30:	0c013783          	ld	a5,192(sp)
   11b34:	0b812703          	lw	a4,184(sp)
   11b38:	000b0893          	mv	a7,s6
						PRINT (cp, ndig);
   11b3c:	07012683          	lw	a3,112(sp)
   11b40:	0017071b          	addiw	a4,a4,1
   11b44:	0128b023          	sd	s2,0(a7)
   11b48:	00f687b3          	add	a5,a3,a5
   11b4c:	cecff06f          	j	11038 <_vfprintf_r+0xcbc>
				if (p != NULL)
					size = p - cp;
				else
					size = prec;
			} else
				size = strlen (cp);
   11b50:	00090513          	mv	a0,s2
   11b54:	091040ef          	jal	163e4 <strlen>
   11b58:	0005079b          	sext.w	a5,a0
   11b5c:	02f12023          	sw	a5,32(sp)
   11b60:	00078d93          	mv	s11,a5
   11b64:	00013883          	ld	a7,0(sp)
   11b68:	0007c463          	bltz	a5,11b70 <_vfprintf_r+0x17f4>
   11b6c:	cf5fe06f          	j	10860 <_vfprintf_r+0x4e4>
   11b70:	00000d93          	li	s11,0
   11b74:	cedfe06f          	j	10860 <_vfprintf_r+0x4e4>
   11b78:	0c013783          	ld	a5,192(sp)
   11b7c:	0b812703          	lw	a4,184(sp)
   11b80:	05513823          	sd	s5,80(sp)
   11b84:	f6dfe06f          	j	10af0 <_vfprintf_r+0x774>
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   11b88:	00000413          	li	s0,0
   11b8c:	fd0ff06f          	j	1135c <_vfprintf_r+0xfe0>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   11b90:	00000413          	li	s0,0
   11b94:	9f1ff06f          	j	11584 <_vfprintf_r+0x1208>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   11b98:	02d00613          	li	a2,45
			{

				_uquad = -_uquad;
				sign = '-';
			}
			base = DEC;
   11b9c:	00100713          	li	a4,1
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   11ba0:	00100693          	li	a3,1
   11ba4:	00d71463          	bne	a4,a3,11bac <_vfprintf_r+0x1830>
   11ba8:	d05fe06f          	j	108ac <_vfprintf_r+0x530>
   11bac:	00200693          	li	a3,2
   11bb0:	00d71463          	bne	a4,a3,11bb8 <_vfprintf_r+0x183c>
   11bb4:	a31fe06f          	j	105e4 <_vfprintf_r+0x268>
   11bb8:	b81fe06f          	j	10738 <_vfprintf_r+0x3bc>
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
				size = ((unsigned) prec > 6U) ? 6 : prec;
   11bbc:	00600713          	li	a4,6
   11bc0:	00877463          	bleu	s0,a4,11bc8 <_vfprintf_r+0x184c>
   11bc4:	00070413          	mv	s0,a4
   11bc8:	02812023          	sw	s0,32(sp)
   11bcc:	00040d93          	mv	s11,s0
   11bd0:	32044a63          	bltz	s0,11f04 <_vfprintf_r+0x1b88>
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   11bd4:	00019937          	lui	s2,0x19
   11bd8:	01b12423          	sw	s11,8(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   11bdc:	03913423          	sd	s9,40(sp)
   11be0:	00000613          	li	a2,0
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   11be4:	00000413          	li	s0,0
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   11be8:	04012623          	sw	zero,76(sp)
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   11bec:	25890913          	addi	s2,s2,600 # 19258 <zeroes.4137+0x68>
   11bf0:	e45fe06f          	j	10a34 <_vfprintf_r+0x6b8>
   11bf4:	0b812703          	lw	a4,184(sp)
   11bf8:	05513823          	sd	s5,80(sp)
   11bfc:	91cff06f          	j	10d18 <_vfprintf_r+0x99c>
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
				ox[1] = ch;
				flags |= HEXPREFIX;
   11c00:	00070c13          	mv	s8,a4
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   11c04:	00000613          	li	a2,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   11c08:	00200713          	li	a4,2
   11c0c:	f95ff06f          	j	11ba0 <_vfprintf_r+0x1824>
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   11c10:	001c7793          	andi	a5,s8,1
		bp = digits + ndigits;
   11c14:	00b50733          	add	a4,a0,a1
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   11c18:	b8079ce3          	bnez	a5,117b0 <_vfprintf_r+0x1434>
   11c1c:	0a813783          	ld	a5,168(sp)
   11c20:	bc1ff06f          	j	117e0 <_vfprintf_r+0x1464>
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
				if (_fpvalue < 0)
					sign = '-';
   11c24:	02d00793          	li	a5,45
   11c28:	08f107a3          	sb	a5,143(sp)
   11c2c:	02d00613          	li	a2,45
   11c30:	9f8ff06f          	j	10e28 <_vfprintf_r+0xaac>
			}
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
   11c34:	00019937          	lui	s2,0x19
   11c38:	22090913          	addi	s2,s2,544 # 19220 <zeroes.4137+0x30>
   11c3c:	d95ff06f          	j	119d0 <_vfprintf_r+0x1654>
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   11c40:	001c7793          	andi	a5,s8,1
   11c44:	26079a63          	bnez	a5,11eb8 <_vfprintf_r+0x1b3c>
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
			*rve++ = '0';
	}
	*length = rve - digits;
   11c48:	0a813783          	ld	a5,168(sp)
   11c4c:	412787b3          	sub	a5,a5,s2
   11c50:	06f12823          	sw	a5,112(sp)
			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   11c54:	35ad9c63          	bne	s11,s10,11fac <_vfprintf_r+0x1c30>
				if (expt <= -4 || expt > prec)
   11c58:	09812783          	lw	a5,152(sp)
   11c5c:	ffd00713          	li	a4,-3
   11c60:	02e7cc63          	blt	a5,a4,11c98 <_vfprintf_r+0x191c>
   11c64:	02f44a63          	blt	s0,a5,11c98 <_vfprintf_r+0x191c>
   11c68:	04f12623          	sw	a5,76(sp)
   11c6c:	b9dff06f          	j	11808 <_vfprintf_r+0x148c>
# endif
					lead = expt;
			}

			if (softsign)
				sign = '-';
   11c70:	02d00713          	li	a4,45
   11c74:	08e107a3          	sb	a4,143(sp)
   11c78:	00f12423          	sw	a5,8(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   11c7c:	00012c03          	lw	s8,0(sp)
# endif
					lead = expt;
			}

			if (softsign)
				sign = '-';
   11c80:	02d00613          	li	a2,45
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   11c84:	00000413          	li	s0,0
   11c88:	b0dfe06f          	j	10794 <_vfprintf_r+0x418>
   11c8c:	0b812703          	lw	a4,184(sp)
   11c90:	00913823          	sd	s1,16(sp)
   11c94:	d78ff06f          	j	1120c <_vfprintf_r+0xe90>
			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
					ch -= 2; /* 'e' or 'E' */
   11c98:	ffed0d1b          	addiw	s10,s10,-2
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
   11c9c:	fff7879b          	addiw	a5,a5,-1
   11ca0:	08f12c23          	sw	a5,152(sp)
# else
#  define isa 0
# endif

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   11ca4:	0ba10023          	sb	s10,160(sp)
	if (exp < 0) {
   11ca8:	2c07c863          	bltz	a5,11f78 <_vfprintf_r+0x1bfc>
		exp = -exp;
		*p++ = '-';
	}
	else
		*p++ = '+';
   11cac:	02b00713          	li	a4,43
   11cb0:	0ae100a3          	sb	a4,161(sp)
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
   11cb4:	00900613          	li	a2,9
   11cb8:	16f64463          	blt	a2,a5,11e20 <_vfprintf_r+0x1aa4>
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
	}
	else {
		if (!isa)
			*p++ = '0';
		*p++ = to_char (exp);
   11cbc:	0307879b          	addiw	a5,a5,48
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
	}
	else {
		if (!isa)
			*p++ = '0';
   11cc0:	03000713          	li	a4,48
		*p++ = to_char (exp);
   11cc4:	0af101a3          	sb	a5,163(sp)
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
	}
	else {
		if (!isa)
			*p++ = '0';
   11cc8:	0ae10123          	sb	a4,162(sp)
		*p++ = to_char (exp);
   11ccc:	0a410793          	addi	a5,sp,164
	}
	return (p - p0);
   11cd0:	0a010713          	addi	a4,sp,160
   11cd4:	40e787bb          	subw	a5,a5,a4
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
   11cd8:	07012703          	lw	a4,112(sp)
	else {
		if (!isa)
			*p++ = '0';
		*p++ = to_char (exp);
	}
	return (p - p0);
   11cdc:	06f12a23          	sw	a5,116(sp)
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
   11ce0:	00e787bb          	addw	a5,a5,a4
   11ce4:	02f12023          	sw	a5,32(sp)
				if (ndig > 1 || flags & ALT)
   11ce8:	00100793          	li	a5,1
   11cec:	26e7d263          	ble	a4,a5,11f50 <_vfprintf_r+0x1bd4>
					++size;
   11cf0:	02012783          	lw	a5,32(sp)
   11cf4:	0017879b          	addiw	a5,a5,1
   11cf8:	02f12023          	sw	a5,32(sp)
   11cfc:	2607c463          	bltz	a5,11f64 <_vfprintf_r+0x1be8>
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   11d00:	04012623          	sw	zero,76(sp)
   11d04:	b2dff06f          	j	11830 <_vfprintf_r+0x14b4>
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
   11d08:	00812423          	sw	s0,8(sp)
   11d0c:	02812023          	sw	s0,32(sp)
   11d10:	08f14603          	lbu	a2,143(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   11d14:	03913423          	sd	s9,40(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   11d18:	00000413          	li	s0,0
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   11d1c:	04012623          	sw	zero,76(sp)
   11d20:	a71fe06f          	j	10790 <_vfprintf_r+0x414>
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
   11d24:	0b010613          	addi	a2,sp,176
   11d28:	000a0593          	mv	a1,s4
   11d2c:	000b8513          	mv	a0,s7
   11d30:	071040ef          	jal	165a0 <__sprint_r>
   11d34:	00050463          	beqz	a0,11d3c <_vfprintf_r+0x19c0>
   11d38:	955fe06f          	j	1068c <_vfprintf_r+0x310>
   11d3c:	09812403          	lw	s0,152(sp)
   11d40:	0c013783          	ld	a5,192(sp)
   11d44:	0b812703          	lw	a4,184(sp)
   11d48:	000b0893          	mv	a7,s6
   11d4c:	be9ff06f          	j	11934 <_vfprintf_r+0x15b8>
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   11d50:	9e0410e3          	bnez	s0,11730 <_vfprintf_r+0x13b4>
				prec = 1;
   11d54:	00090413          	mv	s0,s2
   11d58:	9d9ff06f          	j	11730 <_vfprintf_r+0x13b4>
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
				prec = DEFPREC;
   11d5c:	00600413          	li	s0,6
   11d60:	9d1ff06f          	j	11730 <_vfprintf_r+0x13b4>
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   11d64:	228405d3          	fmv.d	fa1,fs0
   11d68:	09810713          	addi	a4,sp,152
   11d6c:	0a810813          	addi	a6,sp,168
   11d70:	09c10793          	addi	a5,sp,156
   11d74:	00040693          	mv	a3,s0
   11d78:	00300613          	li	a2,3
   11d7c:	000b8513          	mv	a0,s7
   11d80:	01113423          	sd	a7,8(sp)
   11d84:	14d000ef          	jal	126d0 <_dtoa_r>
   11d88:	00813883          	ld	a7,8(sp)

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   11d8c:	00040713          	mv	a4,s0
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   11d90:	00050913          	mv	s2,a0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   11d94:	00e50733          	add	a4,a0,a4
   11d98:	00040593          	mv	a1,s0
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
   11d9c:	00094683          	lbu	a3,0(s2)
   11da0:	03000793          	li	a5,48
   11da4:	14f68063          	beq	a3,a5,11ee4 <_vfprintf_r+0x1b68>
   11da8:	09812583          	lw	a1,152(sp)
				*decpt = -ndigits + 1;
			bp += *decpt;
   11dac:	00b70733          	add	a4,a4,a1
   11db0:	a01ff06f          	j	117b0 <_vfprintf_r+0x1434>
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
   11db4:	22841453          	fneg.d	fs0,fs0
		*sign = '-';
   11db8:	02d00c93          	li	s9,45
   11dbc:	991ff06f          	j	1174c <_vfprintf_r+0x13d0>
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
						1 : 2 - expt);
   11dc0:	04c12703          	lw	a4,76(sp)
   11dc4:	00100793          	li	a5,1
   11dc8:	1ae05263          	blez	a4,11f6c <_vfprintf_r+0x1bf0>
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
   11dcc:	07012703          	lw	a4,112(sp)
   11dd0:	00e787bb          	addw	a5,a5,a4
   11dd4:	02f12023          	sw	a5,32(sp)
   11dd8:	0007ce63          	bltz	a5,11df4 <_vfprintf_r+0x1a78>
   11ddc:	06700d13          	li	s10,103
   11de0:	a51ff06f          	j	11830 <_vfprintf_r+0x14b4>
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
   11de4:	04c12783          	lw	a5,76(sp)
   11de8:	0017879b          	addiw	a5,a5,1
   11dec:	02f12023          	sw	a5,32(sp)
   11df0:	fe07d6e3          	bgez	a5,11ddc <_vfprintf_r+0x1a60>
   11df4:	00000793          	li	a5,0
				} else
					size = ndig + (expt > 0 ?
   11df8:	06700d13          	li	s10,103
   11dfc:	a35ff06f          	j	11830 <_vfprintf_r+0x14b4>
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
					if (expt > 0) {
   11e00:	09812783          	lw	a5,152(sp)
   11e04:	04f12623          	sw	a5,76(sp)
   11e08:	12f05263          	blez	a5,11f2c <_vfprintf_r+0x1bb0>
						size = expt;
						if (prec || flags & ALT)
   11e0c:	0a041e63          	bnez	s0,11ec8 <_vfprintf_r+0x1b4c>
   11e10:	001c7c13          	andi	s8,s8,1
   11e14:	0a0c1a63          	bnez	s8,11ec8 <_vfprintf_r+0x1b4c>
   11e18:	02f12023          	sw	a5,32(sp)
   11e1c:	a15ff06f          	j	11830 <_vfprintf_r+0x14b4>
		*p++ = '-';
	}
	else
		*p++ = '+';
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
   11e20:	0af10593          	addi	a1,sp,175
   11e24:	00058713          	mv	a4,a1
		do {
			*--t = to_char (exp % 10);
   11e28:	00a00513          	li	a0,10
   11e2c:	02a7e6bb          	remw	a3,a5,a0
   11e30:	fff70713          	addi	a4,a4,-1
		} while ((exp /= 10) > 9);
   11e34:	02a7c7bb          	divw	a5,a5,a0
	else
		*p++ = '+';
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
		do {
			*--t = to_char (exp % 10);
   11e38:	0306869b          	addiw	a3,a3,48
   11e3c:	00d70023          	sb	a3,0(a4)
		} while ((exp /= 10) > 9);
   11e40:	fef646e3          	blt	a2,a5,11e2c <_vfprintf_r+0x1ab0>
		*--t = to_char (exp);
   11e44:	0307879b          	addiw	a5,a5,48
   11e48:	0ff7f793          	andi	a5,a5,255
   11e4c:	fff70693          	addi	a3,a4,-1
   11e50:	fef70fa3          	sb	a5,-1(a4)
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   11e54:	16b6f863          	bleu	a1,a3,11fc4 <_vfprintf_r+0x1c48>
   11e58:	0a210613          	addi	a2,sp,162
   11e5c:	0080006f          	j	11e64 <_vfprintf_r+0x1ae8>
   11e60:	0006c783          	lbu	a5,0(a3)
   11e64:	00160613          	addi	a2,a2,1
   11e68:	00168693          	addi	a3,a3,1
   11e6c:	fef60fa3          	sb	a5,-1(a2)
   11e70:	feb698e3          	bne	a3,a1,11e60 <_vfprintf_r+0x1ae4>
   11e74:	0b010793          	addi	a5,sp,176
   11e78:	40e787b3          	sub	a5,a5,a4
   11e7c:	0a210713          	addi	a4,sp,162
   11e80:	00f707b3          	add	a5,a4,a5
   11e84:	e4dff06f          	j	11cd0 <_vfprintf_r+0x1954>
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   11e88:	228405d3          	fmv.d	fa1,fs0
   11e8c:	0a810813          	addi	a6,sp,168
   11e90:	09c10793          	addi	a5,sp,156
   11e94:	09810713          	addi	a4,sp,152
   11e98:	00040693          	mv	a3,s0
   11e9c:	00300613          	li	a2,3
   11ea0:	000b8513          	mv	a0,s7
   11ea4:	01113423          	sd	a7,8(sp)
   11ea8:	029000ef          	jal	126d0 <_dtoa_r>
   11eac:	00813883          	ld	a7,8(sp)
   11eb0:	00050913          	mv	s2,a0
   11eb4:	00040593          	mv	a1,s0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
		if (ch == 'f' || ch == 'F') {
   11eb8:	04600793          	li	a5,70
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   11ebc:	00b90733          	add	a4,s2,a1
		if (ch == 'f' || ch == 'F') {
   11ec0:	ecfd0ee3          	beq	s10,a5,11d9c <_vfprintf_r+0x1a20>
   11ec4:	8edff06f          	j	117b0 <_vfprintf_r+0x1434>
			} else {
				if (ch == 'f') {		/* f fmt */
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
   11ec8:	04c12783          	lw	a5,76(sp)
   11ecc:	0014041b          	addiw	s0,s0,1
   11ed0:	008787bb          	addw	a5,a5,s0
   11ed4:	02f12023          	sw	a5,32(sp)
   11ed8:	9407dce3          	bgez	a5,11830 <_vfprintf_r+0x14b4>
   11edc:	00000793          	li	a5,0
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   11ee0:	951ff06f          	j	11830 <_vfprintf_r+0x14b4>
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
   11ee4:	f20007d3          	fmv.d.x	fa5,zero
   11ee8:	a2f427d3          	feq.d	a5,fs0,fa5
   11eec:	ea079ee3          	bnez	a5,11da8 <_vfprintf_r+0x1a2c>
				*decpt = -ndigits + 1;
   11ef0:	00100793          	li	a5,1
   11ef4:	40b785bb          	subw	a1,a5,a1
   11ef8:	08b12c23          	sw	a1,152(sp)
			bp += *decpt;
   11efc:	00b70733          	add	a4,a4,a1
   11f00:	8b1ff06f          	j	117b0 <_vfprintf_r+0x1434>
   11f04:	00000d93          	li	s11,0
   11f08:	ccdff06f          	j	11bd4 <_vfprintf_r+0x1858>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   11f0c:	02813783          	ld	a5,40(sp)
   11f10:	0007a403          	lw	s0,0(a5)
   11f14:	00878793          	addi	a5,a5,8
   11f18:	02f13423          	sd	a5,40(sp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   11f1c:	00044463          	bltz	s0,11f24 <_vfprintf_r+0x1ba8>
   11f20:	e18fe06f          	j	10538 <_vfprintf_r+0x1bc>
					prec = -1;
   11f24:	fff00413          	li	s0,-1
   11f28:	e10fe06f          	j	10538 <_vfprintf_r+0x1bc>
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   11f2c:	00041a63          	bnez	s0,11f40 <_vfprintf_r+0x1bc4>
   11f30:	00100793          	li	a5,1
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   11f34:	00fc7c33          	and	s8,s8,a5
							  ? prec + 2
							  : 1;
   11f38:	02f12023          	sw	a5,32(sp)
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   11f3c:	8e0c0ae3          	beqz	s8,11830 <_vfprintf_r+0x14b4>
							  ? prec + 2
							  : 1;
   11f40:	0024079b          	addiw	a5,s0,2
   11f44:	02f12023          	sw	a5,32(sp)
   11f48:	8e07d4e3          	bgez	a5,11830 <_vfprintf_r+0x14b4>
   11f4c:	f91ff06f          	j	11edc <_vfprintf_r+0x1b60>
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
   11f50:	00fc7c33          	and	s8,s8,a5
   11f54:	d80c1ee3          	bnez	s8,11cf0 <_vfprintf_r+0x1974>
   11f58:	02012703          	lw	a4,32(sp)
   11f5c:	00070793          	mv	a5,a4
   11f60:	da0750e3          	bgez	a4,11d00 <_vfprintf_r+0x1984>
   11f64:	00000793          	li	a5,0
   11f68:	d99ff06f          	j	11d00 <_vfprintf_r+0x1984>
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
						1 : 2 - expt);
   11f6c:	00200793          	li	a5,2
   11f70:	40e787bb          	subw	a5,a5,a4
   11f74:	e59ff06f          	j	11dcc <_vfprintf_r+0x1a50>

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
	if (exp < 0) {
		exp = -exp;
		*p++ = '-';
   11f78:	02d00713          	li	a4,45
# endif

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
	if (exp < 0) {
		exp = -exp;
   11f7c:	40f007bb          	negw	a5,a5
		*p++ = '-';
   11f80:	0ae100a3          	sb	a4,161(sp)
   11f84:	d31ff06f          	j	11cb4 <_vfprintf_r+0x1938>
   11f88:	08b107a3          	sb	a1,143(sp)
   11f8c:	ed9fe06f          	j	10e64 <_vfprintf_r+0xae8>
   11f90:	00000793          	li	a5,0
   11f94:	891ff06f          	j	11824 <_vfprintf_r+0x14a8>
   11f98:	08b107a3          	sb	a1,143(sp)
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   11f9c:	010c6c13          	ori	s8,s8,16
   11fa0:	f2dfe06f          	j	10ecc <_vfprintf_r+0xb50>
   11fa4:	08b107a3          	sb	a1,143(sp)
   11fa8:	ef5fe06f          	j	10e9c <_vfprintf_r+0xb20>
   11fac:	09812783          	lw	a5,152(sp)
   11fb0:	cedff06f          	j	11c9c <_vfprintf_r+0x1920>
   11fb4:	08b107a3          	sb	a1,143(sp)
   11fb8:	e2dfe06f          	j	10de4 <_vfprintf_r+0xa68>
   11fbc:	08b107a3          	sb	a1,143(sp)
   11fc0:	dd5fe06f          	j	10d94 <_vfprintf_r+0xa18>
	if (exp > 9) {
		do {
			*--t = to_char (exp % 10);
		} while ((exp /= 10) > 9);
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   11fc4:	0a210793          	addi	a5,sp,162
   11fc8:	d09ff06f          	j	11cd0 <_vfprintf_r+0x1954>
   11fcc:	08b107a3          	sb	a1,143(sp)
   11fd0:	f41fe06f          	j	10f10 <_vfprintf_r+0xb94>
   11fd4:	08b107a3          	sb	a1,143(sp)
   11fd8:	f28fe06f          	j	10700 <_vfprintf_r+0x384>
   11fdc:	08b107a3          	sb	a1,143(sp)
   11fe0:	9c5fe06f          	j	109a4 <_vfprintf_r+0x628>
   11fe4:	08b107a3          	sb	a1,143(sp)
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   11fe8:	010c6c13          	ori	s8,s8,16
   11fec:	979fe06f          	j	10964 <_vfprintf_r+0x5e8>
   11ff0:	08b107a3          	sb	a1,143(sp)
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   11ff4:	010c6c13          	ori	s8,s8,16
   11ff8:	929fe06f          	j	10920 <_vfprintf_r+0x5a4>
   11ffc:	08b107a3          	sb	a1,143(sp)
   12000:	881fe06f          	j	10880 <_vfprintf_r+0x504>

0000000000012004 <vfprintf>:
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   12004:	00060693          	mv	a3,a2
   12008:	00058613          	mv	a2,a1
   1200c:	00050593          	mv	a1,a0
   12010:	8101b503          	ld	a0,-2032(gp) # 1b2e0 <_impure_ptr>
   12014:	b68fe06f          	j	1037c <_vfprintf_r>

0000000000012018 <__sbprintf>:
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   12018:	0105d783          	lhu	a5,16(a1)
	fake._flags2 = fp->_flags2;
   1201c:	0ac5ae03          	lw	t3,172(a1)
	fake._file = fp->_file;
   12020:	0125d303          	lhu	t1,18(a1)
	fake._cookie = fp->_cookie;
   12024:	0305b883          	ld	a7,48(a1)
	fake._write = fp->_write;
   12028:	0405b803          	ld	a6,64(a1)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1202c:	b3010113          	addi	sp,sp,-1232
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   12030:	ffd7f793          	andi	a5,a5,-3
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
	fake._bf._size = fake._w = sizeof (buf);
   12034:	40000713          	li	a4,1024
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   12038:	4c813023          	sd	s0,1216(sp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   1203c:	00f11823          	sh	a5,16(sp)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   12040:	00058413          	mv	s0,a1
	fake._file = fp->_file;
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   12044:	0b010793          	addi	a5,sp,176
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   12048:	00010593          	mv	a1,sp
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1204c:	4a913c23          	sd	s1,1208(sp)
   12050:	4b213823          	sd	s2,1200(sp)
   12054:	4c113423          	sd	ra,1224(sp)
   12058:	00050913          	mv	s2,a0
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
	fake._flags2 = fp->_flags2;
   1205c:	0bc12623          	sw	t3,172(sp)
	fake._file = fp->_file;
   12060:	00611923          	sh	t1,18(sp)
	fake._cookie = fp->_cookie;
   12064:	03113823          	sd	a7,48(sp)
	fake._write = fp->_write;
   12068:	05013023          	sd	a6,64(sp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   1206c:	00f13023          	sd	a5,0(sp)
   12070:	00f13c23          	sd	a5,24(sp)
	fake._bf._size = fake._w = sizeof (buf);
   12074:	00e12623          	sw	a4,12(sp)
   12078:	02e12023          	sw	a4,32(sp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   1207c:	02012423          	sw	zero,40(sp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   12080:	afcfe0ef          	jal	1037c <_vfprintf_r>
   12084:	00050493          	mv	s1,a0
	if (ret >= 0 && _fflush_r (rptr, &fake))
   12088:	00054a63          	bltz	a0,1209c <__sbprintf+0x84>
   1208c:	00010593          	mv	a1,sp
   12090:	00090513          	mv	a0,s2
   12094:	1a5010ef          	jal	13a38 <_fflush_r>
   12098:	02051c63          	bnez	a0,120d0 <__sbprintf+0xb8>
		ret = EOF;
	if (fake._flags & __SERR)
   1209c:	01015783          	lhu	a5,16(sp)
   120a0:	0407f793          	andi	a5,a5,64
   120a4:	00078863          	beqz	a5,120b4 <__sbprintf+0x9c>
		fp->_flags |= __SERR;
   120a8:	01045783          	lhu	a5,16(s0)
   120ac:	0407e793          	ori	a5,a5,64
   120b0:	00f41823          	sh	a5,16(s0)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
}
   120b4:	4c813083          	ld	ra,1224(sp)
   120b8:	00048513          	mv	a0,s1
   120bc:	4c013403          	ld	s0,1216(sp)
   120c0:	4b813483          	ld	s1,1208(sp)
   120c4:	4b013903          	ld	s2,1200(sp)
   120c8:	4d010113          	addi	sp,sp,1232
   120cc:	00008067          	ret
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
	if (ret >= 0 && _fflush_r (rptr, &fake))
		ret = EOF;
   120d0:	fff00493          	li	s1,-1
   120d4:	fc9ff06f          	j	1209c <__sbprintf+0x84>

00000000000120d8 <__swsetup_r>:
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   120d8:	8101b783          	ld	a5,-2032(gp) # 1b2e0 <_impure_ptr>

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   120dc:	fe010113          	addi	sp,sp,-32
   120e0:	00813823          	sd	s0,16(sp)
   120e4:	00913423          	sd	s1,8(sp)
   120e8:	00113c23          	sd	ra,24(sp)
   120ec:	00050493          	mv	s1,a0
   120f0:	00058413          	mv	s0,a1
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   120f4:	00078663          	beqz	a5,12100 <__swsetup_r+0x28>
   120f8:	0507a703          	lw	a4,80(a5)
   120fc:	0e070063          	beqz	a4,121dc <__swsetup_r+0x104>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
   12100:	01041703          	lh	a4,16(s0)
   12104:	03071793          	slli	a5,a4,0x30
   12108:	0307d793          	srli	a5,a5,0x30
   1210c:	0087f693          	andi	a3,a5,8
   12110:	04068263          	beqz	a3,12154 <__swsetup_r+0x7c>
   12114:	01843683          	ld	a3,24(s0)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   12118:	06068663          	beqz	a3,12184 <__swsetup_r+0xac>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
    __smakebuf_r (ptr, fp);

  if (fp->_flags & __SLBF)
   1211c:	0017f713          	andi	a4,a5,1
   12120:	08071463          	bnez	a4,121a8 <__swsetup_r+0xd0>
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
   12124:	0027f793          	andi	a5,a5,2
   12128:	00000713          	li	a4,0
   1212c:	00079463          	bnez	a5,12134 <__swsetup_r+0x5c>
   12130:	02042703          	lw	a4,32(s0)
   12134:	00e42623          	sw	a4,12(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   12138:	00000513          	li	a0,0
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   1213c:	08068263          	beqz	a3,121c0 <__swsetup_r+0xe8>
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
}
   12140:	01813083          	ld	ra,24(sp)
   12144:	01013403          	ld	s0,16(sp)
   12148:	00813483          	ld	s1,8(sp)
   1214c:	02010113          	addi	sp,sp,32
   12150:	00008067          	ret
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
   12154:	0107f693          	andi	a3,a5,16
   12158:	0c068663          	beqz	a3,12224 <__swsetup_r+0x14c>
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
	  return EOF;
        }
      if (fp->_flags & __SRD)
   1215c:	0047f793          	andi	a5,a5,4
   12160:	08079463          	bnez	a5,121e8 <__swsetup_r+0x110>
   12164:	01843683          	ld	a3,24(s0)
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
	}
      fp->_flags |= __SWR;
   12168:	00876793          	ori	a5,a4,8
   1216c:	0107979b          	slliw	a5,a5,0x10
   12170:	4107d79b          	sraiw	a5,a5,0x10
   12174:	00f41823          	sh	a5,16(s0)
   12178:	03079793          	slli	a5,a5,0x30
   1217c:	0307d793          	srli	a5,a5,0x30
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   12180:	f8069ee3          	bnez	a3,1211c <__swsetup_r+0x44>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
   12184:	2807f713          	andi	a4,a5,640
   12188:	20000613          	li	a2,512
   1218c:	f8c708e3          	beq	a4,a2,1211c <__swsetup_r+0x44>
    __smakebuf_r (ptr, fp);
   12190:	00040593          	mv	a1,s0
   12194:	00048513          	mv	a0,s1
   12198:	2ec020ef          	jal	14484 <__smakebuf_r>
   1219c:	01045783          	lhu	a5,16(s0)
   121a0:	01843683          	ld	a3,24(s0)
   121a4:	f79ff06f          	j	1211c <__swsetup_r+0x44>
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   121a8:	02042783          	lw	a5,32(s0)
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
   121ac:	00042623          	sw	zero,12(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   121b0:	00000513          	li	a0,0
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   121b4:	40f007bb          	negw	a5,a5
   121b8:	02f42423          	sw	a5,40(s0)
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   121bc:	f80692e3          	bnez	a3,12140 <__swsetup_r+0x68>
   121c0:	01041783          	lh	a5,16(s0)
   121c4:	0807f713          	andi	a4,a5,128
   121c8:	f6070ce3          	beqz	a4,12140 <__swsetup_r+0x68>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
   121cc:	0407e793          	ori	a5,a5,64
   121d0:	00f41823          	sh	a5,16(s0)
      return EOF;
   121d4:	fff00513          	li	a0,-1
   121d8:	f69ff06f          	j	12140 <__swsetup_r+0x68>
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   121dc:	00078513          	mv	a0,a5
   121e0:	405010ef          	jal	13de4 <__sinit>
   121e4:	f1dff06f          	j	12100 <__swsetup_r+0x28>
	  return EOF;
        }
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
   121e8:	05843583          	ld	a1,88(s0)
   121ec:	00058e63          	beqz	a1,12208 <__swsetup_r+0x130>
	    FREEUB (ptr, fp);
   121f0:	07440793          	addi	a5,s0,116
   121f4:	00f58863          	beq	a1,a5,12204 <__swsetup_r+0x12c>
   121f8:	00048513          	mv	a0,s1
   121fc:	541010ef          	jal	13f3c <_free_r>
   12200:	01041703          	lh	a4,16(s0)
   12204:	04043c23          	sd	zero,88(s0)
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
   12208:	01843683          	ld	a3,24(s0)
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
   1220c:	fdb77713          	andi	a4,a4,-37
   12210:	0107171b          	slliw	a4,a4,0x10
   12214:	4107571b          	sraiw	a4,a4,0x10
	  fp->_r = 0;
   12218:	00042423          	sw	zero,8(s0)
	  fp->_p = fp->_bf._base;
   1221c:	00d43023          	sd	a3,0(s0)
   12220:	f49ff06f          	j	12168 <__swsetup_r+0x90>

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
   12224:	00900793          	li	a5,9
   12228:	00f4a023          	sw	a5,0(s1)
	  fp->_flags |= __SERR;
   1222c:	04076713          	ori	a4,a4,64
   12230:	00e41823          	sh	a4,16(s0)
	  return EOF;
   12234:	fff00513          	li	a0,-1
   12238:	f09ff06f          	j	12140 <__swsetup_r+0x68>

000000000001223c <__register_exitproc>:
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   1223c:	fd010113          	addi	sp,sp,-48
   12240:	02813023          	sd	s0,32(sp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   12244:	8081b403          	ld	s0,-2040(gp) # 1b2d8 <_global_impure_ptr>
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   12248:	00913c23          	sd	s1,24(sp)
   1224c:	00050493          	mv	s1,a0

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   12250:	1f843503          	ld	a0,504(s0)
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   12254:	01213823          	sd	s2,16(sp)
   12258:	01313423          	sd	s3,8(sp)
   1225c:	01413023          	sd	s4,0(sp)
   12260:	02113423          	sd	ra,40(sp)
   12264:	00058913          	mv	s2,a1
   12268:	00060a13          	mv	s4,a2
   1226c:	00068993          	mv	s3,a3
#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
   12270:	0c050663          	beqz	a0,1233c <__register_exitproc+0x100>
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
  if (p->_ind >= _ATEXIT_SIZE)
   12274:	00852703          	lw	a4,8(a0)
   12278:	01f00793          	li	a5,31
   1227c:	0017059b          	addiw	a1,a4,1
   12280:	04e7d063          	ble	a4,a5,122c0 <__register_exitproc+0x84>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
   12284:	000007b7          	lui	a5,0x0
   12288:	00078793          	mv	a5,a5
   1228c:	0a078e63          	beqz	a5,12348 <__register_exitproc+0x10c>
	return -1;

      p = (struct _atexit *) malloc (sizeof *p);
   12290:	31800513          	li	a0,792
   12294:	fffee317          	auipc	t1,0xfffee
   12298:	d6c300e7          	jalr	t1,-660 # 0 <_ftext-0x10000>
      if (p == NULL)
   1229c:	0a050663          	beqz	a0,12348 <__register_exitproc+0x10c>
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
   122a0:	1f843783          	ld	a5,504(s0)
#ifndef __SINGLE_THREAD__
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
   122a4:	00052423          	sw	zero,8(a0)
      p->_next = _GLOBAL_ATEXIT;
      _GLOBAL_ATEXIT = p;
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
      p->_on_exit_args._is_cxa = 0;
   122a8:	00100593          	li	a1,1
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
   122ac:	00f53023          	sd	a5,0(a0)
      _GLOBAL_ATEXIT = p;
   122b0:	1ea43c23          	sd	a0,504(s0)
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
   122b4:	30052823          	sw	zero,784(a0)
      p->_on_exit_args._is_cxa = 0;
   122b8:	30052a23          	sw	zero,788(a0)
   122bc:	00000713          	li	a4,0
   122c0:	00070793          	mv	a5,a4
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
   122c4:	02049e63          	bnez	s1,12300 <__register_exitproc+0xc4>
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   122c8:	00278793          	addi	a5,a5,2 # 2 <_ftext-0xfffe>
   122cc:	00379793          	slli	a5,a5,0x3
   122d0:	00b52423          	sw	a1,8(a0)
   122d4:	00f50533          	add	a0,a0,a5
   122d8:	01253023          	sd	s2,0(a0)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
   122dc:	00000513          	li	a0,0
}
   122e0:	02813083          	ld	ra,40(sp)
   122e4:	02013403          	ld	s0,32(sp)
   122e8:	01813483          	ld	s1,24(sp)
   122ec:	01013903          	ld	s2,16(sp)
   122f0:	00813983          	ld	s3,8(sp)
   122f4:	00013a03          	ld	s4,0(sp)
   122f8:	03010113          	addi	sp,sp,48
   122fc:	00008067          	ret
   12300:	00371813          	slli	a6,a4,0x3
   12304:	01050833          	add	a6,a0,a6
	  p->_on_exit_args_ptr = args;
	}
#else
      args = &p->_on_exit_args;
#endif
      args->_fnargs[p->_ind] = arg;
   12308:	11483823          	sd	s4,272(a6)
      args->_fntypes |= (1 << p->_ind);
   1230c:	31052883          	lw	a7,784(a0)
   12310:	00100613          	li	a2,1
   12314:	00e6173b          	sllw	a4,a2,a4
   12318:	00e8e633          	or	a2,a7,a4
   1231c:	30c52823          	sw	a2,784(a0)
      args->_dso_handle[p->_ind] = d;
   12320:	21383823          	sd	s3,528(a6)
      if (type == __et_cxa)
   12324:	00200693          	li	a3,2
   12328:	fad490e3          	bne	s1,a3,122c8 <__register_exitproc+0x8c>
	args->_is_cxa |= (1 << p->_ind);
   1232c:	31452683          	lw	a3,788(a0)
   12330:	00e6e733          	or	a4,a3,a4
   12334:	30e52a23          	sw	a4,788(a0)
   12338:	f91ff06f          	j	122c8 <__register_exitproc+0x8c>
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
   1233c:	20040513          	addi	a0,s0,512
   12340:	1ea43c23          	sd	a0,504(s0)
   12344:	f31ff06f          	j	12274 <__register_exitproc+0x38>
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
	return -1;
   12348:	fff00513          	li	a0,-1
   1234c:	f95ff06f          	j	122e0 <__register_exitproc+0xa4>

0000000000012350 <__call_exitprocs>:
 */

void 
_DEFUN (__call_exitprocs, (code, d),
	int code _AND _PTR d)
{
   12350:	fa010113          	addi	sp,sp,-96
   12354:	03413823          	sd	s4,48(sp)
   12358:	8081ba03          	ld	s4,-2040(gp) # 1b2d8 <_global_impure_ptr>
   1235c:	03313c23          	sd	s3,56(sp)
#ifndef _ATEXIT_DYNAMIC_ALLOC
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
   12360:	000009b7          	lui	s3,0x0
 */

void 
_DEFUN (__call_exitprocs, (code, d),
	int code _AND _PTR d)
{
   12364:	04913423          	sd	s1,72(sp)
   12368:	05213023          	sd	s2,64(sp)
   1236c:	03513423          	sd	s5,40(sp)
   12370:	01713c23          	sd	s7,24(sp)
   12374:	01813823          	sd	s8,16(sp)
   12378:	04113c23          	sd	ra,88(sp)
   1237c:	04813823          	sd	s0,80(sp)
   12380:	03613023          	sd	s6,32(sp)
   12384:	01913423          	sd	s9,8(sp)
   12388:	01a13023          	sd	s10,0(sp)
   1238c:	00050913          	mv	s2,a0
   12390:	00058b93          	mv	s7,a1
   12394:	1f8a0a93          	addi	s5,s4,504
	    continue;

	  ind = p->_ind;

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
   12398:	00100493          	li	s1,1
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
#endif
      for (n = p->_ind - 1; n >= 0; n--)
   1239c:	fff00c13          	li	s8,-1
#ifndef _ATEXIT_DYNAMIC_ALLOC
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
   123a0:	00098993          	mv	s3,s3
  __lock_acquire_recursive(__atexit_lock);
#endif

 restart:

  p = _GLOBAL_ATEXIT;
   123a4:	1f8a3b03          	ld	s6,504(s4)
  lastp = &_GLOBAL_ATEXIT;
  while (p)
   123a8:	0c0b0663          	beqz	s6,12474 <__call_exitprocs+0x124>
   123ac:	000a8d13          	mv	s10,s5
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
#endif
      for (n = p->_ind - 1; n >= 0; n--)
   123b0:	008b2403          	lw	s0,8(s6)
   123b4:	fff4041b          	addiw	s0,s0,-1
   123b8:	02045263          	bgez	s0,123dc <__call_exitprocs+0x8c>
   123bc:	08c0006f          	j	12448 <__call_exitprocs+0xf8>
	  int ind;

	  i = 1 << n;

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
   123c0:	02040793          	addi	a5,s0,32
   123c4:	00379793          	slli	a5,a5,0x3
   123c8:	00fb07b3          	add	a5,s6,a5
   123cc:	1107b783          	ld	a5,272(a5)
   123d0:	00fb8a63          	beq	s7,a5,123e4 <__call_exitprocs+0x94>
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
#endif
      for (n = p->_ind - 1; n >= 0; n--)
   123d4:	fff4041b          	addiw	s0,s0,-1
   123d8:	07840863          	beq	s0,s8,12448 <__call_exitprocs+0xf8>
	  int ind;

	  i = 1 << n;

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
   123dc:	00040713          	mv	a4,s0
   123e0:	fe0b90e3          	bnez	s7,123c0 <__call_exitprocs+0x70>
	    continue;

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
	  if (n == p->_ind - 1)
   123e4:	008b2783          	lw	a5,8(s6)
   123e8:	00371713          	slli	a4,a4,0x3
   123ec:	00eb0733          	add	a4,s6,a4
   123f0:	fff7879b          	addiw	a5,a5,-1
	  if (d && (!args || args->_dso_handle[n] != d))
	    continue;

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
   123f4:	01073683          	ld	a3,16(a4)
	  if (n == p->_ind - 1)
   123f8:	0a878e63          	beq	a5,s0,124b4 <__call_exitprocs+0x164>
	    p->_ind--;
	  else
	    p->_fns[n] = NULL;
   123fc:	00073823          	sd	zero,16(a4)

	  /* Skip functions that have already been called.  */
	  if (!fn)
   12400:	fc068ae3          	beqz	a3,123d4 <__call_exitprocs+0x84>
	    continue;

	  ind = p->_ind;

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
   12404:	310b2783          	lw	a5,784(s6)
   12408:	0084963b          	sllw	a2,s1,s0

	  /* Skip functions that have already been called.  */
	  if (!fn)
	    continue;

	  ind = p->_ind;
   1240c:	008b2c83          	lw	s9,8(s6)

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
   12410:	00f677b3          	and	a5,a2,a5
   12414:	08078c63          	beqz	a5,124ac <__call_exitprocs+0x15c>
	    fn ();
	  else if ((args->_is_cxa & i) == 0)
   12418:	314b2783          	lw	a5,788(s6)
   1241c:	00f67633          	and	a2,a2,a5
   12420:	08061e63          	bnez	a2,124bc <__call_exitprocs+0x16c>
	    (*((void (*)(int, _PTR)) fn))(code, args->_fnargs[n]);
   12424:	11073583          	ld	a1,272(a4)
   12428:	00090513          	mv	a0,s2
   1242c:	000680e7          	jalr	a3
	    (*((void (*)(_PTR)) fn))(args->_fnargs[n]);

	  /* The function we called call atexit and registered another
	     function (or functions).  Call these new functions before
	     continuing with the already registered functions.  */
	  if (ind != p->_ind || *lastp != p)
   12430:	008b2783          	lw	a5,8(s6)
   12434:	f79798e3          	bne	a5,s9,123a4 <__call_exitprocs+0x54>
   12438:	000d3783          	ld	a5,0(s10)
   1243c:	f76794e3          	bne	a5,s6,123a4 <__call_exitprocs+0x54>
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
#endif
      for (n = p->_ind - 1; n >= 0; n--)
   12440:	fff4041b          	addiw	s0,s0,-1
   12444:	f9841ce3          	bne	s0,s8,123dc <__call_exitprocs+0x8c>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
   12448:	02098663          	beqz	s3,12474 <__call_exitprocs+0x124>
	break;

      /* Move to the next block.  Free empty blocks except the last one,
	 which is part of _GLOBAL_REENT.  */
      if (p->_ind == 0 && p->_next)
   1244c:	008b2783          	lw	a5,8(s6)
   12450:	06079c63          	bnez	a5,124c8 <__call_exitprocs+0x178>
   12454:	000b3783          	ld	a5,0(s6)
   12458:	08078263          	beqz	a5,124dc <__call_exitprocs+0x18c>
	  *lastp = p->_next;
#ifdef _REENT_SMALL
	  if (args)
	    free (args);
#endif
	  free (p);
   1245c:	000b0513          	mv	a0,s6
      /* Move to the next block.  Free empty blocks except the last one,
	 which is part of _GLOBAL_REENT.  */
      if (p->_ind == 0 && p->_next)
	{
	  /* Remove empty block from the list.  */
	  *lastp = p->_next;
   12460:	00fd3023          	sd	a5,0(s10)
#ifdef _REENT_SMALL
	  if (args)
	    free (args);
#endif
	  free (p);
   12464:	fffee317          	auipc	t1,0xfffee
   12468:	b9c300e7          	jalr	t1,-1124 # 0 <_ftext-0x10000>
	  p = *lastp;
   1246c:	000d3b03          	ld	s6,0(s10)

 restart:

  p = _GLOBAL_ATEXIT;
  lastp = &_GLOBAL_ATEXIT;
  while (p)
   12470:	f40b10e3          	bnez	s6,123b0 <__call_exitprocs+0x60>
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif

}
   12474:	05813083          	ld	ra,88(sp)
   12478:	05013403          	ld	s0,80(sp)
   1247c:	04813483          	ld	s1,72(sp)
   12480:	04013903          	ld	s2,64(sp)
   12484:	03813983          	ld	s3,56(sp)
   12488:	03013a03          	ld	s4,48(sp)
   1248c:	02813a83          	ld	s5,40(sp)
   12490:	02013b03          	ld	s6,32(sp)
   12494:	01813b83          	ld	s7,24(sp)
   12498:	01013c03          	ld	s8,16(sp)
   1249c:	00813c83          	ld	s9,8(sp)
   124a0:	00013d03          	ld	s10,0(sp)
   124a4:	06010113          	addi	sp,sp,96
   124a8:	00008067          	ret

	  ind = p->_ind;

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
	    fn ();
   124ac:	000680e7          	jalr	a3
   124b0:	f81ff06f          	j	12430 <__call_exitprocs+0xe0>

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
	  if (n == p->_ind - 1)
	    p->_ind--;
   124b4:	008b2423          	sw	s0,8(s6)
   124b8:	f49ff06f          	j	12400 <__call_exitprocs+0xb0>
	  if (!args || (args->_fntypes & i) == 0)
	    fn ();
	  else if ((args->_is_cxa & i) == 0)
	    (*((void (*)(int, _PTR)) fn))(code, args->_fnargs[n]);
	  else
	    (*((void (*)(_PTR)) fn))(args->_fnargs[n]);
   124bc:	11073503          	ld	a0,272(a4)
   124c0:	000680e7          	jalr	a3
   124c4:	f6dff06f          	j	12430 <__call_exitprocs+0xe0>
   124c8:	000b3783          	ld	a5,0(s6)
	  free (p);
	  p = *lastp;
	}
      else
	{
	  lastp = &p->_next;
   124cc:	000b0d13          	mv	s10,s6
	  p = p->_next;
   124d0:	00078b13          	mv	s6,a5

 restart:

  p = _GLOBAL_ATEXIT;
  lastp = &_GLOBAL_ATEXIT;
  while (p)
   124d4:	ec0b1ee3          	bnez	s6,123b0 <__call_exitprocs+0x60>
   124d8:	f9dff06f          	j	12474 <__call_exitprocs+0x124>
   124dc:	00000793          	li	a5,0
   124e0:	fedff06f          	j	124cc <__call_exitprocs+0x17c>

00000000000124e4 <quorem>:

static int
_DEFUN (quorem,
	(b, S),
	_Bigint * b _AND _Bigint * S)
{
   124e4:	fc010113          	addi	sp,sp,-64
   124e8:	03213023          	sd	s2,32(sp)
  n = S->_wds;
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
   124ec:	01452783          	lw	a5,20(a0)
#ifdef Pack_32
  __Long z;
  __ULong si, zs;
#endif

  n = S->_wds;
   124f0:	0145a903          	lw	s2,20(a1)

static int
_DEFUN (quorem,
	(b, S),
	_Bigint * b _AND _Bigint * S)
{
   124f4:	02113c23          	sd	ra,56(sp)
   124f8:	02813823          	sd	s0,48(sp)
   124fc:	02913423          	sd	s1,40(sp)
   12500:	01313c23          	sd	s3,24(sp)
   12504:	01413823          	sd	s4,16(sp)
   12508:	01513423          	sd	s5,8(sp)
  n = S->_wds;
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
   1250c:	1b27ce63          	blt	a5,s2,126c8 <quorem+0x1e4>
    return 0;
  sx = S->_x;
  sxe = sx + --n;
   12510:	fff9091b          	addiw	s2,s2,-1
   12514:	00090f13          	mv	t5,s2
   12518:	002f1f13          	slli	t5,t5,0x2
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
   1251c:	01858413          	addi	s0,a1,24
  sxe = sx + --n;
   12520:	01e409b3          	add	s3,s0,t5
  bx = b->_x;
   12524:	01850a13          	addi	s4,a0,24
  bxe = bx + n;
   12528:	01ea0f33          	add	t5,s4,t5
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
   1252c:	0009a783          	lw	a5,0(s3) # 0 <_ftext-0x10000>
   12530:	000f2483          	lw	s1,0(t5)
   12534:	0017879b          	addiw	a5,a5,1
   12538:	02f4d4bb          	divuw	s1,s1,a5
#ifdef DEBUG
  /*debug*/ if (q > 9)
    /*debug*/ Bug ("oversized quotient in quorem");
#endif
  if (q)
   1253c:	0a048e63          	beqz	s1,125f8 <quorem+0x114>
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   12540:	00010337          	lui	t1,0x10
   12544:	00040e93          	mv	t4,s0
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
  sxe = sx + --n;
  bx = b->_x;
   12548:	000a0e13          	mv	t3,s4
   1254c:	00000613          	li	a2,0
   12550:	00000713          	li	a4,0
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   12554:	fff3031b          	addiw	t1,t1,-1
      borrow = 0;
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
   12558:	004e8e93          	addi	t4,t4,4
   1255c:	ffcea803          	lw	a6,-4(t4)
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   12560:	000e2683          	lw	a3,0(t3)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   12564:	004e0e13          	addi	t3,t3,4
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   12568:	006878b3          	and	a7,a6,t1
   1256c:	029888bb          	mulw	a7,a7,s1
	  zs = (si >> 16) * q + (ys >> 16);
   12570:	0108581b          	srliw	a6,a6,0x10
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   12574:	0066f7b3          	and	a5,a3,t1
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   12578:	0106d69b          	srliw	a3,a3,0x10
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
   1257c:	0298083b          	mulw	a6,a6,s1
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   12580:	00c888bb          	addw	a7,a7,a2
	  zs = (si >> 16) * q + (ys >> 16);
   12584:	0108d61b          	srliw	a2,a7,0x10
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   12588:	0068f8b3          	and	a7,a7,t1
   1258c:	4117073b          	subw	a4,a4,a7
   12590:	00f707bb          	addw	a5,a4,a5
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   12594:	4107d71b          	sraiw	a4,a5,0x10
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   12598:	0067f7b3          	and	a5,a5,t1
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
   1259c:	00c8063b          	addw	a2,a6,a2
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   125a0:	00667833          	and	a6,a2,t1
   125a4:	410686bb          	subw	a3,a3,a6
   125a8:	00e6873b          	addw	a4,a3,a4
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   125ac:	0107169b          	slliw	a3,a4,0x10
   125b0:	00f6e6b3          	or	a3,a3,a5
   125b4:	fede2e23          	sw	a3,-4(t3)
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
	  carry = zs >> 16;
   125b8:	0106561b          	srliw	a2,a2,0x10
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
   125bc:	4107571b          	sraiw	a4,a4,0x10
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   125c0:	f9d9fce3          	bleu	t4,s3,12558 <quorem+0x74>
      if (!*bxe)
   125c4:	000f2783          	lw	a5,0(t5)
   125c8:	02079863          	bnez	a5,125f8 <quorem+0x114>
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
   125cc:	ffcf0793          	addi	a5,t5,-4
   125d0:	02fa7263          	bleu	a5,s4,125f4 <quorem+0x110>
   125d4:	ffcf2703          	lw	a4,-4(t5)
   125d8:	00070863          	beqz	a4,125e8 <quorem+0x104>
   125dc:	0180006f          	j	125f4 <quorem+0x110>
   125e0:	0007a703          	lw	a4,0(a5)
   125e4:	00071863          	bnez	a4,125f4 <quorem+0x110>
   125e8:	ffc78793          	addi	a5,a5,-4
	    --n;
   125ec:	fff9091b          	addiw	s2,s2,-1
	}
      while (sx <= sxe);
      if (!*bxe)
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
   125f0:	fefa68e3          	bltu	s4,a5,125e0 <quorem+0xfc>
	    --n;
	  b->_wds = n;
   125f4:	01252a23          	sw	s2,20(a0)
   125f8:	00050a93          	mv	s5,a0
	}
    }
  if (cmp (b, S) >= 0)
   125fc:	388030ef          	jal	15984 <__mcmp>
   12600:	0a054063          	bltz	a0,126a0 <quorem+0x1bc>
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   12604:	000105b7          	lui	a1,0x10
	  b->_wds = n;
	}
    }
  if (cmp (b, S) >= 0)
    {
      q++;
   12608:	0014849b          	addiw	s1,s1,1
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
  sxe = sx + --n;
  bx = b->_x;
   1260c:	000a0613          	mv	a2,s4
	}
    }
  if (cmp (b, S) >= 0)
    {
      q++;
      borrow = 0;
   12610:	00000793          	li	a5,0
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   12614:	fff5859b          	addiw	a1,a1,-1
      bx = b->_x;
      sx = S->_x;
      do
	{
#ifdef Pack_32
	  si = *sx++;
   12618:	00440413          	addi	s0,s0,4
   1261c:	ffc42683          	lw	a3,-4(s0)
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   12620:	00062703          	lw	a4,0(a2)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   12624:	00460613          	addi	a2,a2,4
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   12628:	00b6f833          	and	a6,a3,a1
   1262c:	410787bb          	subw	a5,a5,a6
   12630:	00b77833          	and	a6,a4,a1
   12634:	010787bb          	addw	a5,a5,a6
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   12638:	0106d69b          	srliw	a3,a3,0x10
   1263c:	0107571b          	srliw	a4,a4,0x10
   12640:	40d7073b          	subw	a4,a4,a3
   12644:	4107d69b          	sraiw	a3,a5,0x10
   12648:	00d706bb          	addw	a3,a4,a3
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   1264c:	0106981b          	slliw	a6,a3,0x10
   12650:	00b7f733          	and	a4,a5,a1
   12654:	00e86733          	or	a4,a6,a4
   12658:	fee62e23          	sw	a4,-4(a2)
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
   1265c:	4106d79b          	sraiw	a5,a3,0x10
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   12660:	fa89fce3          	bleu	s0,s3,12618 <quorem+0x134>
      bx = b->_x;
      bxe = bx + n;
   12664:	00291713          	slli	a4,s2,0x2
   12668:	00ea0733          	add	a4,s4,a4
      if (!*bxe)
   1266c:	00072783          	lw	a5,0(a4)
   12670:	02079863          	bnez	a5,126a0 <quorem+0x1bc>
	{
	  while (--bxe > bx && !*bxe)
   12674:	ffc70793          	addi	a5,a4,-4
   12678:	02fa7263          	bleu	a5,s4,1269c <quorem+0x1b8>
   1267c:	ffc72703          	lw	a4,-4(a4)
   12680:	00070863          	beqz	a4,12690 <quorem+0x1ac>
   12684:	0180006f          	j	1269c <quorem+0x1b8>
   12688:	0007a703          	lw	a4,0(a5)
   1268c:	00071863          	bnez	a4,1269c <quorem+0x1b8>
   12690:	ffc78793          	addi	a5,a5,-4
	    --n;
   12694:	fff9091b          	addiw	s2,s2,-1
      while (sx <= sxe);
      bx = b->_x;
      bxe = bx + n;
      if (!*bxe)
	{
	  while (--bxe > bx && !*bxe)
   12698:	fefa68e3          	bltu	s4,a5,12688 <quorem+0x1a4>
	    --n;
	  b->_wds = n;
   1269c:	012aaa23          	sw	s2,20(s5)
	}
    }
  return q;
   126a0:	00048513          	mv	a0,s1
}
   126a4:	03813083          	ld	ra,56(sp)
   126a8:	03013403          	ld	s0,48(sp)
   126ac:	02813483          	ld	s1,40(sp)
   126b0:	02013903          	ld	s2,32(sp)
   126b4:	01813983          	ld	s3,24(sp)
   126b8:	01013a03          	ld	s4,16(sp)
   126bc:	00813a83          	ld	s5,8(sp)
   126c0:	04010113          	addi	sp,sp,64
   126c4:	00008067          	ret
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
    return 0;
   126c8:	00000513          	li	a0,0
   126cc:	fd9ff06f          	j	126a4 <quorem+0x1c0>

00000000000126d0 <_dtoa_r>:
	int mode _AND
	int ndigits _AND
	int *decpt _AND
	int *sign _AND
	char **rve)
{
   126d0:	e20585d3          	fmv.x.d	a1,fa1
  char *s, *s0;

  d.d = _d;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
   126d4:	06053883          	ld	a7,96(a0)
	int mode _AND
	int ndigits _AND
	int *decpt _AND
	int *sign _AND
	char **rve)
{
   126d8:	f3010113          	addi	sp,sp,-208
   126dc:	0c813023          	sd	s0,192(sp)
   126e0:	0a913c23          	sd	s1,184(sp)
   126e4:	0b313423          	sd	s3,168(sp)
   126e8:	09613823          	sd	s6,144(sp)
   126ec:	07913c23          	sd	s9,120(sp)
   126f0:	07a13823          	sd	s10,112(sp)
   126f4:	0c113423          	sd	ra,200(sp)
   126f8:	0b213823          	sd	s2,176(sp)
   126fc:	0b413023          	sd	s4,160(sp)
   12700:	09513c23          	sd	s5,152(sp)
   12704:	09713423          	sd	s7,136(sp)
   12708:	09813023          	sd	s8,128(sp)
   1270c:	07b13423          	sd	s11,104(sp)
   12710:	00e13023          	sd	a4,0(sp)
   12714:	00050413          	mv	s0,a0
   12718:	00060993          	mv	s3,a2
   1271c:	00068c93          	mv	s9,a3
   12720:	00078493          	mv	s1,a5
   12724:	00080b13          	mv	s6,a6
#endif
  _Bigint *b, *b1, *delta, *mlo = NULL, *mhi, *S;
  double ds;
  char *s, *s0;

  d.d = _d;
   12728:	00058d13          	mv	s10,a1

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
   1272c:	02088263          	beqz	a7,12750 <_dtoa_r+0x80>
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   12730:	06852603          	lw	a2,104(a0)
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   12734:	00100693          	li	a3,1
      Bfree (ptr, _REENT_MP_RESULT(ptr));
   12738:	00088593          	mv	a1,a7

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   1273c:	00c696bb          	sllw	a3,a3,a2
  d.d = _d;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   12740:	00c8a423          	sw	a2,8(a7)
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   12744:	00d8a623          	sw	a3,12(a7)
      Bfree (ptr, _REENT_MP_RESULT(ptr));
   12748:	1f1020ef          	jal	15138 <_Bfree>
      _REENT_MP_RESULT(ptr) = 0;
   1274c:	06043023          	sd	zero,96(s0)
    }

  if (word0 (d) & Sign_bit)
   12750:	420d5913          	srai	s2,s10,0x20
   12754:	0c094063          	bltz	s2,12814 <_dtoa_r+0x144>
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
    }
  else
    *sign = 0;
   12758:	0004a023          	sw	zero,0(s1)

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
  if ((word0 (d) & Exp_mask) == Exp_mask)
   1275c:	7ff007b7          	lui	a5,0x7ff00
   12760:	00f976b3          	and	a3,s2,a5
   12764:	06f68a63          	beq	a3,a5,127d8 <_dtoa_r+0x108>
    }
#endif
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
   12768:	f20007d3          	fmv.d.x	fa5,zero
   1276c:	f20d0753          	fmv.d.x	fa4,s10
   12770:	a2f727d3          	feq.d	a5,fa4,fa5
   12774:	0c078463          	beqz	a5,1283c <_dtoa_r+0x16c>
    {
      *decpt = 1;
   12778:	00013703          	ld	a4,0(sp)
   1277c:	00100793          	li	a5,1
   12780:	00f72023          	sw	a5,0(a4)
      s = "0";
      if (rve)
   12784:	480b0a63          	beqz	s6,12c18 <_dtoa_r+0x548>
	*rve = s + 1;
   12788:	000197b7          	lui	a5,0x19
   1278c:	26178793          	addi	a5,a5,609 # 19261 <zeroes.4137+0x71>
      return s;
   12790:	00019537          	lui	a0,0x19
  if (!d.d)
    {
      *decpt = 1;
      s = "0";
      if (rve)
	*rve = s + 1;
   12794:	00fb3023          	sd	a5,0(s6)
      return s;
   12798:	26050513          	addi	a0,a0,608 # 19260 <zeroes.4137+0x70>
  *s = 0;
  *decpt = k + 1;
  if (rve)
    *rve = s;
  return s0;
}
   1279c:	0c813083          	ld	ra,200(sp)
   127a0:	0c013403          	ld	s0,192(sp)
   127a4:	0b813483          	ld	s1,184(sp)
   127a8:	0b013903          	ld	s2,176(sp)
   127ac:	0a813983          	ld	s3,168(sp)
   127b0:	0a013a03          	ld	s4,160(sp)
   127b4:	09813a83          	ld	s5,152(sp)
   127b8:	09013b03          	ld	s6,144(sp)
   127bc:	08813b83          	ld	s7,136(sp)
   127c0:	08013c03          	ld	s8,128(sp)
   127c4:	07813c83          	ld	s9,120(sp)
   127c8:	07013d03          	ld	s10,112(sp)
   127cc:	06813d83          	ld	s11,104(sp)
   127d0:	0d010113          	addi	sp,sp,208
   127d4:	00008067          	ret
#else
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
   127d8:	00013703          	ld	a4,0(sp)
   127dc:	000027b7          	lui	a5,0x2
   127e0:	70f7879b          	addiw	a5,a5,1807
   127e4:	00f72023          	sw	a5,0(a4)
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   127e8:	00cd1793          	slli	a5,s10,0xc
   127ec:	3e079863          	bnez	a5,12bdc <_dtoa_r+0x50c>
   127f0:	00019537          	lui	a0,0x19
   127f4:	26850513          	addi	a0,a0,616 # 19268 <zeroes.4137+0x78>
#endif
	"NaN";
      if (rve)
   127f8:	fa0b02e3          	beqz	s6,1279c <_dtoa_r+0xcc>
	*rve =
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
   127fc:	00354703          	lbu	a4,3(a0)
   12800:	00350793          	addi	a5,a0,3
   12804:	00070463          	beqz	a4,1280c <_dtoa_r+0x13c>
   12808:	00850793          	addi	a5,a0,8
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
#endif
	"NaN";
      if (rve)
	*rve =
   1280c:	00fb3023          	sd	a5,0(s6)
   12810:	f8dff06f          	j	1279c <_dtoa_r+0xcc>

  if (word0 (d) & Sign_bit)
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   12814:	800007b7          	lui	a5,0x80000
   12818:	fff7c793          	not	a5,a5
   1281c:	020d1713          	slli	a4,s10,0x20
   12820:	00f97933          	and	s2,s2,a5
   12824:	02091793          	slli	a5,s2,0x20
   12828:	02075713          	srli	a4,a4,0x20
    }

  if (word0 (d) & Sign_bit)
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
   1282c:	00100693          	li	a3,1
   12830:	00d4a023          	sw	a3,0(s1)
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   12834:	00f76d33          	or	s10,a4,a5
   12838:	f25ff06f          	j	1275c <_dtoa_r+0x8c>
      if (rve)
	*rve = s + 1;
      return s;
    }

  b = d2b (ptr, d.d, &be, &bbits);
   1283c:	f20d05d3          	fmv.d.x	fa1,s10
   12840:	05810693          	addi	a3,sp,88
   12844:	05c10613          	addi	a2,sp,92
   12848:	00040513          	mv	a0,s0
   1284c:	578030ef          	jal	15dc4 <__d2b>
   12850:	02a13023          	sd	a0,32(sp)
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
   12854:	0149581b          	srliw	a6,s2,0x14
   12858:	38081863          	bnez	a6,12be8 <_dtoa_r+0x518>
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
   1285c:	05812603          	lw	a2,88(sp)
   12860:	05c12803          	lw	a6,92(sp)
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   12864:	02000793          	li	a5,32
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
   12868:	0106083b          	addw	a6,a2,a6
   1286c:	4328069b          	addiw	a3,a6,1074
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   12870:	6ad7de63          	ble	a3,a5,12f2c <_dtoa_r+0x85c>
   12874:	04000593          	li	a1,64
   12878:	4128049b          	addiw	s1,a6,1042

      i = bbits + be + (Bias + (P - 1) - 1);
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
   1287c:	000d079b          	sext.w	a5,s10
       : (word1 (d) << (32 - i));
   12880:	40d585bb          	subw	a1,a1,a3
   12884:	0097d7bb          	srlw	a5,a5,s1
   12888:	00b914bb          	sllw	s1,s2,a1
   1288c:	0097e4b3          	or	s1,a5,s1
#endif
      d2.d = x;
   12890:	d21487d3          	fcvt.d.wu	fa5,s1
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   12894:	fe1006b7          	lui	a3,0xfe100
      i -= (Bias + (P - 1) - 1) + 1;
   12898:	fff8081b          	addiw	a6,a6,-1
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
#endif
      d2.d = x;
   1289c:	e20784d3          	fmv.x.d	s1,fa5
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
      i -= (Bias + (P - 1) - 1) + 1;
      denorm = 1;
   128a0:	00100913          	li	s2,1
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
#endif
      d2.d = x;
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   128a4:	4204d793          	srai	a5,s1,0x20
   128a8:	00d787bb          	addw	a5,a5,a3
   128ac:	02049493          	slli	s1,s1,0x20
   128b0:	02079793          	slli	a5,a5,0x20
   128b4:	0204d493          	srli	s1,s1,0x20
   128b8:	00f4e4b3          	or	s1,s1,a5
    }
#endif
#if defined (_DOUBLE_IS_32BITS)
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
   128bc:	0001b7b7          	lui	a5,0x1b
   128c0:	3087b787          	fld	fa5,776(a5) # 1b308 <__wctomb+0x8>
   128c4:	f2048753          	fmv.d.x	fa4,s1
   128c8:	0001b7b7          	lui	a5,0x1b
   128cc:	0af77653          	fsub.d	fa2,fa4,fa5
   128d0:	3187b787          	fld	fa5,792(a5) # 1b318 <__wctomb+0x18>
   128d4:	0001b7b7          	lui	a5,0x1b
   128d8:	3107b687          	fld	fa3,784(a5) # 1b310 <__wctomb+0x10>
   128dc:	0001b7b7          	lui	a5,0x1b
   128e0:	d2080753          	fcvt.d.w	fa4,a6
   128e4:	7ad677c3          	fmadd.d	fa5,fa2,fa3,fa5
   128e8:	3207b687          	fld	fa3,800(a5) # 1b320 <__wctomb+0x20>
   128ec:	7ad777c3          	fmadd.d	fa5,fa4,fa3,fa5
#endif
  k = (int) ds;
  if (ds < 0. && ds != k)
   128f0:	f2000753          	fmv.d.x	fa4,zero
   128f4:	a2e797d3          	flt.d	a5,fa5,fa4
#if defined (_DOUBLE_IS_32BITS)
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
#endif
  k = (int) ds;
   128f8:	c2079bd3          	fcvt.w.d	s7,fa5,rtz
  if (ds < 0. && ds != k)
   128fc:	5e079e63          	bnez	a5,12ef8 <_dtoa_r+0x828>
    k--;			/* want k = floor(ds) */
  k_check = 1;
   12900:	00100793          	li	a5,1
   12904:	02f12823          	sw	a5,48(sp)
  if (k >= 0 && k <= Ten_pmax)
   12908:	01600793          	li	a5,22
   1290c:	0377e663          	bltu	a5,s7,12938 <_dtoa_r+0x268>
    {
      if (d.d < tens[k])
   12910:	000197b7          	lui	a5,0x19
   12914:	003b9693          	slli	a3,s7,0x3
   12918:	f6078793          	addi	a5,a5,-160 # 18f60 <__mprec_tens>
   1291c:	00f687b3          	add	a5,a3,a5
   12920:	0007b787          	fld	fa5,0(a5)
   12924:	f20d0753          	fmv.d.x	fa4,s10
   12928:	a2f717d3          	flt.d	a5,fa4,fa5
   1292c:	60078863          	beqz	a5,12f3c <_dtoa_r+0x86c>
	k--;
   12930:	fffb8b9b          	addiw	s7,s7,-1
      k_check = 0;
   12934:	02012823          	sw	zero,48(sp)
    }
  j = bbits - i - 1;
   12938:	4106083b          	subw	a6,a2,a6
   1293c:	fff80d9b          	addiw	s11,a6,-1
  if (j >= 0)
    {
      b2 = 0;
   12940:	00000813          	li	a6,0
      if (d.d < tens[k])
	k--;
      k_check = 0;
    }
  j = bbits - i - 1;
  if (j >= 0)
   12944:	2e0dc063          	bltz	s11,12c24 <_dtoa_r+0x554>
  else
    {
      b2 = -j;
      s2 = 0;
    }
  if (k >= 0)
   12948:	5c0bc263          	bltz	s7,12f0c <_dtoa_r+0x83c>
    {
      b5 = 0;
      s5 = k;
      s2 += k;
   1294c:	017d8dbb          	addw	s11,s11,s7
   12950:	03712423          	sw	s7,40(sp)
      b2 = -j;
      s2 = 0;
    }
  if (k >= 0)
    {
      b5 = 0;
   12954:	00000c13          	li	s8,0
    {
      b2 -= k;
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
   12958:	00900793          	li	a5,9
   1295c:	2d37ea63          	bltu	a5,s3,12c30 <_dtoa_r+0x560>
    mode = 0;
  try_quick = 1;
  if (mode > 5)
   12960:	00500793          	li	a5,5
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
    mode = 0;
  try_quick = 1;
   12964:	00100a13          	li	s4,1
  if (mode > 5)
   12968:	0137d663          	ble	s3,a5,12974 <_dtoa_r+0x2a4>
    {
      mode -= 4;
   1296c:	ffc9899b          	addiw	s3,s3,-4
      try_quick = 0;
   12970:	00000a13          	li	s4,0
    }
  leftright = 1;
  ilim = ilim1 = -1;
  switch (mode)
   12974:	00300793          	li	a5,3
   12978:	2af982e3          	beq	s3,a5,1341c <_dtoa_r+0xd4c>
   1297c:	1f37dce3          	ble	s3,a5,13374 <_dtoa_r+0xca4>
   12980:	00400793          	li	a5,4
   12984:	0cf98ae3          	beq	s3,a5,13258 <_dtoa_r+0xb88>
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   12988:	00100793          	li	a5,1
   1298c:	00f12823          	sw	a5,16(sp)
  ilim = ilim1 = -1;
  switch (mode)
   12990:	00500793          	li	a5,5
   12994:	1ef996e3          	bne	s3,a5,13380 <_dtoa_r+0xcb0>
      break;
    case 3:
      leftright = 0;
      /* no break */
    case 5:
      i = ndigits + k + 1;
   12998:	019b87bb          	addw	a5,s7,s9
   1299c:	00178a9b          	addiw	s5,a5,1
   129a0:	02f12a23          	sw	a5,52(sp)
   129a4:	000a8513          	mv	a0,s5
   129a8:	000a8493          	mv	s1,s5
      ilim = i;
      ilim1 = i - 1;
      if (i <= 0)
   129ac:	1b505ee3          	blez	s5,13368 <_dtoa_r+0xc98>
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   129b0:	06042423          	sw	zero,104(s0)
   129b4:	01f00793          	li	a5,31
   129b8:	00000593          	li	a1,0
   129bc:	02a7f463          	bleu	a0,a5,129e4 <_dtoa_r+0x314>
   129c0:	00100613          	li	a2,1
   129c4:	00400693          	li	a3,4
       j <<= 1)
   129c8:	0016969b          	slliw	a3,a3,0x1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   129cc:	00068793          	mv	a5,a3
   129d0:	01c78793          	addi	a5,a5,28
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
   129d4:	00060593          	mv	a1,a2
   129d8:	0016061b          	addiw	a2,a2,1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   129dc:	fef576e3          	bleu	a5,a0,129c8 <_dtoa_r+0x2f8>
   129e0:	06b42423          	sw	a1,104(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   129e4:	00040513          	mv	a0,s0
   129e8:	03013c23          	sd	a6,56(sp)
   129ec:	6a0020ef          	jal	1508c <_Balloc>
   129f0:	00a13423          	sd	a0,8(sp)
   129f4:	06a43023          	sd	a0,96(s0)
  s = s0 = (char *) _REENT_MP_RESULT(ptr);

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
   129f8:	00e00793          	li	a5,14
   129fc:	03813803          	ld	a6,56(sp)
   12a00:	2697e463          	bltu	a5,s1,12c68 <_dtoa_r+0x598>
   12a04:	260a0263          	beqz	s4,12c68 <_dtoa_r+0x598>
    {
      /* Try to get by with floating-point arithmetic. */

      i = 0;
      d2.d = d.d;
   12a08:	03a13c23          	sd	s10,56(sp)
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
   12a0c:	317054e3          	blez	s7,13514 <_dtoa_r+0xe44>
	{
	  ds = tens[k & 0xf];
   12a10:	00fbf713          	andi	a4,s7,15
   12a14:	00371693          	slli	a3,a4,0x3
   12a18:	00019737          	lui	a4,0x19
	  j = k >> 4;
   12a1c:	404bd79b          	sraiw	a5,s7,0x4
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
	{
	  ds = tens[k & 0xf];
   12a20:	f6070713          	addi	a4,a4,-160 # 18f60 <__mprec_tens>
   12a24:	00e68733          	add	a4,a3,a4
	  j = k >> 4;
	  if (j & Bletch)
   12a28:	0107f693          	andi	a3,a5,16
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
	{
	  ds = tens[k & 0xf];
   12a2c:	00073687          	fld	fa3,0(a4)
   12a30:	f20d07d3          	fmv.d.x	fa5,s10

      i = 0;
      d2.d = d.d;
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
   12a34:	00200713          	li	a4,2
      if (k > 0)
	{
	  ds = tens[k & 0xf];
	  j = k >> 4;
	  if (j & Bletch)
   12a38:	00068c63          	beqz	a3,12a50 <_dtoa_r+0x380>
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
   12a3c:	00019737          	lui	a4,0x19
   12a40:	07073707          	fld	fa4,112(a4) # 19070 <__mprec_bigtens+0x20>
	  ds = tens[k & 0xf];
	  j = k >> 4;
	  if (j & Bletch)
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
   12a44:	00f7f793          	andi	a5,a5,15
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
   12a48:	00300713          	li	a4,3
	  j = k >> 4;
	  if (j & Bletch)
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
   12a4c:	1ae7f7d3          	fdiv.d	fa5,fa5,fa4
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
   12a50:	02078663          	beqz	a5,12a7c <_dtoa_r+0x3ac>
   12a54:	000196b7          	lui	a3,0x19
   12a58:	05068693          	addi	a3,a3,80 # 19050 <__mprec_bigtens>
	    if (j & 1)
   12a5c:	0017f613          	andi	a2,a5,1
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
   12a60:	4017d79b          	sraiw	a5,a5,0x1
	    if (j & 1)
   12a64:	00060863          	beqz	a2,12a74 <_dtoa_r+0x3a4>
	      {
		ieps++;
		ds *= bigtens[i];
   12a68:	0006b707          	fld	fa4,0(a3)
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
	    if (j & 1)
	      {
		ieps++;
   12a6c:	0017071b          	addiw	a4,a4,1
		ds *= bigtens[i];
   12a70:	12e6f6d3          	fmul.d	fa3,fa3,fa4
   12a74:	00868693          	addi	a3,a3,8
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
   12a78:	fe0792e3          	bnez	a5,12a5c <_dtoa_r+0x38c>
	    if (j & 1)
	      {
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
   12a7c:	1ad7f7d3          	fdiv.d	fa5,fa5,fa3
	      {
		ieps++;
		d.d *= bigtens[i];
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
   12a80:	03012783          	lw	a5,48(sp)
   12a84:	00078a63          	beqz	a5,12a98 <_dtoa_r+0x3c8>
   12a88:	0001b7b7          	lui	a5,0x1b
   12a8c:	3287b707          	fld	fa4,808(a5) # 1b328 <__wctomb+0x28>
   12a90:	a2e797d3          	flt.d	a5,fa5,fa4
   12a94:	440790e3          	bnez	a5,136d4 <_dtoa_r+0x1004>
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   12a98:	0001b7b7          	lui	a5,0x1b
   12a9c:	d20706d3          	fcvt.d.w	fa3,a4
   12aa0:	3387b707          	fld	fa4,824(a5) # 1b338 <__wctomb+0x38>
      word0 (eps) -= (P - 1) * Exp_msk1;
   12aa4:	fcc006b7          	lui	a3,0xfcc00
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   12aa8:	72f6f743          	fmadd.d	fa4,fa3,fa5,fa4
   12aac:	e2070753          	fmv.x.d	a4,fa4
      word0 (eps) -= (P - 1) * Exp_msk1;
   12ab0:	42075793          	srai	a5,a4,0x20
   12ab4:	00d787bb          	addw	a5,a5,a3
   12ab8:	02071713          	slli	a4,a4,0x20
   12abc:	02079793          	slli	a5,a5,0x20
   12ac0:	02075713          	srli	a4,a4,0x20
   12ac4:	00f76733          	or	a4,a4,a5
      if (ilim == 0)
   12ac8:	180a86e3          	beqz	s5,13454 <_dtoa_r+0xd84>
   12acc:	000b8693          	mv	a3,s7
   12ad0:	000a8613          	mv	a2,s5
	  if (d.d < -eps.d)
	    goto no_digits;
	  goto fast_failed;
	}
#ifndef No_leftright
      if (leftright)
   12ad4:	01012783          	lw	a5,16(sp)
   12ad8:	300782e3          	beqz	a5,135dc <_dtoa_r+0xf0c>
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   12adc:	fff6079b          	addiw	a5,a2,-1
   12ae0:	000195b7          	lui	a1,0x19
   12ae4:	f6058593          	addi	a1,a1,-160 # 18f60 <__mprec_tens>
   12ae8:	00379793          	slli	a5,a5,0x3
   12aec:	00b787b3          	add	a5,a5,a1
   12af0:	0001b5b7          	lui	a1,0x1b
   12af4:	0007b687          	fld	fa3,0(a5)
   12af8:	3485b707          	fld	fa4,840(a1) # 1b348 <__wctomb+0x48>
	  for (i = 0;;)
	    {
	      L = d.d;
   12afc:	c20797d3          	fcvt.w.d	a5,fa5,rtz
	      d.d -= L;
	      *s++ = '0' + (int) L;
   12b00:	00813503          	ld	a0,8(sp)
      if (leftright)
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   12b04:	1ad77753          	fdiv.d	fa4,fa4,fa3
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
   12b08:	d20786d3          	fcvt.d.w	fa3,a5
	      *s++ = '0' + (int) L;
   12b0c:	0307879b          	addiw	a5,a5,48
   12b10:	0ff7f793          	andi	a5,a5,255
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
   12b14:	0ad7f7d3          	fsub.d	fa5,fa5,fa3
      if (leftright)
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   12b18:	f20706d3          	fmv.d.x	fa3,a4
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   12b1c:	00f50023          	sb	a5,0(a0)
   12b20:	00150493          	addi	s1,a0,1
      if (leftright)
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   12b24:	0ad77753          	fsub.d	fa4,fa4,fa3
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
   12b28:	a2e79753          	flt.d	a4,fa5,fa4
   12b2c:	08071063          	bnez	a4,12bac <_dtoa_r+0x4dc>
		goto ret1;
	      if (1. - d.d < eps.d)
   12b30:	0001b737          	lui	a4,0x1b
   12b34:	32873587          	fld	fa1,808(a4) # 1b328 <__wctomb+0x28>
   12b38:	0af5f6d3          	fsub.d	fa3,fa1,fa5
   12b3c:	a2e69753          	flt.d	a4,fa3,fa4
   12b40:	40071ae3          	bnez	a4,13754 <_dtoa_r+0x1084>
		goto bump_up;
	      if (++i >= ilim)
   12b44:	00100793          	li	a5,1
   12b48:	1ac7d4e3          	ble	a2,a5,134f0 <_dtoa_r+0xe20>
   12b4c:	0001b7b7          	lui	a5,0x1b
   12b50:	ffe6061b          	addiw	a2,a2,-2
   12b54:	02061613          	slli	a2,a2,0x20
		break;
	      eps.d *= 10.;
   12b58:	3307b607          	fld	fa2,816(a5) # 1b330 <__wctomb+0x30>
   12b5c:	00813783          	ld	a5,8(sp)
   12b60:	02065613          	srli	a2,a2,0x20
   12b64:	00260613          	addi	a2,a2,2
   12b68:	00c78633          	add	a2,a5,a2
   12b6c:	0140006f          	j	12b80 <_dtoa_r+0x4b0>
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
		goto ret1;
	      if (1. - d.d < eps.d)
   12b70:	0af5f6d3          	fsub.d	fa3,fa1,fa5
   12b74:	a2e69753          	flt.d	a4,fa3,fa4
   12b78:	3c071ee3          	bnez	a4,13754 <_dtoa_r+0x1084>
		goto bump_up;
	      if (++i >= ilim)
   12b7c:	16960ae3          	beq	a2,s1,134f0 <_dtoa_r+0xe20>
		break;
	      eps.d *= 10.;
	      d.d *= 10.;
   12b80:	12c7f7d3          	fmul.d	fa5,fa5,fa2
		goto ret1;
	      if (1. - d.d < eps.d)
		goto bump_up;
	      if (++i >= ilim)
		break;
	      eps.d *= 10.;
   12b84:	12c77753          	fmul.d	fa4,fa4,fa2
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   12b88:	00148493          	addi	s1,s1,1
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
   12b8c:	c20797d3          	fcvt.w.d	a5,fa5,rtz
	      d.d -= L;
   12b90:	d20786d3          	fcvt.d.w	fa3,a5
	      *s++ = '0' + (int) L;
   12b94:	0307879b          	addiw	a5,a5,48
   12b98:	0ff7f793          	andi	a5,a5,255
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
   12b9c:	0ad7f7d3          	fsub.d	fa5,fa5,fa3
	      *s++ = '0' + (int) L;
   12ba0:	fef48fa3          	sb	a5,-1(s1)
	      if (d.d < eps.d)
   12ba4:	a2e79753          	flt.d	a4,fa5,fa4
   12ba8:	fc0704e3          	beqz	a4,12b70 <_dtoa_r+0x4a0>
   12bac:	00068b93          	mv	s7,a3
      if (mlo && mlo != mhi)
	Bfree (ptr, mlo);
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
   12bb0:	02013583          	ld	a1,32(sp)
   12bb4:	00040513          	mv	a0,s0
  *s = 0;
  *decpt = k + 1;
   12bb8:	001b8b9b          	addiw	s7,s7,1
      if (mlo && mlo != mhi)
	Bfree (ptr, mlo);
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
   12bbc:	57c020ef          	jal	15138 <_Bfree>
  *s = 0;
  *decpt = k + 1;
   12bc0:	00013783          	ld	a5,0(sp)
	Bfree (ptr, mlo);
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
  *s = 0;
   12bc4:	00048023          	sb	zero,0(s1)
  *decpt = k + 1;
   12bc8:	0177a023          	sw	s7,0(a5)
  if (rve)
   12bcc:	0c0b0ce3          	beqz	s6,134a4 <_dtoa_r+0xdd4>
    *rve = s;
   12bd0:	009b3023          	sd	s1,0(s6)
   12bd4:	00813503          	ld	a0,8(sp)
   12bd8:	bc5ff06f          	j	1279c <_dtoa_r+0xcc>
    {
      /* Infinity or NaN */
      *decpt = 9999;
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   12bdc:	00019537          	lui	a0,0x19
   12be0:	27850513          	addi	a0,a0,632 # 19278 <zeroes.4137+0x88>
   12be4:	c15ff06f          	j	127f8 <_dtoa_r+0x128>
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
    {
#endif
      d2.d = d.d;
      word0 (d2) &= Frac_mask1;
      word0 (d2) |= Exp_11;
   12be8:	00cd1793          	slli	a5,s10,0xc
   12bec:	02c7d693          	srli	a3,a5,0x2c
   12bf0:	3ff007b7          	lui	a5,0x3ff00
   12bf4:	00f6e7b3          	or	a5,a3,a5
   12bf8:	020d1493          	slli	s1,s10,0x20
   12bfc:	02079793          	slli	a5,a5,0x20
   12c00:	0204d493          	srli	s1,s1,0x20
   12c04:	00f4e4b3          	or	s1,s1,a5
		 * Hence we adjust the constant term to 0.1760912590558.
		 * (We could get a more accurate k by invoking log10,
		 *  but this is probably not worthwhile.)
		 */

      i -= Bias;
   12c08:	c018081b          	addiw	a6,a6,-1023
   12c0c:	05812603          	lw	a2,88(sp)
#ifdef IBM
      i <<= 2;
      i += j;
#endif
#ifndef Sudden_Underflow
      denorm = 0;
   12c10:	00000913          	li	s2,0
   12c14:	ca9ff06f          	j	128bc <_dtoa_r+0x1ec>
    {
      *decpt = 1;
      s = "0";
      if (rve)
	*rve = s + 1;
      return s;
   12c18:	00019537          	lui	a0,0x19
   12c1c:	26050513          	addi	a0,a0,608 # 19260 <zeroes.4137+0x70>
   12c20:	b7dff06f          	j	1279c <_dtoa_r+0xcc>
      b2 = 0;
      s2 = j;
    }
  else
    {
      b2 = -j;
   12c24:	41b0083b          	negw	a6,s11
      s2 = 0;
   12c28:	00000d93          	li	s11,0
   12c2c:	d1dff06f          	j	12948 <_dtoa_r+0x278>
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   12c30:	06042423          	sw	zero,104(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   12c34:	00000593          	li	a1,0
   12c38:	00040513          	mv	a0,s0
   12c3c:	03013c23          	sd	a6,56(sp)
   12c40:	44c020ef          	jal	1508c <_Balloc>
   12c44:	03813803          	ld	a6,56(sp)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   12c48:	fff00a93          	li	s5,-1
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   12c4c:	00100793          	li	a5,1
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   12c50:	00a13423          	sd	a0,8(sp)
   12c54:	06a43023          	sd	a0,96(s0)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   12c58:	03512a23          	sw	s5,52(sp)
      b2 -= k;
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
    mode = 0;
   12c5c:	00000993          	li	s3,0
  switch (mode)
    {
    case 0:
    case 1:
      i = 18;
      ndigits = 0;
   12c60:	00000c93          	li	s9,0
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   12c64:	00f12823          	sw	a5,16(sp)
      ilim = ilim0;
    }

  /* Do we have a "small" integer? */

  if (be >= 0 && k <= Int_max)
   12c68:	05c12783          	lw	a5,92(sp)
   12c6c:	0e07ca63          	bltz	a5,12d60 <_dtoa_r+0x690>
   12c70:	00e00693          	li	a3,14
   12c74:	0f76c663          	blt	a3,s7,12d60 <_dtoa_r+0x690>
    {
      /* Yes. */
      ds = tens[k];
   12c78:	000197b7          	lui	a5,0x19
   12c7c:	003b9693          	slli	a3,s7,0x3
   12c80:	f6078793          	addi	a5,a5,-160 # 18f60 <__mprec_tens>
   12c84:	00f687b3          	add	a5,a3,a5
   12c88:	0007b687          	fld	fa3,0(a5)
      if (ndigits < 0 && ilim <= 0)
   12c8c:	5e0cc663          	bltz	s9,13278 <_dtoa_r+0xba8>
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
   12c90:	f20d0653          	fmv.d.x	fa2,s10
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   12c94:	00813703          	ld	a4,8(sp)
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
	  d.d -= L * ds;
   12c98:	22d69553          	fneg.d	fa0,fa3
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
   12c9c:	1ad67753          	fdiv.d	fa4,fa2,fa3
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   12ca0:	00170493          	addi	s1,a4,1
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
   12ca4:	c20717d3          	fcvt.w.d	a5,fa4,rtz
	  d.d -= L * ds;
   12ca8:	d20787d3          	fcvt.d.w	fa5,a5
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   12cac:	0307869b          	addiw	a3,a5,48
   12cb0:	00d70023          	sb	a3,0(a4)
	  if (i == ilim)
   12cb4:	00100713          	li	a4,1
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
	  d.d -= L * ds;
   12cb8:	62f577c3          	fmadd.d	fa5,fa0,fa5,fa2
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
	  if (i == ilim)
   12cbc:	2aea88e3          	beq	s5,a4,1376c <_dtoa_r+0x109c>
		      }
		  ++*s++;
		}
	      break;
	    }
	  if (!(d.d *= 10.))
   12cc0:	0001b7b7          	lui	a5,0x1b
   12cc4:	3307b587          	fld	fa1,816(a5) # 1b330 <__wctomb+0x30>
   12cc8:	f2000653          	fmv.d.x	fa2,zero
   12ccc:	12b7f7d3          	fmul.d	fa5,fa5,fa1
   12cd0:	a2c7a7d3          	feq.d	a5,fa5,fa2
   12cd4:	ec079ee3          	bnez	a5,12bb0 <_dtoa_r+0x4e0>
   12cd8:	ffea869b          	addiw	a3,s5,-2
   12cdc:	02069693          	slli	a3,a3,0x20
   12ce0:	00813783          	ld	a5,8(sp)
   12ce4:	0206d693          	srli	a3,a3,0x20
   12ce8:	00268693          	addi	a3,a3,2 # fffffffffcc00002 <_gp+0xfffffffffcbe4532>
   12cec:	00d786b3          	add	a3,a5,a3
   12cf0:	0100006f          	j	12d00 <_dtoa_r+0x630>
   12cf4:	12b7f7d3          	fmul.d	fa5,fa5,fa1
   12cf8:	a2c7a7d3          	feq.d	a5,fa5,fa2
   12cfc:	ea079ae3          	bnez	a5,12bb0 <_dtoa_r+0x4e0>
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
   12d00:	1ad7f753          	fdiv.d	fa4,fa5,fa3
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   12d04:	00148493          	addi	s1,s1,1
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
   12d08:	c20717d3          	fcvt.w.d	a5,fa4,rtz
	  d.d -= L * ds;
   12d0c:	d2078753          	fcvt.d.w	fa4,a5
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   12d10:	0307871b          	addiw	a4,a5,48
   12d14:	fee48fa3          	sb	a4,-1(s1)
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
	  d.d -= L * ds;
   12d18:	7ae577c3          	fmadd.d	fa5,fa0,fa4,fa5
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
	  if (i == ilim)
   12d1c:	fcd49ce3          	bne	s1,a3,12cf4 <_dtoa_r+0x624>
	    {
	      d.d += d.d;
   12d20:	02f7f7d3          	fadd.d	fa5,fa5,fa5
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
   12d24:	a2f69753          	flt.d	a4,fa3,fa5
   12d28:	7c070863          	beqz	a4,134f8 <_dtoa_r+0xe28>
   12d2c:	fff6c783          	lbu	a5,-1(a3)
   12d30:	00068493          	mv	s1,a3
		{
		bump_up:
		  while (*--s == '9')
   12d34:	03900693          	li	a3,57
   12d38:	0140006f          	j	12d4c <_dtoa_r+0x67c>
		    if (s == s0)
   12d3c:	00813783          	ld	a5,8(sp)
   12d40:	02f70ce3          	beq	a4,a5,13578 <_dtoa_r+0xea8>
   12d44:	fff74783          	lbu	a5,-1(a4)
   12d48:	00070493          	mv	s1,a4
	    {
	      d.d += d.d;
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
		{
		bump_up:
		  while (*--s == '9')
   12d4c:	fff48713          	addi	a4,s1,-1
   12d50:	fed786e3          	beq	a5,a3,12d3c <_dtoa_r+0x66c>
		      {
			k++;
			*s = '0';
			break;
		      }
		  ++*s++;
   12d54:	0017879b          	addiw	a5,a5,1
   12d58:	00f70023          	sb	a5,0(a4)
   12d5c:	e55ff06f          	j	12bb0 <_dtoa_r+0x4e0>
    }

  m2 = b2;
  m5 = b5;
  mhi = mlo = 0;
  if (leftright)
   12d60:	01012703          	lw	a4,16(sp)
   12d64:	1a070c63          	beqz	a4,12f1c <_dtoa_r+0x84c>
    {
      if (mode < 2)
   12d68:	00100693          	li	a3,1
   12d6c:	5536d863          	ble	s3,a3,132bc <_dtoa_r+0xbec>
	    1 + P - bbits;
#endif
	}
      else
	{
	  j = ilim - 1;
   12d70:	fffa869b          	addiw	a3,s5,-1
	  if (m5 >= j)
   12d74:	72dc4c63          	blt	s8,a3,134ac <_dtoa_r+0xddc>
	    m5 -= j;
   12d78:	40dc06bb          	subw	a3,s8,a3
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   12d7c:	00080493          	mv	s1,a6
   12d80:	000a8793          	mv	a5,s5
	    {
	      s5 += j -= m5;
	      b5 += j;
	      m5 = 0;
	    }
	  if ((i = ilim) < 0)
   12d84:	120ac2e3          	bltz	s5,136a8 <_dtoa_r+0xfd8>
	    {
	      m2 -= i;
	      i = 0;
	    }
	}
      b2 += i;
   12d88:	00f8083b          	addw	a6,a6,a5
      s2 += i;
      mhi = i2b (ptr, 1);
   12d8c:	00100593          	li	a1,1
   12d90:	00040513          	mv	a0,s0
   12d94:	04d13423          	sd	a3,72(sp)
	    {
	      m2 -= i;
	      i = 0;
	    }
	}
      b2 += i;
   12d98:	05013023          	sd	a6,64(sp)
   12d9c:	03013c23          	sd	a6,56(sp)
      s2 += i;
   12da0:	00fd8dbb          	addw	s11,s11,a5
      mhi = i2b (ptr, 1);
   12da4:	720020ef          	jal	154c4 <__i2b>
   12da8:	04013803          	ld	a6,64(sp)
   12dac:	04813683          	ld	a3,72(sp)
   12db0:	00050a13          	mv	s4,a0
    }
  if (m2 > 0 && s2 > 0)
   12db4:	00048e63          	beqz	s1,12dd0 <_dtoa_r+0x700>
   12db8:	01b05c63          	blez	s11,12dd0 <_dtoa_r+0x700>
    {
      i = m2 < s2 ? m2 : s2;
   12dbc:	00048793          	mv	a5,s1
   12dc0:	489dc463          	blt	s11,s1,13248 <_dtoa_r+0xb78>
      b2 -= i;
   12dc4:	40f8083b          	subw	a6,a6,a5
      m2 -= i;
   12dc8:	40f484bb          	subw	s1,s1,a5
      s2 -= i;
   12dcc:	40fd8dbb          	subw	s11,s11,a5
      if (rve)
	*rve = s + 1;
      return s;
    }

  b = d2b (ptr, d.d, &be, &bbits);
   12dd0:	02013903          	ld	s2,32(sp)
      i = m2 < s2 ? m2 : s2;
      b2 -= i;
      m2 -= i;
      s2 -= i;
    }
  if (b5 > 0)
   12dd4:	07805e63          	blez	s8,12e50 <_dtoa_r+0x780>
    {
      if (leftright)
   12dd8:	01012783          	lw	a5,16(sp)
   12ddc:	6a078463          	beqz	a5,13484 <_dtoa_r+0xdb4>
	{
	  if (m5 > 0)
   12de0:	04068a63          	beqz	a3,12e34 <_dtoa_r+0x764>
	    {
	      mhi = pow5mult (ptr, mhi, m5);
   12de4:	00068613          	mv	a2,a3
   12de8:	000a0593          	mv	a1,s4
   12dec:	00040513          	mv	a0,s0
   12df0:	05013023          	sd	a6,64(sp)
   12df4:	02d13c23          	sd	a3,56(sp)
   12df8:	0f5020ef          	jal	156ec <__pow5mult>
	      b1 = mult (ptr, mhi, b);
   12dfc:	02013603          	ld	a2,32(sp)
   12e00:	00050593          	mv	a1,a0
    {
      if (leftright)
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
   12e04:	00050a13          	mv	s4,a0
	      b1 = mult (ptr, mhi, b);
   12e08:	00040513          	mv	a0,s0
   12e0c:	6ec020ef          	jal	154f8 <__multiply>
	      Bfree (ptr, b);
	      b = b1;
	    }
         if ((j = b5 - m5) != 0)
   12e10:	03813683          	ld	a3,56(sp)
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
	      Bfree (ptr, b);
   12e14:	02013583          	ld	a1,32(sp)
      if (leftright)
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
   12e18:	00050913          	mv	s2,a0
	      Bfree (ptr, b);
   12e1c:	00040513          	mv	a0,s0
	      b = b1;
	    }
         if ((j = b5 - m5) != 0)
   12e20:	40dc0c3b          	subw	s8,s8,a3
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
	      Bfree (ptr, b);
   12e24:	314020ef          	jal	15138 <_Bfree>
	      b = b1;
	    }
         if ((j = b5 - m5) != 0)
   12e28:	04013803          	ld	a6,64(sp)
   12e2c:	020c0263          	beqz	s8,12e50 <_dtoa_r+0x780>
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
	      Bfree (ptr, b);
	      b = b1;
   12e30:	03213023          	sd	s2,32(sp)
	    }
         if ((j = b5 - m5) != 0)
	    b = pow5mult (ptr, b, j);
   12e34:	02013583          	ld	a1,32(sp)
   12e38:	000c0613          	mv	a2,s8
   12e3c:	00040513          	mv	a0,s0
   12e40:	03013c23          	sd	a6,56(sp)
   12e44:	0a9020ef          	jal	156ec <__pow5mult>
   12e48:	03813803          	ld	a6,56(sp)
   12e4c:	00050913          	mv	s2,a0
	}
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
   12e50:	00100593          	li	a1,1
   12e54:	00040513          	mv	a0,s0
   12e58:	03013023          	sd	a6,32(sp)
   12e5c:	668020ef          	jal	154c4 <__i2b>
  if (s5 > 0)
   12e60:	02812783          	lw	a5,40(sp)
	    b = pow5mult (ptr, b, j);
	}
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
   12e64:	00050c13          	mv	s8,a0
  if (s5 > 0)
   12e68:	02013803          	ld	a6,32(sp)
   12e6c:	0c078c63          	beqz	a5,12f44 <_dtoa_r+0x874>
    S = pow5mult (ptr, S, s5);
   12e70:	00078613          	mv	a2,a5
   12e74:	00050593          	mv	a1,a0
   12e78:	00040513          	mv	a0,s0
   12e7c:	071020ef          	jal	156ec <__pow5mult>

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   12e80:	00100793          	li	a5,1
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);
   12e84:	00050c13          	mv	s8,a0

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   12e88:	02013803          	ld	a6,32(sp)
   12e8c:	3d37c263          	blt	a5,s3,13250 <_dtoa_r+0xb80>
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   12e90:	00cd1793          	slli	a5,s10,0xc
   12e94:	3a079e63          	bnez	a5,13250 <_dtoa_r+0xb80>
#ifndef Sudden_Underflow
	  && word0 (d) & Exp_mask
   12e98:	420d5693          	srai	a3,s10,0x20
   12e9c:	7ff007b7          	lui	a5,0x7ff00
   12ea0:	00f6f7b3          	and	a5,a3,a5
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   12ea4:	02012023          	sw	zero,32(sp)
  if (mode < 2)
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
#ifndef Sudden_Underflow
	  && word0 (d) & Exp_mask
   12ea8:	00078a63          	beqz	a5,12ebc <_dtoa_r+0x7ec>
	)
	{
	  /* The special case */
	  b2 += Log2P;
	  s2 += Log2P;
	  spec_case = 1;
   12eac:	00100793          	li	a5,1
	  && word0 (d) & Exp_mask
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
   12eb0:	0018081b          	addiw	a6,a6,1
	  s2 += Log2P;
   12eb4:	001d8d9b          	addiw	s11,s11,1
	  spec_case = 1;
   12eb8:	02f12023          	sw	a5,32(sp)
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   12ebc:	02812783          	lw	a5,40(sp)
   12ec0:	00100513          	li	a0,1
   12ec4:	08078863          	beqz	a5,12f54 <_dtoa_r+0x884>
   12ec8:	014c2783          	lw	a5,20(s8)
   12ecc:	03013423          	sd	a6,40(sp)
   12ed0:	fff7879b          	addiw	a5,a5,-1
   12ed4:	00478793          	addi	a5,a5,4 # 7ff00004 <_gp+0x7fee4534>
   12ed8:	00279793          	slli	a5,a5,0x2
   12edc:	00fc07b3          	add	a5,s8,a5
   12ee0:	0087a503          	lw	a0,8(a5)
   12ee4:	4b4020ef          	jal	15398 <__hi0bits>
   12ee8:	02000793          	li	a5,32
   12eec:	40a7853b          	subw	a0,a5,a0
   12ef0:	02813803          	ld	a6,40(sp)
   12ef4:	0600006f          	j	12f54 <_dtoa_r+0x884>
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
#endif
  k = (int) ds;
  if (ds < 0. && ds != k)
   12ef8:	d20b8753          	fcvt.d.w	fa4,s7
    k--;			/* want k = floor(ds) */
   12efc:	a2e7a7d3          	feq.d	a5,fa5,fa4
   12f00:	0017b793          	seqz	a5,a5
   12f04:	40fb8bbb          	subw	s7,s7,a5
   12f08:	9f9ff06f          	j	12900 <_dtoa_r+0x230>
      s5 = k;
      s2 += k;
    }
  else
    {
      b2 -= k;
   12f0c:	4178083b          	subw	a6,a6,s7
      b5 = -k;
   12f10:	41700c3b          	negw	s8,s7
      s5 = 0;
   12f14:	02012423          	sw	zero,40(sp)
   12f18:	a41ff06f          	j	12958 <_dtoa_r+0x288>
   12f1c:	000c0693          	mv	a3,s8
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   12f20:	00080493          	mv	s1,a6
  m5 = b5;
  mhi = mlo = 0;
   12f24:	00000a13          	li	s4,0
   12f28:	e8dff06f          	j	12db4 <_dtoa_r+0x6e4>
      i = bbits + be + (Bias + (P - 1) - 1);
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   12f2c:	000d049b          	sext.w	s1,s10
   12f30:	40d787bb          	subw	a5,a5,a3
   12f34:	00f494bb          	sllw	s1,s1,a5
   12f38:	959ff06f          	j	12890 <_dtoa_r+0x1c0>
  k_check = 1;
  if (k >= 0 && k <= Ten_pmax)
    {
      if (d.d < tens[k])
	k--;
      k_check = 0;
   12f3c:	02012823          	sw	zero,48(sp)
   12f40:	9f9ff06f          	j	12938 <_dtoa_r+0x268>
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   12f44:	00100793          	li	a5,1
   12f48:	0737d4e3          	ble	s3,a5,137b0 <_dtoa_r+0x10e0>
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   12f4c:	02012023          	sw	zero,32(sp)
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   12f50:	00078513          	mv	a0,a5
   12f54:	01b507bb          	addw	a5,a0,s11
   12f58:	01f7f793          	andi	a5,a5,31
   12f5c:	1a078663          	beqz	a5,13108 <_dtoa_r+0xa38>
    i = 32 - i;
   12f60:	02000693          	li	a3,32
   12f64:	40f686bb          	subw	a3,a3,a5
#else
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0xf) != 0)
    i = 16 - i;
#endif
  if (i > 4)
   12f68:	00400613          	li	a2,4
   12f6c:	04d658e3          	ble	a3,a2,137bc <_dtoa_r+0x10ec>
    {
      i -= 4;
   12f70:	01c00693          	li	a3,28
   12f74:	40f687bb          	subw	a5,a3,a5
      b2 += i;
   12f78:	00f8083b          	addw	a6,a6,a5
      m2 += i;
   12f7c:	00f484bb          	addw	s1,s1,a5
      s2 += i;
   12f80:	00fd8dbb          	addw	s11,s11,a5
      i += 28;
      b2 += i;
      m2 += i;
      s2 += i;
    }
  if (b2 > 0)
   12f84:	01005c63          	blez	a6,12f9c <_dtoa_r+0x8cc>
    b = lshift (ptr, b, b2);
   12f88:	00090593          	mv	a1,s2
   12f8c:	00080613          	mv	a2,a6
   12f90:	00040513          	mv	a0,s0
   12f94:	091020ef          	jal	15824 <__lshift>
   12f98:	00050913          	mv	s2,a0
  if (s2 > 0)
   12f9c:	01b05c63          	blez	s11,12fb4 <_dtoa_r+0x8e4>
    S = lshift (ptr, S, s2);
   12fa0:	000c0593          	mv	a1,s8
   12fa4:	000d8613          	mv	a2,s11
   12fa8:	00040513          	mv	a0,s0
   12fac:	079020ef          	jal	15824 <__lshift>
   12fb0:	00050c13          	mv	s8,a0
  if (k_check)
   12fb4:	03012783          	lw	a5,48(sp)
   12fb8:	22079663          	bnez	a5,131e4 <_dtoa_r+0xb14>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   12fbc:	3f505e63          	blez	s5,133b8 <_dtoa_r+0xce8>
    one_digit:
      *s++ = '1';
      k++;
      goto ret;
    }
  if (leftright)
   12fc0:	01012783          	lw	a5,16(sp)
   12fc4:	14078c63          	beqz	a5,1311c <_dtoa_r+0xa4c>
    {
      if (m2 > 0)
   12fc8:	00905c63          	blez	s1,12fe0 <_dtoa_r+0x910>
	mhi = lshift (ptr, mhi, m2);
   12fcc:	000a0593          	mv	a1,s4
   12fd0:	00048613          	mv	a2,s1
   12fd4:	00040513          	mv	a0,s0
   12fd8:	04d020ef          	jal	15824 <__lshift>
   12fdc:	00050a13          	mv	s4,a0
      /* Compute mlo -- check for special case
       * that d is a normalized power of 2.
       */

      mlo = mhi;
      if (spec_case)
   12fe0:	02012783          	lw	a5,32(sp)
   12fe4:	000a0d93          	mv	s11,s4
   12fe8:	5a079463          	bnez	a5,13590 <_dtoa_r+0xec0>
   12fec:	fffa849b          	addiw	s1,s5,-1
   12ff0:	00813783          	ld	a5,8(sp)
   12ff4:	02049493          	slli	s1,s1,0x20
   12ff8:	0204d493          	srli	s1,s1,0x20
   12ffc:	00148493          	addi	s1,s1,1
   13000:	009784b3          	add	s1,a5,s1
   13004:	00078c93          	mv	s9,a5
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
	  j1 = delta->_sign ? 1 : cmp (b, delta);
	  Bfree (ptr, delta);
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
   13008:	001d7793          	andi	a5,s10,1
   1300c:	00f13823          	sd	a5,16(sp)
	  mhi = lshift (ptr, mhi, Log2P);
	}

      for (i = 1;; i++)
	{
	  dig = quorem (b, S) + '0';
   13010:	000c0593          	mv	a1,s8
   13014:	00090513          	mv	a0,s2
   13018:	cccff0ef          	jal	124e4 <quorem>
   1301c:	00050d13          	mv	s10,a0
   13020:	02a12823          	sw	a0,48(sp)
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
   13024:	000a0593          	mv	a1,s4
   13028:	00090513          	mv	a0,s2
   1302c:	159020ef          	jal	15984 <__mcmp>
   13030:	00050a93          	mv	s5,a0
	  delta = diff (ptr, S, mhi);
   13034:	000d8613          	mv	a2,s11
   13038:	000c0593          	mv	a1,s8
   1303c:	00040513          	mv	a0,s0
   13040:	1a5020ef          	jal	159e4 <__mdiff>
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   13044:	01052683          	lw	a3,16(a0)
	  dig = quorem (b, S) + '0';
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
   13048:	00050793          	mv	a5,a0
	  mhi = lshift (ptr, mhi, Log2P);
	}

      for (i = 1;; i++)
	{
	  dig = quorem (b, S) + '0';
   1304c:	030d0d1b          	addiw	s10,s10,48
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   13050:	00100713          	li	a4,1
   13054:	00069e63          	bnez	a3,13070 <_dtoa_r+0x9a0>
   13058:	00050593          	mv	a1,a0
   1305c:	02a13023          	sd	a0,32(sp)
   13060:	00090513          	mv	a0,s2
   13064:	121020ef          	jal	15984 <__mcmp>
   13068:	02013783          	ld	a5,32(sp)
   1306c:	00050713          	mv	a4,a0
	  Bfree (ptr, delta);
   13070:	00078593          	mv	a1,a5
   13074:	00040513          	mv	a0,s0
   13078:	02e13023          	sd	a4,32(sp)
   1307c:	0bc020ef          	jal	15138 <_Bfree>
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
   13080:	02013703          	ld	a4,32(sp)
   13084:	013767b3          	or	a5,a4,s3
   13088:	00079663          	bnez	a5,13094 <_dtoa_r+0x9c4>
   1308c:	01012783          	lw	a5,16(sp)
   13090:	24078063          	beqz	a5,132d0 <_dtoa_r+0xc00>
		dig++;
	      *s++ = dig;
	      goto ret;
	    }
#endif
         if ((j < 0) || ((j == 0) && !mode
   13094:	260ac463          	bltz	s5,132fc <_dtoa_r+0xc2c>
   13098:	013aeab3          	or	s5,s5,s3
   1309c:	000a9663          	bnez	s5,130a8 <_dtoa_r+0x9d8>
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
   130a0:	01012783          	lw	a5,16(sp)
   130a4:	24078c63          	beqz	a5,132fc <_dtoa_r+0xc2c>
		    goto round_9_up;
		}
	      *s++ = dig;
	      goto ret;
	    }
	  if (j1 > 0)
   130a8:	5ee04263          	bgtz	a4,1368c <_dtoa_r+0xfbc>
		  goto roundoff;
		}
	      *s++ = dig + 1;
	      goto ret;
	    }
	  *s++ = dig;
   130ac:	001c8c93          	addi	s9,s9,1
   130b0:	ffac8fa3          	sb	s10,-1(s9)
	  if (i == ilim)
   130b4:	5f948463          	beq	s1,s9,1369c <_dtoa_r+0xfcc>
	    break;
	  b = multadd (ptr, b, 10, 0);
   130b8:	00090593          	mv	a1,s2
   130bc:	00000693          	li	a3,0
   130c0:	00a00613          	li	a2,10
   130c4:	00040513          	mv	a0,s0
   130c8:	094020ef          	jal	1515c <__multadd>
   130cc:	00050913          	mv	s2,a0
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   130d0:	00000693          	li	a3,0
   130d4:	00a00613          	li	a2,10
   130d8:	000a0593          	mv	a1,s4
   130dc:	00040513          	mv	a0,s0
	    }
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
   130e0:	27ba0463          	beq	s4,s11,13348 <_dtoa_r+0xc78>
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
   130e4:	078020ef          	jal	1515c <__multadd>
	      mhi = multadd (ptr, mhi, 10, 0);
   130e8:	000d8593          	mv	a1,s11
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
   130ec:	00050a13          	mv	s4,a0
	      mhi = multadd (ptr, mhi, 10, 0);
   130f0:	00000693          	li	a3,0
   130f4:	00a00613          	li	a2,10
   130f8:	00040513          	mv	a0,s0
   130fc:	060020ef          	jal	1515c <__multadd>
   13100:	00050d93          	mv	s11,a0
	    }
	}
   13104:	f0dff06f          	j	13010 <_dtoa_r+0x940>
   13108:	01c00793          	li	a5,28
      s2 += i;
    }
  else if (i < 4)
    {
      i += 28;
      b2 += i;
   1310c:	00f8083b          	addw	a6,a6,a5
      m2 += i;
   13110:	00f484bb          	addw	s1,s1,a5
      s2 += i;
   13114:	00fd8dbb          	addw	s11,s11,a5
   13118:	e6dff06f          	j	12f84 <_dtoa_r+0x8b4>
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   1311c:	00813483          	ld	s1,8(sp)
   13120:	00100993          	li	s3,1
   13124:	0100006f          	j	13134 <_dtoa_r+0xa64>
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
	if (i >= ilim)
	  break;
	b = multadd (ptr, b, 10, 0);
   13128:	034020ef          	jal	1515c <__multadd>
   1312c:	00050913          	mv	s2,a0
	      mhi = multadd (ptr, mhi, 10, 0);
	    }
	}
    }
  else
    for (i = 1;; i++)
   13130:	0019899b          	addiw	s3,s3,1
      {
	*s++ = dig = quorem (b, S) + '0';
   13134:	000c0593          	mv	a1,s8
   13138:	00090513          	mv	a0,s2
   1313c:	ba8ff0ef          	jal	124e4 <quorem>
   13140:	03050d1b          	addiw	s10,a0,48
   13144:	00148493          	addi	s1,s1,1
   13148:	ffa48fa3          	sb	s10,-1(s1)
	if (i >= ilim)
	  break;
	b = multadd (ptr, b, 10, 0);
   1314c:	00000693          	li	a3,0
   13150:	00a00613          	li	a2,10
   13154:	00090593          	mv	a1,s2
   13158:	00040513          	mv	a0,s0
    }
  else
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
	if (i >= ilim)
   1315c:	fd59c6e3          	blt	s3,s5,13128 <_dtoa_r+0xa58>
      goto ret1;
    }

  m2 = b2;
  m5 = b5;
  mhi = mlo = 0;
   13160:	00000993          	li	s3,0
	b = multadd (ptr, b, 10, 0);
      }

  /* Round off last digit */

  b = lshift (ptr, b, 1);
   13164:	00090593          	mv	a1,s2
   13168:	00100613          	li	a2,1
   1316c:	00040513          	mv	a0,s0
   13170:	6b4020ef          	jal	15824 <__lshift>
  j = cmp (b, S);
   13174:	000c0593          	mv	a1,s8
	b = multadd (ptr, b, 10, 0);
      }

  /* Round off last digit */

  b = lshift (ptr, b, 1);
   13178:	02a13023          	sd	a0,32(sp)
  j = cmp (b, S);
   1317c:	009020ef          	jal	15984 <__mcmp>
  if ((j > 0) || ((j == 0) && (dig & 1)))
   13180:	34a05463          	blez	a0,134c8 <_dtoa_r+0xdf8>
   13184:	fff4c703          	lbu	a4,-1(s1)
    {
    roundoff:
      while (*--s == '9')
   13188:	03900693          	li	a3,57
   1318c:	0140006f          	j	131a0 <_dtoa_r+0xad0>
	if (s == s0)
   13190:	00813703          	ld	a4,8(sp)
   13194:	26e78a63          	beq	a5,a4,13408 <_dtoa_r+0xd38>
   13198:	fff7c703          	lbu	a4,-1(a5)
   1319c:	00078493          	mv	s1,a5
  b = lshift (ptr, b, 1);
  j = cmp (b, S);
  if ((j > 0) || ((j == 0) && (dig & 1)))
    {
    roundoff:
      while (*--s == '9')
   131a0:	fff48793          	addi	a5,s1,-1
   131a4:	fed706e3          	beq	a4,a3,13190 <_dtoa_r+0xac0>
	  {
	    k++;
	    *s++ = '1';
	    goto ret;
	  }
      ++*s++;
   131a8:	0017071b          	addiw	a4,a4,1
   131ac:	00e78023          	sb	a4,0(a5)
    {
      while (*--s == '0');
      s++;
    }
ret:
  Bfree (ptr, S);
   131b0:	000c0593          	mv	a1,s8
   131b4:	00040513          	mv	a0,s0
   131b8:	781010ef          	jal	15138 <_Bfree>
  if (mhi)
   131bc:	9e0a0ae3          	beqz	s4,12bb0 <_dtoa_r+0x4e0>
    {
      if (mlo && mlo != mhi)
   131c0:	00098a63          	beqz	s3,131d4 <_dtoa_r+0xb04>
   131c4:	01498863          	beq	s3,s4,131d4 <_dtoa_r+0xb04>
	Bfree (ptr, mlo);
   131c8:	00098593          	mv	a1,s3
   131cc:	00040513          	mv	a0,s0
   131d0:	769010ef          	jal	15138 <_Bfree>
      Bfree (ptr, mhi);
   131d4:	000a0593          	mv	a1,s4
   131d8:	00040513          	mv	a0,s0
   131dc:	75d010ef          	jal	15138 <_Bfree>
   131e0:	9d1ff06f          	j	12bb0 <_dtoa_r+0x4e0>
    b = lshift (ptr, b, b2);
  if (s2 > 0)
    S = lshift (ptr, S, s2);
  if (k_check)
    {
      if (cmp (b, S) < 0)
   131e4:	000c0593          	mv	a1,s8
   131e8:	00090513          	mv	a0,s2
   131ec:	798020ef          	jal	15984 <__mcmp>
   131f0:	dc0556e3          	bgez	a0,12fbc <_dtoa_r+0x8ec>
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   131f4:	00090593          	mv	a1,s2
   131f8:	00000693          	li	a3,0
   131fc:	00a00613          	li	a2,10
   13200:	00040513          	mv	a0,s0
   13204:	759010ef          	jal	1515c <__multadd>
	  if (leftright)
   13208:	01012783          	lw	a5,16(sp)
  if (k_check)
    {
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   1320c:	00050913          	mv	s2,a0
    S = lshift (ptr, S, s2);
  if (k_check)
    {
      if (cmp (b, S) < 0)
	{
	  k--;
   13210:	fffb8b9b          	addiw	s7,s7,-1
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
   13214:	56079063          	bnez	a5,13774 <_dtoa_r+0x10a4>
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   13218:	03412783          	lw	a5,52(sp)
   1321c:	00078a93          	mv	s5,a5
   13220:	eef04ee3          	bgtz	a5,1311c <_dtoa_r+0xa4c>
   13224:	00200793          	li	a5,2
   13228:	5937c063          	blt	a5,s3,137a8 <_dtoa_r+0x10d8>
	}
    }
  else
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
   1322c:	000c0593          	mv	a1,s8
   13230:	ab4ff0ef          	jal	124e4 <quorem>
   13234:	00813783          	ld	a5,8(sp)
   13238:	03050d1b          	addiw	s10,a0,48
   1323c:	00178493          	addi	s1,a5,1
   13240:	ffa48fa3          	sb	s10,-1(s1)
   13244:	f1dff06f          	j	13160 <_dtoa_r+0xa90>
      s2 += i;
      mhi = i2b (ptr, 1);
    }
  if (m2 > 0 && s2 > 0)
    {
      i = m2 < s2 ? m2 : s2;
   13248:	000d8793          	mv	a5,s11
   1324c:	b79ff06f          	j	12dc4 <_dtoa_r+0x6f4>
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   13250:	02012023          	sw	zero,32(sp)
   13254:	c75ff06f          	j	12ec8 <_dtoa_r+0x7f8>
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   13258:	00100793          	li	a5,1
   1325c:	00f12823          	sw	a5,16(sp)
      break;
    case 2:
      leftright = 0;
      /* no break */
    case 4:
      if (ndigits <= 0)
   13260:	0f905c63          	blez	s9,13358 <_dtoa_r+0xc88>
   13264:	000c8513          	mv	a0,s9
   13268:	000c8493          	mv	s1,s9
   1326c:	03912a23          	sw	s9,52(sp)
   13270:	000c8a93          	mv	s5,s9
   13274:	f3cff06f          	j	129b0 <_dtoa_r+0x2e0>

  if (be >= 0 && k <= Int_max)
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
   13278:	a1504ce3          	bgtz	s5,12c90 <_dtoa_r+0x5c0>
	{
	  S = mhi = 0;
	  if (ilim < 0 || d.d <= 5 * ds)
   1327c:	1e0a9e63          	bnez	s5,13478 <_dtoa_r+0xda8>
   13280:	0001b7b7          	lui	a5,0x1b
   13284:	3407b787          	fld	fa5,832(a5) # 1b340 <__wctomb+0x40>
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
	{
	  S = mhi = 0;
   13288:	00000c13          	li	s8,0
   1328c:	00000a13          	li	s4,0
	  if (ilim < 0 || d.d <= 5 * ds)
   13290:	12f6f6d3          	fmul.d	fa3,fa3,fa5
   13294:	f20d07d3          	fmv.d.x	fa5,s10
   13298:	a2d78753          	fle.d	a4,fa5,fa3
   1329c:	14070a63          	beqz	a4,133f0 <_dtoa_r+0xd20>
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
	{
	  /* no digits, fcvt style */
	no_digits:
	  k = -1 - ndigits;
	  goto ret;
   132a0:	00813483          	ld	s1,8(sp)
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
	{
	  /* no digits, fcvt style */
	no_digits:
	  k = -1 - ndigits;
   132a4:	fffccb93          	not	s7,s9
    {
      while (*--s == '0');
      s++;
    }
ret:
  Bfree (ptr, S);
   132a8:	000c0593          	mv	a1,s8
   132ac:	00040513          	mv	a0,s0
   132b0:	689010ef          	jal	15138 <_Bfree>
  if (mhi)
   132b4:	8e0a0ee3          	beqz	s4,12bb0 <_dtoa_r+0x4e0>
   132b8:	f1dff06f          	j	131d4 <_dtoa_r+0xb04>
    {
      if (mode < 2)
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   132bc:	3e090c63          	beqz	s2,136b4 <_dtoa_r+0xfe4>
   132c0:	4337879b          	addiw	a5,a5,1075
   132c4:	000c0693          	mv	a3,s8
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   132c8:	00080493          	mv	s1,a6
   132cc:	abdff06f          	j	12d88 <_dtoa_r+0x6b8>
	  j1 = delta->_sign ? 1 : cmp (b, delta);
	  Bfree (ptr, delta);
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
	    {
	      if (dig == '9')
   132d0:	03900793          	li	a5,57
   132d4:	04fd0a63          	beq	s10,a5,13328 <_dtoa_r+0xc58>
		goto round_9_up;
	      if (j > 0)
   132d8:	01505663          	blez	s5,132e4 <_dtoa_r+0xc14>
	      if (j1 > 0)
		{
		  b = lshift (ptr, b, 1);
		  j1 = cmp (b, S);
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
		      && dig++ == '9')
   132dc:	03012783          	lw	a5,48(sp)
   132e0:	03178d1b          	addiw	s10,a5,49
		round_9_up:
		  *s++ = '9';
		  goto roundoff;
		}
	      *s++ = dig + 1;
	      goto ret;
   132e4:	000a0993          	mv	s3,s4
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
		  goto roundoff;
		}
	      *s++ = dig + 1;
   132e8:	001c8493          	addi	s1,s9,1
   132ec:	01ac8023          	sb	s10,0(s9)
	      goto ret;
   132f0:	000d8a13          	mv	s4,s11
   132f4:	03213023          	sd	s2,32(sp)
   132f8:	eb9ff06f          	j	131b0 <_dtoa_r+0xae0>
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
#endif
           ))
	    {
	      if (j1 > 0)
   132fc:	fee054e3          	blez	a4,132e4 <_dtoa_r+0xc14>
		{
		  b = lshift (ptr, b, 1);
   13300:	00090593          	mv	a1,s2
   13304:	00100613          	li	a2,1
   13308:	00040513          	mv	a0,s0
   1330c:	518020ef          	jal	15824 <__lshift>
		  j1 = cmp (b, S);
   13310:	000c0593          	mv	a1,s8
#endif
           ))
	    {
	      if (j1 > 0)
		{
		  b = lshift (ptr, b, 1);
   13314:	00050913          	mv	s2,a0
		  j1 = cmp (b, S);
   13318:	66c020ef          	jal	15984 <__mcmp>
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   1331c:	44a05063          	blez	a0,1375c <_dtoa_r+0x108c>
		      && dig++ == '9')
   13320:	03900793          	li	a5,57
   13324:	fafd1ce3          	bne	s10,a5,132dc <_dtoa_r+0xc0c>
	  if (j1 > 0)
	    {
	      if (dig == '9')
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
   13328:	03900793          	li	a5,57
		  goto roundoff;
   1332c:	000a0993          	mv	s3,s4
	  if (j1 > 0)
	    {
	      if (dig == '9')
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
   13330:	001c8493          	addi	s1,s9,1
   13334:	00fc8023          	sb	a5,0(s9)
		  goto roundoff;
   13338:	000d8a13          	mv	s4,s11
   1333c:	03213023          	sd	s2,32(sp)
   13340:	03900713          	li	a4,57
   13344:	e45ff06f          	j	13188 <_dtoa_r+0xab8>
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   13348:	615010ef          	jal	1515c <__multadd>
   1334c:	00050a13          	mv	s4,a0
   13350:	00050d93          	mv	s11,a0
   13354:	cbdff06f          	j	13010 <_dtoa_r+0x940>
   13358:	00100493          	li	s1,1
    case 2:
      leftright = 0;
      /* no break */
    case 4:
      if (ndigits <= 0)
	ndigits = 1;
   1335c:	02912a23          	sw	s1,52(sp)
   13360:	00048a93          	mv	s5,s1
   13364:	00048c93          	mv	s9,s1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   13368:	06042423          	sw	zero,104(s0)
   1336c:	00000593          	li	a1,0
   13370:	e74ff06f          	j	129e4 <_dtoa_r+0x314>
    case 1:
      i = 18;
      ndigits = 0;
      break;
    case 2:
      leftright = 0;
   13374:	00012823          	sw	zero,16(sp)
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
  switch (mode)
   13378:	00200793          	li	a5,2
   1337c:	eef982e3          	beq	s3,a5,13260 <_dtoa_r+0xb90>
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   13380:	06042423          	sw	zero,104(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   13384:	00000593          	li	a1,0
   13388:	00040513          	mv	a0,s0
   1338c:	03013c23          	sd	a6,56(sp)
   13390:	4fd010ef          	jal	1508c <_Balloc>
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   13394:	fff00a93          	li	s5,-1
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   13398:	00100793          	li	a5,1
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   1339c:	00a13423          	sd	a0,8(sp)
   133a0:	06a43023          	sd	a0,96(s0)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   133a4:	03512a23          	sw	s5,52(sp)
  switch (mode)
    {
    case 0:
    case 1:
      i = 18;
      ndigits = 0;
   133a8:	00000c93          	li	s9,0
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   133ac:	00f12823          	sw	a5,16(sp)
   133b0:	03813803          	ld	a6,56(sp)
   133b4:	8b5ff06f          	j	12c68 <_dtoa_r+0x598>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   133b8:	00200793          	li	a5,2
   133bc:	c137d2e3          	ble	s3,a5,12fc0 <_dtoa_r+0x8f0>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
   133c0:	300a9663          	bnez	s5,136cc <_dtoa_r+0xffc>
   133c4:	000c0593          	mv	a1,s8
   133c8:	00000693          	li	a3,0
   133cc:	00500613          	li	a2,5
   133d0:	00040513          	mv	a0,s0
   133d4:	589010ef          	jal	1515c <__multadd>
   133d8:	00050593          	mv	a1,a0
   133dc:	00050c13          	mv	s8,a0
   133e0:	00090513          	mv	a0,s2
   133e4:	5a0020ef          	jal	15984 <__mcmp>
   133e8:	03213023          	sd	s2,32(sp)
   133ec:	eaa05ae3          	blez	a0,132a0 <_dtoa_r+0xbd0>
	no_digits:
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
   133f0:	00813703          	ld	a4,8(sp)
   133f4:	03100793          	li	a5,49
      k++;
   133f8:	001b8b9b          	addiw	s7,s7,1
	no_digits:
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
   133fc:	00170493          	addi	s1,a4,1
   13400:	00f70023          	sb	a5,0(a4)
      k++;
      goto ret;
   13404:	ea5ff06f          	j	132a8 <_dtoa_r+0xbd8>
    roundoff:
      while (*--s == '9')
	if (s == s0)
	  {
	    k++;
	    *s++ = '1';
   13408:	00813703          	ld	a4,8(sp)
   1340c:	03100793          	li	a5,49
    {
    roundoff:
      while (*--s == '9')
	if (s == s0)
	  {
	    k++;
   13410:	001b8b9b          	addiw	s7,s7,1
	    *s++ = '1';
   13414:	00f70023          	sb	a5,0(a4)
	    goto ret;
   13418:	d99ff06f          	j	131b0 <_dtoa_r+0xae0>
      if (ndigits <= 0)
	ndigits = 1;
      ilim = ilim1 = i = ndigits;
      break;
    case 3:
      leftright = 0;
   1341c:	00012823          	sw	zero,16(sp)
   13420:	d78ff06f          	j	12998 <_dtoa_r+0x2c8>
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   13424:	0001b7b7          	lui	a5,0x1b
   13428:	d20706d3          	fcvt.d.w	fa3,a4
   1342c:	3387b707          	fld	fa4,824(a5) # 1b338 <__wctomb+0x38>
      word0 (eps) -= (P - 1) * Exp_msk1;
   13430:	fcc006b7          	lui	a3,0xfcc00
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   13434:	72d7f743          	fmadd.d	fa4,fa5,fa3,fa4
   13438:	e2070753          	fmv.x.d	a4,fa4
      word0 (eps) -= (P - 1) * Exp_msk1;
   1343c:	42075793          	srai	a5,a4,0x20
   13440:	00d787bb          	addw	a5,a5,a3
   13444:	02071713          	slli	a4,a4,0x20
   13448:	02079793          	slli	a5,a5,0x20
   1344c:	02075713          	srli	a4,a4,0x20
   13450:	00f76733          	or	a4,a4,a5
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
   13454:	0001b7b7          	lui	a5,0x1b
   13458:	3407b707          	fld	fa4,832(a5) # 1b340 <__wctomb+0x40>
	  if (d.d > eps.d)
   1345c:	f20706d3          	fmv.d.x	fa3,a4
      eps.d = ieps * d.d + 7.;
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
   13460:	0ae7f7d3          	fsub.d	fa5,fa5,fa4
	  if (d.d > eps.d)
   13464:	a2f697d3          	flt.d	a5,fa3,fa5
   13468:	16079463          	bnez	a5,135d0 <_dtoa_r+0xf00>
	    goto one_digit;
	  if (d.d < -eps.d)
   1346c:	22d69753          	fneg.d	fa4,fa3
   13470:	a2e797d3          	flt.d	a5,fa5,fa4
   13474:	06078e63          	beqz	a5,134f0 <_dtoa_r+0xe20>
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
	{
	  S = mhi = 0;
   13478:	00000c13          	li	s8,0
   1347c:	00000a13          	li	s4,0
   13480:	e21ff06f          	j	132a0 <_dtoa_r+0xbd0>
	    }
         if ((j = b5 - m5) != 0)
	    b = pow5mult (ptr, b, j);
	}
      else
	b = pow5mult (ptr, b, b5);
   13484:	00090593          	mv	a1,s2
   13488:	000c0613          	mv	a2,s8
   1348c:	00040513          	mv	a0,s0
   13490:	03013023          	sd	a6,32(sp)
   13494:	258020ef          	jal	156ec <__pow5mult>
   13498:	00050913          	mv	s2,a0
   1349c:	02013803          	ld	a6,32(sp)
   134a0:	9b1ff06f          	j	12e50 <_dtoa_r+0x780>
   134a4:	00813503          	ld	a0,8(sp)
   134a8:	af4ff06f          	j	1279c <_dtoa_r+0xcc>
	  j = ilim - 1;
	  if (m5 >= j)
	    m5 -= j;
	  else
	    {
	      s5 += j -= m5;
   134ac:	02812783          	lw	a5,40(sp)
   134b0:	41868c3b          	subw	s8,a3,s8
   134b4:	018787bb          	addw	a5,a5,s8
   134b8:	02f12423          	sw	a5,40(sp)
   134bc:	00068c13          	mv	s8,a3
	      b5 += j;
	      m5 = 0;
   134c0:	00000693          	li	a3,0
   134c4:	8b9ff06f          	j	12d7c <_dtoa_r+0x6ac>

  /* Round off last digit */

  b = lshift (ptr, b, 1);
  j = cmp (b, S);
  if ((j > 0) || ((j == 0) && (dig & 1)))
   134c8:	00051663          	bnez	a0,134d4 <_dtoa_r+0xe04>
   134cc:	001d7d13          	andi	s10,s10,1
   134d0:	ca0d1ae3          	bnez	s10,13184 <_dtoa_r+0xab4>
	  }
      ++*s++;
    }
  else
    {
      while (*--s == '0');
   134d4:	03000693          	li	a3,48
   134d8:	0080006f          	j	134e0 <_dtoa_r+0xe10>
   134dc:	00070493          	mv	s1,a4
   134e0:	fff4c783          	lbu	a5,-1(s1)
   134e4:	fff48713          	addi	a4,s1,-1
   134e8:	fed78ae3          	beq	a5,a3,134dc <_dtoa_r+0xe0c>
   134ec:	cc5ff06f          	j	131b0 <_dtoa_r+0xae0>
#ifndef No_leftright
	}
#endif
    fast_failed:
      s = s0;
      d.d = d2.d;
   134f0:	03813d03          	ld	s10,56(sp)
   134f4:	f74ff06f          	j	12c68 <_dtoa_r+0x598>
#endif
	  *s++ = '0' + (int) L;
	  if (i == ilim)
	    {
	      d.d += d.d;
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
   134f8:	a2f6a753          	feq.d	a4,fa3,fa5
   134fc:	00068493          	mv	s1,a3
   13500:	ea070863          	beqz	a4,12bb0 <_dtoa_r+0x4e0>
   13504:	0017f793          	andi	a5,a5,1
   13508:	ea078463          	beqz	a5,12bb0 <_dtoa_r+0x4e0>
   1350c:	fff6c783          	lbu	a5,-1(a3) # fffffffffcbfffff <_gp+0xfffffffffcbe452f>
   13510:	825ff06f          	j	12d34 <_dtoa_r+0x664>
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
   13514:	417007bb          	negw	a5,s7
   13518:	03813787          	fld	fa5,56(sp)

      i = 0;
      d2.d = d.d;
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
   1351c:	00200713          	li	a4,2
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
   13520:	d6078063          	beqz	a5,12a80 <_dtoa_r+0x3b0>
	{
	  d.d *= tens[j1 & 0xf];
   13524:	00f7f693          	andi	a3,a5,15
   13528:	00019637          	lui	a2,0x19
   1352c:	00369693          	slli	a3,a3,0x3
   13530:	f6060613          	addi	a2,a2,-160 # 18f60 <__mprec_tens>
   13534:	00c686b3          	add	a3,a3,a2
   13538:	0006b787          	fld	fa5,0(a3)
   1353c:	03813707          	fld	fa4,56(sp)
	  for (j = j1 >> 4; j; j >>= 1, i++)
   13540:	4047d79b          	sraiw	a5,a5,0x4
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
   13544:	12f777d3          	fmul.d	fa5,fa4,fa5
	  for (j = j1 >> 4; j; j >>= 1, i++)
   13548:	d2078c63          	beqz	a5,12a80 <_dtoa_r+0x3b0>
   1354c:	000196b7          	lui	a3,0x19
   13550:	05068693          	addi	a3,a3,80 # 19050 <__mprec_bigtens>
	    if (j & 1)
   13554:	0017f613          	andi	a2,a5,1
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
   13558:	4017d79b          	sraiw	a5,a5,0x1
	    if (j & 1)
   1355c:	00060863          	beqz	a2,1356c <_dtoa_r+0xe9c>
	      {
		ieps++;
		d.d *= bigtens[i];
   13560:	0006b707          	fld	fa4,0(a3)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
	    if (j & 1)
	      {
		ieps++;
   13564:	0017071b          	addiw	a4,a4,1
		d.d *= bigtens[i];
   13568:	12e7f7d3          	fmul.d	fa5,fa5,fa4
   1356c:	00868693          	addi	a3,a3,8
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
   13570:	fe0792e3          	bnez	a5,13554 <_dtoa_r+0xe84>
   13574:	d0cff06f          	j	12a80 <_dtoa_r+0x3b0>
		bump_up:
		  while (*--s == '9')
		    if (s == s0)
		      {
			k++;
			*s = '0';
   13578:	00813683          	ld	a3,8(sp)
   1357c:	03000793          	li	a5,48
		{
		bump_up:
		  while (*--s == '9')
		    if (s == s0)
		      {
			k++;
   13580:	001b8b9b          	addiw	s7,s7,1
			*s = '0';
   13584:	00f68023          	sb	a5,0(a3)
   13588:	fff4c783          	lbu	a5,-1(s1)
			break;
   1358c:	fc8ff06f          	j	12d54 <_dtoa_r+0x684>
       */

      mlo = mhi;
      if (spec_case)
	{
	  mhi = Balloc (ptr, mhi->_k);
   13590:	008a2583          	lw	a1,8(s4)
   13594:	00040513          	mv	a0,s0
   13598:	2f5010ef          	jal	1508c <_Balloc>
	  Bcopy (mhi, mlo);
   1359c:	014a2603          	lw	a2,20(s4)
       */

      mlo = mhi;
      if (spec_case)
	{
	  mhi = Balloc (ptr, mhi->_k);
   135a0:	00050493          	mv	s1,a0
	  Bcopy (mhi, mlo);
   135a4:	010a0593          	addi	a1,s4,16
   135a8:	00260613          	addi	a2,a2,2
   135ac:	00261613          	slli	a2,a2,0x2
   135b0:	01050513          	addi	a0,a0,16
   135b4:	0d5010ef          	jal	14e88 <memcpy>
	  mhi = lshift (ptr, mhi, Log2P);
   135b8:	00100613          	li	a2,1
   135bc:	00048593          	mv	a1,s1
   135c0:	00040513          	mv	a0,s0
   135c4:	260020ef          	jal	15824 <__lshift>
   135c8:	00050d93          	mv	s11,a0
   135cc:	a21ff06f          	j	12fec <_dtoa_r+0x91c>
	}
      eps.d = ieps * d.d + 7.;
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
	{
	  S = mhi = 0;
   135d0:	00000c13          	li	s8,0
   135d4:	00000a13          	li	s4,0
   135d8:	e19ff06f          	j	133f0 <_dtoa_r+0xd20>
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
   135dc:	fff6079b          	addiw	a5,a2,-1
   135e0:	00019537          	lui	a0,0x19
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
   135e4:	c20795d3          	fcvt.w.d	a1,fa5,rtz
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
   135e8:	00379793          	slli	a5,a5,0x3
   135ec:	f6050513          	addi	a0,a0,-160 # 18f60 <__mprec_tens>
   135f0:	00a787b3          	add	a5,a5,a0
   135f4:	0007b707          	fld	fa4,0(a5)
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   135f8:	00813783          	ld	a5,8(sp)
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
   135fc:	d20586d3          	fcvt.d.w	fa3,a1
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
   13600:	f2070653          	fmv.d.x	fa2,a4
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   13604:	0305859b          	addiw	a1,a1,48
   13608:	00b78023          	sb	a1,0(a5)
   1360c:	00178493          	addi	s1,a5,1
	      if (i == ilim)
   13610:	00100793          	li	a5,1
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
   13614:	12c77653          	fmul.d	fa2,fa4,fa2
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
   13618:	0ad7f7d3          	fsub.d	fa5,fa5,fa3
	      *s++ = '0' + (int) L;
	      if (i == ilim)
   1361c:	04f60863          	beq	a2,a5,1366c <_dtoa_r+0xf9c>
   13620:	ffe6061b          	addiw	a2,a2,-2
   13624:	0001b7b7          	lui	a5,0x1b
   13628:	02061593          	slli	a1,a2,0x20
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
   1362c:	3307b687          	fld	fa3,816(a5) # 1b330 <__wctomb+0x30>
   13630:	00813783          	ld	a5,8(sp)
   13634:	0205d593          	srli	a1,a1,0x20
   13638:	00258513          	addi	a0,a1,2
   1363c:	00a78533          	add	a0,a5,a0
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (i == ilim)
   13640:	00048613          	mv	a2,s1
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
   13644:	12d7f7d3          	fmul.d	fa5,fa5,fa3
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   13648:	00160613          	addi	a2,a2,1
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
   1364c:	c20797d3          	fcvt.w.d	a5,fa5,rtz
	      d.d -= L;
   13650:	d2078753          	fcvt.d.w	fa4,a5
	      *s++ = '0' + (int) L;
   13654:	0307879b          	addiw	a5,a5,48
   13658:	fef60fa3          	sb	a5,-1(a2)
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
   1365c:	0ae7f7d3          	fsub.d	fa5,fa5,fa4
	      *s++ = '0' + (int) L;
	      if (i == ilim)
   13660:	fea612e3          	bne	a2,a0,13644 <_dtoa_r+0xf74>
   13664:	00158593          	addi	a1,a1,1
   13668:	00b484b3          	add	s1,s1,a1
		{
		  if (d.d > 0.5 + eps.d)
   1366c:	0001b7b7          	lui	a5,0x1b
   13670:	3487b707          	fld	fa4,840(a5) # 1b348 <__wctomb+0x48>
   13674:	02e676d3          	fadd.d	fa3,fa2,fa4
   13678:	a2f697d3          	flt.d	a5,fa3,fa5
   1367c:	0a078663          	beqz	a5,13728 <_dtoa_r+0x1058>
   13680:	fff4c783          	lbu	a5,-1(s1)
   13684:	00068b93          	mv	s7,a3
   13688:	eacff06f          	j	12d34 <_dtoa_r+0x664>
	      *s++ = dig;
	      goto ret;
	    }
	  if (j1 > 0)
	    {
	      if (dig == '9')
   1368c:	03900793          	li	a5,57
   13690:	c8fd0ce3          	beq	s10,a5,13328 <_dtoa_r+0xc58>
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
		  goto roundoff;
		}
	      *s++ = dig + 1;
   13694:	001d0d1b          	addiw	s10,s10,1
   13698:	c4dff06f          	j	132e4 <_dtoa_r+0xc14>
   1369c:	000a0993          	mv	s3,s4
   136a0:	000d8a13          	mv	s4,s11
   136a4:	ac1ff06f          	j	13164 <_dtoa_r+0xa94>
	      b5 += j;
	      m5 = 0;
	    }
	  if ((i = ilim) < 0)
	    {
	      m2 -= i;
   136a8:	415804bb          	subw	s1,a6,s5
	      i = 0;
   136ac:	00000793          	li	a5,0
   136b0:	ed8ff06f          	j	12d88 <_dtoa_r+0x6b8>
    {
      if (mode < 2)
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   136b4:	05812603          	lw	a2,88(sp)
   136b8:	03600793          	li	a5,54
   136bc:	000c0693          	mv	a3,s8
   136c0:	40c787bb          	subw	a5,a5,a2
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   136c4:	00080493          	mv	s1,a6
   136c8:	ec0ff06f          	j	12d88 <_dtoa_r+0x6b8>
   136cc:	03213023          	sd	s2,32(sp)
   136d0:	bd1ff06f          	j	132a0 <_dtoa_r+0xbd0>
	      {
		ieps++;
		d.d *= bigtens[i];
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
   136d4:	d40a88e3          	beqz	s5,13424 <_dtoa_r+0xd54>
	{
	  if (ilim1 <= 0)
   136d8:	03412603          	lw	a2,52(sp)
   136dc:	e0c05ae3          	blez	a2,134f0 <_dtoa_r+0xe20>
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
   136e0:	0001b7b7          	lui	a5,0x1b
   136e4:	3307b707          	fld	fa4,816(a5) # 1b330 <__wctomb+0x30>
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   136e8:	0017071b          	addiw	a4,a4,1
   136ec:	0001b7b7          	lui	a5,0x1b
	{
	  if (ilim1 <= 0)
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
   136f0:	12e7f7d3          	fmul.d	fa5,fa5,fa4
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   136f4:	d20706d3          	fcvt.d.w	fa3,a4
   136f8:	3387b707          	fld	fa4,824(a5) # 1b338 <__wctomb+0x38>
      word0 (eps) -= (P - 1) * Exp_msk1;
   136fc:	fcc005b7          	lui	a1,0xfcc00
      if (k_check && d.d < 1. && ilim > 0)
	{
	  if (ilim1 <= 0)
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
   13700:	fffb869b          	addiw	a3,s7,-1
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   13704:	72d7f743          	fmadd.d	fa4,fa5,fa3,fa4
   13708:	e2070753          	fmv.x.d	a4,fa4
      word0 (eps) -= (P - 1) * Exp_msk1;
   1370c:	42075793          	srai	a5,a4,0x20
   13710:	00b787bb          	addw	a5,a5,a1
   13714:	02071713          	slli	a4,a4,0x20
   13718:	02079793          	slli	a5,a5,0x20
   1371c:	02075713          	srli	a4,a4,0x20
   13720:	00f76733          	or	a4,a4,a5
   13724:	bb0ff06f          	j	12ad4 <_dtoa_r+0x404>
	      *s++ = '0' + (int) L;
	      if (i == ilim)
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
   13728:	0ac77753          	fsub.d	fa4,fa4,fa2
		    {
		      while (*--s == '0');
   1372c:	03000613          	li	a2,48
	      *s++ = '0' + (int) L;
	      if (i == ilim)
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
   13730:	a2e797d3          	flt.d	a5,fa5,fa4
   13734:	00079663          	bnez	a5,13740 <_dtoa_r+0x1070>
   13738:	db9ff06f          	j	134f0 <_dtoa_r+0xe20>
   1373c:	00070493          	mv	s1,a4
		    {
		      while (*--s == '0');
   13740:	fff4c783          	lbu	a5,-1(s1)
   13744:	fff48713          	addi	a4,s1,-1
   13748:	fec78ae3          	beq	a5,a2,1373c <_dtoa_r+0x106c>
   1374c:	00068b93          	mv	s7,a3
   13750:	c60ff06f          	j	12bb0 <_dtoa_r+0x4e0>
   13754:	00068b93          	mv	s7,a3
   13758:	ddcff06f          	j	12d34 <_dtoa_r+0x664>
	    {
	      if (j1 > 0)
		{
		  b = lshift (ptr, b, 1);
		  j1 = cmp (b, S);
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   1375c:	b80514e3          	bnez	a0,132e4 <_dtoa_r+0xc14>
   13760:	001d7793          	andi	a5,s10,1
   13764:	b80780e3          	beqz	a5,132e4 <_dtoa_r+0xc14>
   13768:	bb9ff06f          	j	13320 <_dtoa_r+0xc50>
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   1376c:	00048693          	mv	a3,s1
   13770:	db0ff06f          	j	12d20 <_dtoa_r+0x650>
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
   13774:	000a0593          	mv	a1,s4
   13778:	00000693          	li	a3,0
   1377c:	00a00613          	li	a2,10
   13780:	00040513          	mv	a0,s0
   13784:	1d9010ef          	jal	1515c <__multadd>
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   13788:	03412783          	lw	a5,52(sp)
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
   1378c:	00050a13          	mv	s4,a0
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   13790:	00078a93          	mv	s5,a5
   13794:	82f04ae3          	bgtz	a5,12fc8 <_dtoa_r+0x8f8>
   13798:	00200793          	li	a5,2
   1379c:	0137c663          	blt	a5,s3,137a8 <_dtoa_r+0x10d8>
   137a0:	03412a83          	lw	s5,52(sp)
   137a4:	825ff06f          	j	12fc8 <_dtoa_r+0x8f8>
   137a8:	03412a83          	lw	s5,52(sp)
   137ac:	c15ff06f          	j	133c0 <_dtoa_r+0xcf0>
  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   137b0:	00cd1713          	slli	a4,s10,0xc
   137b4:	ee070263          	beqz	a4,12e98 <_dtoa_r+0x7c8>
   137b8:	f94ff06f          	j	12f4c <_dtoa_r+0x87c>
      i -= 4;
      b2 += i;
      m2 += i;
      s2 += i;
    }
  else if (i < 4)
   137bc:	fcc68463          	beq	a3,a2,12f84 <_dtoa_r+0x8b4>
   137c0:	03c00693          	li	a3,60
   137c4:	40f687bb          	subw	a5,a3,a5
   137c8:	945ff06f          	j	1310c <_dtoa_r+0xa3c>

00000000000137cc <__sflush_r>:
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
   137cc:	01059683          	lh	a3,16(a1) # fffffffffcc00010 <_gp+0xfffffffffcbe4540>
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   137d0:	fd010113          	addi	sp,sp,-48
   137d4:	00913c23          	sd	s1,24(sp)
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   137d8:	03069713          	slli	a4,a3,0x30
   137dc:	03075713          	srli	a4,a4,0x30
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   137e0:	01313423          	sd	s3,8(sp)
   137e4:	02113423          	sd	ra,40(sp)
   137e8:	02813023          	sd	s0,32(sp)
   137ec:	01213823          	sd	s2,16(sp)
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   137f0:	00877793          	andi	a5,a4,8
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   137f4:	00058493          	mv	s1,a1
   137f8:	00050993          	mv	s3,a0
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   137fc:	0e079863          	bnez	a5,138ec <__sflush_r+0x120>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   13800:	000017b7          	lui	a5,0x1
   13804:	8007879b          	addiw	a5,a5,-2048
   13808:	00f6e7b3          	or	a5,a3,a5
   1380c:	0107979b          	slliw	a5,a5,0x10
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   13810:	0085a703          	lw	a4,8(a1)
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   13814:	4107d79b          	sraiw	a5,a5,0x10
   13818:	00f59823          	sh	a5,16(a1)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   1381c:	1ae05863          	blez	a4,139cc <__sflush_r+0x200>
   13820:	0484b703          	ld	a4,72(s1)
   13824:	0a070463          	beqz	a4,138cc <__sflush_r+0x100>
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
	  ptr->_errno = 0;
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   13828:	03079793          	slli	a5,a5,0x30
   1382c:	0307d793          	srli	a5,a5,0x30
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
   13830:	0009a403          	lw	s0,0(s3)
	  ptr->_errno = 0;
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   13834:	03379693          	slli	a3,a5,0x33

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
	  ptr->_errno = 0;
   13838:	0009a023          	sw	zero,0(s3)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   1383c:	1806de63          	bgez	a3,139d8 <__sflush_r+0x20c>
	    curoff = fp->_offset;
   13840:	0904b603          	ld	a2,144(s1)
		  else
		    fp->_flags |= __SERR;
		  return result;
		}
            }
          if (fp->_flags & __SRD)
   13844:	0047f793          	andi	a5,a5,4
   13848:	00078e63          	beqz	a5,13864 <__sflush_r+0x98>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   1384c:	0084a683          	lw	a3,8(s1)
              if (HASUB (fp))
   13850:	0584b783          	ld	a5,88(s1)
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   13854:	40d60633          	sub	a2,a2,a3
              if (HASUB (fp))
   13858:	00078663          	beqz	a5,13864 <__sflush_r+0x98>
                curoff -= fp->_ur;
   1385c:	0704a783          	lw	a5,112(s1)
   13860:	40f60633          	sub	a2,a2,a5
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
   13864:	0304b583          	ld	a1,48(s1)
   13868:	00000693          	li	a3,0
   1386c:	00098513          	mv	a0,s3
   13870:	000700e7          	jalr	a4
	  if (curoff != -1 || ptr->_errno == 0
   13874:	fff00793          	li	a5,-1
   13878:	0ef50c63          	beq	a0,a5,13970 <__sflush_r+0x1a4>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   1387c:	0104d683          	lhu	a3,16(s1)
   13880:	fffff7b7          	lui	a5,0xfffff
   13884:	7ff7879b          	addiw	a5,a5,2047
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   13888:	0184b703          	ld	a4,24(s1)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   1388c:	00f6f7b3          	and	a5,a3,a5
   13890:	0107979b          	slliw	a5,a5,0x10
   13894:	4107d79b          	sraiw	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   13898:	00e4b023          	sd	a4,0(s1)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   1389c:	00f49823          	sh	a5,16(s1)
#endif
	      fp->_r = 0;
   138a0:	0004a423          	sw	zero,8(s1)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   138a4:	03379713          	slli	a4,a5,0x33
   138a8:	10074e63          	bltz	a4,139c4 <__sflush_r+0x1f8>
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
   138ac:	0584b583          	ld	a1,88(s1)
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
   138b0:	0089a023          	sw	s0,0(s3)
	      if (HASUB (fp))
   138b4:	00058c63          	beqz	a1,138cc <__sflush_r+0x100>
		FREEUB (ptr, fp);
   138b8:	07448793          	addi	a5,s1,116
   138bc:	00f58663          	beq	a1,a5,138c8 <__sflush_r+0xfc>
   138c0:	00098513          	mv	a0,s3
   138c4:	678000ef          	jal	13f3c <_free_r>
   138c8:	0404bc23          	sd	zero,88(s1)
	    {
	      fp->_flags |= __SERR;
	      return EOF;
	    }
	}
      return 0;
   138cc:	00000513          	li	a0,0
	}
      p += t;
      n -= t;
    }
  return 0;
}
   138d0:	02813083          	ld	ra,40(sp)
   138d4:	02013403          	ld	s0,32(sp)
   138d8:	01813483          	ld	s1,24(sp)
   138dc:	01013903          	ld	s2,16(sp)
   138e0:	00813983          	ld	s3,8(sp)
   138e4:	03010113          	addi	sp,sp,48
   138e8:	00008067          	ret
	      return EOF;
	    }
	}
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
   138ec:	0185b903          	ld	s2,24(a1)
   138f0:	fc090ee3          	beqz	s2,138cc <__sflush_r+0x100>
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   138f4:	0005b403          	ld	s0,0(a1)
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   138f8:	00377713          	andi	a4,a4,3
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
   138fc:	0125b023          	sd	s2,0(a1)
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   13900:	4124043b          	subw	s0,s0,s2
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   13904:	00000793          	li	a5,0
   13908:	00071463          	bnez	a4,13910 <__sflush_r+0x144>
   1390c:	0205a783          	lw	a5,32(a1)
   13910:	00f4a623          	sw	a5,12(s1)

  while (n > 0)
   13914:	00804863          	bgtz	s0,13924 <__sflush_r+0x158>
   13918:	fb5ff06f          	j	138cc <__sflush_r+0x100>
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
   1391c:	00a90933          	add	s2,s2,a0
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
   13920:	fa8056e3          	blez	s0,138cc <__sflush_r+0x100>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
   13924:	0404b783          	ld	a5,64(s1)
   13928:	0304b583          	ld	a1,48(s1)
   1392c:	00040693          	mv	a3,s0
   13930:	00090613          	mv	a2,s2
   13934:	00098513          	mv	a0,s3
   13938:	000780e7          	jalr	a5
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
      n -= t;
   1393c:	40a4043b          	subw	s0,s0,a0
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
   13940:	fca04ee3          	bgtz	a0,1391c <__sflush_r+0x150>
	{
          fp->_flags |= __SERR;
   13944:	0104d783          	lhu	a5,16(s1)
	}
      p += t;
      n -= t;
    }
  return 0;
}
   13948:	02813083          	ld	ra,40(sp)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          return EOF;
   1394c:	fff00513          	li	a0,-1
  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
   13950:	0407e793          	ori	a5,a5,64
   13954:	00f49823          	sh	a5,16(s1)
	}
      p += t;
      n -= t;
    }
  return 0;
}
   13958:	02013403          	ld	s0,32(sp)
   1395c:	01813483          	ld	s1,24(sp)
   13960:	01013903          	ld	s2,16(sp)
   13964:	00813983          	ld	s3,8(sp)
   13968:	03010113          	addi	sp,sp,48
   1396c:	00008067          	ret
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
	  if (curoff != -1 || ptr->_errno == 0
   13970:	0009a703          	lw	a4,0(s3)
   13974:	01d00793          	li	a5,29
   13978:	fce7e6e3          	bltu	a5,a4,13944 <__sflush_r+0x178>
   1397c:	204007b7          	lui	a5,0x20400
   13980:	00178793          	addi	a5,a5,1 # 20400001 <_gp+0x203e4531>
   13984:	00e7d7b3          	srl	a5,a5,a4
   13988:	0017f793          	andi	a5,a5,1
   1398c:	fa078ce3          	beqz	a5,13944 <__sflush_r+0x178>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   13990:	0104d603          	lhu	a2,16(s1)
   13994:	fffff7b7          	lui	a5,0xfffff
   13998:	7ff7879b          	addiw	a5,a5,2047
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   1399c:	0184b683          	ld	a3,24(s1)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   139a0:	00f677b3          	and	a5,a2,a5
   139a4:	0107979b          	slliw	a5,a5,0x10
   139a8:	4107d79b          	sraiw	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   139ac:	00d4b023          	sd	a3,0(s1)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   139b0:	00f49823          	sh	a5,16(s1)
#endif
	      fp->_r = 0;
   139b4:	0004a423          	sw	zero,8(s1)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   139b8:	03379693          	slli	a3,a5,0x33
   139bc:	ee06d8e3          	bgez	a3,138ac <__sflush_r+0xe0>
   139c0:	ee0716e3          	bnez	a4,138ac <__sflush_r+0xe0>
		fp->_offset = curoff;
   139c4:	08a4b823          	sd	a0,144(s1)
   139c8:	ee5ff06f          	j	138ac <__sflush_r+0xe0>
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   139cc:	0705a703          	lw	a4,112(a1)
   139d0:	e4e048e3          	bgtz	a4,13820 <__sflush_r+0x54>
   139d4:	ef9ff06f          	j	138cc <__sflush_r+0x100>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   139d8:	0304b583          	ld	a1,48(s1)
   139dc:	00000613          	li	a2,0
   139e0:	00100693          	li	a3,1
   139e4:	00098513          	mv	a0,s3
   139e8:	000700e7          	jalr	a4
	      if (curoff == -1L && ptr->_errno != 0)
   139ec:	fff00793          	li	a5,-1
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   139f0:	00050613          	mv	a2,a0
	      if (curoff == -1L && ptr->_errno != 0)
   139f4:	00f50863          	beq	a0,a5,13a04 <__sflush_r+0x238>
   139f8:	0104d783          	lhu	a5,16(s1)
   139fc:	0484b703          	ld	a4,72(s1)
   13a00:	e45ff06f          	j	13844 <__sflush_r+0x78>
   13a04:	0009a783          	lw	a5,0(s3)
   13a08:	fe0788e3          	beqz	a5,139f8 <__sflush_r+0x22c>
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
   13a0c:	01d00713          	li	a4,29
   13a10:	00e78663          	beq	a5,a4,13a1c <__sflush_r+0x250>
   13a14:	01600713          	li	a4,22
   13a18:	00e79863          	bne	a5,a4,13a28 <__sflush_r+0x25c>
		    {
		      result = 0;
		      ptr->_errno = tmp_errno;
   13a1c:	0089a023          	sw	s0,0(s3)
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
		    {
		      result = 0;
   13a20:	00000513          	li	a0,0
		      ptr->_errno = tmp_errno;
   13a24:	eadff06f          	j	138d0 <__sflush_r+0x104>
		    }
		  else
		    fp->_flags |= __SERR;
   13a28:	0104d783          	lhu	a5,16(s1)
   13a2c:	0407e793          	ori	a5,a5,64
   13a30:	00f49823          	sh	a5,16(s1)
   13a34:	e9dff06f          	j	138d0 <__sflush_r+0x104>

0000000000013a38 <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   13a38:	fe010113          	addi	sp,sp,-32
   13a3c:	00813823          	sd	s0,16(sp)
   13a40:	00113c23          	sd	ra,24(sp)
   13a44:	00050413          	mv	s0,a0
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   13a48:	00050663          	beqz	a0,13a54 <_fflush_r+0x1c>
   13a4c:	05052783          	lw	a5,80(a0)
   13a50:	02078a63          	beqz	a5,13a84 <_fflush_r+0x4c>

  if (!fp->_flags)
   13a54:	01059783          	lh	a5,16(a1)
   13a58:	00079c63          	bnez	a5,13a70 <_fflush_r+0x38>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
  _newlib_flockfile_end (fp);
  return ret;
}
   13a5c:	01813083          	ld	ra,24(sp)
   13a60:	00000513          	li	a0,0
   13a64:	01013403          	ld	s0,16(sp)
   13a68:	02010113          	addi	sp,sp,32
   13a6c:	00008067          	ret

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   13a70:	00040513          	mv	a0,s0
  _newlib_flockfile_end (fp);
  return ret;
}
   13a74:	01813083          	ld	ra,24(sp)
   13a78:	01013403          	ld	s0,16(sp)
   13a7c:	02010113          	addi	sp,sp,32

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   13a80:	d4dff06f          	j	137cc <__sflush_r>
   13a84:	00b13423          	sd	a1,8(sp)
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   13a88:	35c000ef          	jal	13de4 <__sinit>
   13a8c:	00813583          	ld	a1,8(sp)
   13a90:	fc5ff06f          	j	13a54 <_fflush_r+0x1c>

0000000000013a94 <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
   13a94:	00050593          	mv	a1,a0
  if (fp == NULL)
   13a98:	00050663          	beqz	a0,13aa4 <fflush+0x10>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);

  return _fflush_r (_REENT, fp);
   13a9c:	8101b503          	ld	a0,-2032(gp) # 1b2e0 <_impure_ptr>
   13aa0:	f99ff06f          	j	13a38 <_fflush_r>
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  if (fp == NULL)
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
   13aa4:	8081b503          	ld	a0,-2040(gp) # 1b2d8 <_global_impure_ptr>
   13aa8:	000145b7          	lui	a1,0x14
   13aac:	a3858593          	addi	a1,a1,-1480 # 13a38 <_fflush_r>
   13ab0:	04d0006f          	j	142fc <_fwalk_reent>

0000000000013ab4 <__fp_unlock>:
       FILE * ptr)
{
  _funlockfile (ptr);

  return 0;
}
   13ab4:	00000513          	li	a0,0
   13ab8:	00008067          	ret

0000000000013abc <_cleanup_r>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   13abc:	000175b7          	lui	a1,0x17
   13ac0:	7dc58593          	addi	a1,a1,2012 # 177dc <_fclose_r>
   13ac4:	0390006f          	j	142fc <_fwalk_reent>

0000000000013ac8 <__sinit.part.1>:
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   13ac8:	fc010113          	addi	sp,sp,-64
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   13acc:	000147b7          	lui	a5,0x14
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   13ad0:	02113c23          	sd	ra,56(sp)
   13ad4:	02813823          	sd	s0,48(sp)
   13ad8:	02913423          	sd	s1,40(sp)
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
   13adc:	00853403          	ld	s0,8(a0)
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   13ae0:	03213023          	sd	s2,32(sp)
   13ae4:	01313c23          	sd	s3,24(sp)
   13ae8:	01413823          	sd	s4,16(sp)
   13aec:	01513423          	sd	s5,8(sp)
   13af0:	01613023          	sd	s6,0(sp)
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   13af4:	abc78793          	addi	a5,a5,-1348 # 13abc <_cleanup_r>
   13af8:	04f53c23          	sd	a5,88(a0)

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
  s->__sglue._iobs = &s->__sf[0];
   13afc:	53850713          	addi	a4,a0,1336
  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
   13b00:	00300793          	li	a5,3
  s->__sglue._iobs = &s->__sf[0];
   13b04:	52e53823          	sd	a4,1328(a0)
  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
   13b08:	52f52423          	sw	a5,1320(a0)
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
   13b0c:	52053023          	sd	zero,1312(a0)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   13b10:	00400793          	li	a5,4
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   13b14:	00050913          	mv	s2,a0
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   13b18:	00f41823          	sh	a5,16(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13b1c:	00800613          	li	a2,8
   13b20:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   13b24:	00043023          	sd	zero,0(s0)
  ptr->_r = 0;
   13b28:	00042423          	sw	zero,8(s0)
  ptr->_w = 0;
   13b2c:	00042623          	sw	zero,12(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   13b30:	0a042623          	sw	zero,172(s0)
  ptr->_file = file;
   13b34:	00041923          	sh	zero,18(s0)
  ptr->_bf._base = 0;
   13b38:	00043c23          	sd	zero,24(s0)
  ptr->_bf._size = 0;
   13b3c:	02042023          	sw	zero,32(s0)
  ptr->_lbfsize = 0;
   13b40:	02042423          	sw	zero,40(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13b44:	0a440513          	addi	a0,s0,164
   13b48:	460010ef          	jal	14fa8 <memset>
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   13b4c:	00016b37          	lui	s6,0x16
     requires both stdin and stdout to be line-buffered, but tradition
     leaves stdin alone on systems without fcntl.  */
#ifdef HAVE_FCNTL
  std (s->_stdout, __SWR, 1, s);
#else
  std (s->_stdout, __SWR | __SLBF, 1, s);
   13b50:	01093483          	ld	s1,16(s2)
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   13b54:	00016ab7          	lui	s5,0x16
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   13b58:	00016a37          	lui	s4,0x16
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   13b5c:	000169b7          	lui	s3,0x16
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   13b60:	168b0b13          	addi	s6,s6,360 # 16168 <__sread>
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   13b64:	1d4a8a93          	addi	s5,s5,468 # 161d4 <__swrite>
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   13b68:	244a0a13          	addi	s4,s4,580 # 16244 <__sseek>
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   13b6c:	2b098993          	addi	s3,s3,688 # 162b0 <__sclose>
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   13b70:	03643c23          	sd	s6,56(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   13b74:	05543023          	sd	s5,64(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   13b78:	05443423          	sd	s4,72(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   13b7c:	05343823          	sd	s3,80(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   13b80:	02843823          	sd	s0,48(s0)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   13b84:	00900793          	li	a5,9
   13b88:	00f49823          	sh	a5,16(s1)
  ptr->_flags2 = 0;
  ptr->_file = file;
   13b8c:	00100793          	li	a5,1
   13b90:	00f49923          	sh	a5,18(s1)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13b94:	00800613          	li	a2,8
   13b98:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   13b9c:	0004b023          	sd	zero,0(s1)
  ptr->_r = 0;
   13ba0:	0004a423          	sw	zero,8(s1)
  ptr->_w = 0;
   13ba4:	0004a623          	sw	zero,12(s1)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   13ba8:	0a04a623          	sw	zero,172(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
   13bac:	0004bc23          	sd	zero,24(s1)
  ptr->_bf._size = 0;
   13bb0:	0204a023          	sw	zero,32(s1)
  ptr->_lbfsize = 0;
   13bb4:	0204a423          	sw	zero,40(s1)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13bb8:	0a448513          	addi	a0,s1,164
   13bbc:	3ec010ef          	jal	14fa8 <memset>
  std (s->_stdout, __SWR | __SLBF, 1, s);
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
   13bc0:	01893403          	ld	s0,24(s2)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   13bc4:	01200793          	li	a5,18
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   13bc8:	0364bc23          	sd	s6,56(s1)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   13bcc:	0554b023          	sd	s5,64(s1)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   13bd0:	0544b423          	sd	s4,72(s1)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   13bd4:	0534b823          	sd	s3,80(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   13bd8:	0294b823          	sd	s1,48(s1)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   13bdc:	00f41823          	sh	a5,16(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
   13be0:	00200793          	li	a5,2
   13be4:	00f41923          	sh	a5,18(s0)
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   13be8:	00043023          	sd	zero,0(s0)
  ptr->_r = 0;
   13bec:	00042423          	sw	zero,8(s0)
  ptr->_w = 0;
   13bf0:	00042623          	sw	zero,12(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   13bf4:	0a042623          	sw	zero,172(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
   13bf8:	00043c23          	sd	zero,24(s0)
  ptr->_bf._size = 0;
   13bfc:	02042023          	sw	zero,32(s0)
  ptr->_lbfsize = 0;
   13c00:	02042423          	sw	zero,40(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13c04:	0a440513          	addi	a0,s0,164
   13c08:	00800613          	li	a2,8
   13c0c:	00000593          	li	a1,0
   13c10:	398010ef          	jal	14fa8 <memset>
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;

  __sinit_lock_release ();
}
   13c14:	03813083          	ld	ra,56(sp)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   13c18:	03643c23          	sd	s6,56(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   13c1c:	05543023          	sd	s5,64(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   13c20:	05443423          	sd	s4,72(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   13c24:	05343823          	sd	s3,80(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   13c28:	02843823          	sd	s0,48(s0)

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;
   13c2c:	00100793          	li	a5,1
   13c30:	04f92823          	sw	a5,80(s2)

  __sinit_lock_release ();
}
   13c34:	03013403          	ld	s0,48(sp)
   13c38:	02813483          	ld	s1,40(sp)
   13c3c:	02013903          	ld	s2,32(sp)
   13c40:	01813983          	ld	s3,24(sp)
   13c44:	01013a03          	ld	s4,16(sp)
   13c48:	00813a83          	ld	s5,8(sp)
   13c4c:	00013b03          	ld	s6,0(sp)
   13c50:	04010113          	addi	sp,sp,64
   13c54:	00008067          	ret

0000000000013c58 <__fp_lock>:
   13c58:	00000513          	li	a0,0
   13c5c:	00008067          	ret

0000000000013c60 <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   13c60:	fe010113          	addi	sp,sp,-32
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   13c64:	fff5879b          	addiw	a5,a1,-1

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   13c68:	00913423          	sd	s1,8(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   13c6c:	0b000493          	li	s1,176
   13c70:	029784b3          	mul	s1,a5,s1

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   13c74:	01213023          	sd	s2,0(sp)
   13c78:	00058913          	mv	s2,a1
   13c7c:	00813823          	sd	s0,16(sp)
   13c80:	00113c23          	sd	ra,24(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   13c84:	0c848593          	addi	a1,s1,200
   13c88:	1a9000ef          	jal	14630 <_malloc_r>
   13c8c:	00050413          	mv	s0,a0
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
   13c90:	02050063          	beqz	a0,13cb0 <__sfmoreglue+0x50>
    return NULL;
  g->glue._next = NULL;
  g->glue._niobs = n;
  g->glue._iobs = &g->file;
   13c94:	01850513          	addi	a0,a0,24

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
    return NULL;
  g->glue._next = NULL;
   13c98:	00043023          	sd	zero,0(s0)
  g->glue._niobs = n;
   13c9c:	01242423          	sw	s2,8(s0)
  g->glue._iobs = &g->file;
   13ca0:	00a43823          	sd	a0,16(s0)
  memset (&g->file, 0, n * sizeof (FILE));
   13ca4:	0b048613          	addi	a2,s1,176
   13ca8:	00000593          	li	a1,0
   13cac:	2fc010ef          	jal	14fa8 <memset>
  return &g->glue;
}
   13cb0:	01813083          	ld	ra,24(sp)
   13cb4:	00040513          	mv	a0,s0
   13cb8:	00813483          	ld	s1,8(sp)
   13cbc:	01013403          	ld	s0,16(sp)
   13cc0:	00013903          	ld	s2,0(sp)
   13cc4:	02010113          	addi	sp,sp,32
   13cc8:	00008067          	ret

0000000000013ccc <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   13ccc:	fd010113          	addi	sp,sp,-48
   13cd0:	01213823          	sd	s2,16(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   13cd4:	8081b903          	ld	s2,-2040(gp) # 1b2d8 <_global_impure_ptr>
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   13cd8:	01313423          	sd	s3,8(sp)
   13cdc:	02113423          	sd	ra,40(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   13ce0:	05092783          	lw	a5,80(s2)
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   13ce4:	02813023          	sd	s0,32(sp)
   13ce8:	00913c23          	sd	s1,24(sp)
   13cec:	00050993          	mv	s3,a0
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   13cf0:	00079663          	bnez	a5,13cfc <__sfp+0x30>
   13cf4:	00090513          	mv	a0,s2
   13cf8:	dd1ff0ef          	jal	13ac8 <__sinit.part.1>
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
   13cfc:	52090913          	addi	s2,s2,1312
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13d00:	fff00493          	li	s1,-1
   13d04:	00892783          	lw	a5,8(s2)
   13d08:	01093403          	ld	s0,16(s2)
   13d0c:	fff7879b          	addiw	a5,a5,-1
   13d10:	0007da63          	bgez	a5,13d24 <__sfp+0x58>
   13d14:	0840006f          	j	13d98 <__sfp+0xcc>
   13d18:	fff7879b          	addiw	a5,a5,-1
   13d1c:	0b040413          	addi	s0,s0,176
   13d20:	06978c63          	beq	a5,s1,13d98 <__sfp+0xcc>
	if (fp->_flags == 0)
   13d24:	01041703          	lh	a4,16(s0)
   13d28:	fe0718e3          	bnez	a4,13d18 <__sfp+0x4c>
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
   13d2c:	fff00793          	li	a5,-1
   13d30:	00f41923          	sh	a5,18(s0)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
   13d34:	00100793          	li	a5,1
   13d38:	00f41823          	sh	a5,16(s0)
  fp->_flags2 = 0;
   13d3c:	0a042623          	sw	zero,172(s0)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();

  fp->_p = NULL;		/* no current pointer */
   13d40:	00043023          	sd	zero,0(s0)
  fp->_w = 0;			/* nothing to read or write */
   13d44:	00042623          	sw	zero,12(s0)
  fp->_r = 0;
   13d48:	00042423          	sw	zero,8(s0)
  fp->_bf._base = NULL;		/* no buffer */
   13d4c:	00043c23          	sd	zero,24(s0)
  fp->_bf._size = 0;
   13d50:	02042023          	sw	zero,32(s0)
  fp->_lbfsize = 0;		/* not line buffered */
   13d54:	02042423          	sw	zero,40(s0)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   13d58:	00800613          	li	a2,8
   13d5c:	00000593          	li	a1,0
   13d60:	0a440513          	addi	a0,s0,164
   13d64:	244010ef          	jal	14fa8 <memset>
  fp->_ub._base = NULL;		/* no ungetc buffer */
  fp->_ub._size = 0;
  fp->_lb._base = NULL;		/* no line buffer */
  fp->_lb._size = 0;

  return fp;
   13d68:	00040513          	mv	a0,s0
  fp->_bf._base = NULL;		/* no buffer */
  fp->_bf._size = 0;
  fp->_lbfsize = 0;		/* not line buffered */
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
   13d6c:	04043c23          	sd	zero,88(s0)
  fp->_ub._size = 0;
   13d70:	06042023          	sw	zero,96(s0)
  fp->_lb._base = NULL;		/* no line buffer */
   13d74:	06043c23          	sd	zero,120(s0)
  fp->_lb._size = 0;
   13d78:	08042023          	sw	zero,128(s0)

  return fp;
}
   13d7c:	02813083          	ld	ra,40(sp)
   13d80:	02013403          	ld	s0,32(sp)
   13d84:	01813483          	ld	s1,24(sp)
   13d88:	01013903          	ld	s2,16(sp)
   13d8c:	00813983          	ld	s3,8(sp)
   13d90:	03010113          	addi	sp,sp,48
   13d94:	00008067          	ret
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   13d98:	00093783          	ld	a5,0(s2)
   13d9c:	00078663          	beqz	a5,13da8 <__sfp+0xdc>
   13da0:	00078913          	mv	s2,a5
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
   13da4:	f61ff06f          	j	13d04 <__sfp+0x38>
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
   13da8:	00400593          	li	a1,4
   13dac:	00098513          	mv	a0,s3
   13db0:	eb1ff0ef          	jal	13c60 <__sfmoreglue>
   13db4:	00a93023          	sd	a0,0(s2)
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   13db8:	00050663          	beqz	a0,13dc4 <__sfp+0xf8>
   13dbc:	00050913          	mv	s2,a0
   13dc0:	f45ff06f          	j	13d04 <__sfp+0x38>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
   13dc4:	00c00793          	li	a5,12
   13dc8:	00f9a023          	sw	a5,0(s3)
  return NULL;
   13dcc:	00000513          	li	a0,0
   13dd0:	fadff06f          	j	13d7c <__sfp+0xb0>

0000000000013dd4 <_cleanup>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   13dd4:	8081b503          	ld	a0,-2040(gp) # 1b2d8 <_global_impure_ptr>
   13dd8:	000175b7          	lui	a1,0x17
   13ddc:	7dc58593          	addi	a1,a1,2012 # 177dc <_fclose_r>
   13de0:	51c0006f          	j	142fc <_fwalk_reent>

0000000000013de4 <__sinit>:
_DEFUN(__sinit, (s),
       struct _reent *s)
{
  __sinit_lock_acquire ();

  if (s->__sdidinit)
   13de4:	05052783          	lw	a5,80(a0)
   13de8:	00078463          	beqz	a5,13df0 <__sinit+0xc>
   13dec:	00008067          	ret
   13df0:	cd9ff06f          	j	13ac8 <__sinit.part.1>

0000000000013df4 <__sfp_lock_acquire>:
   13df4:	00008067          	ret

0000000000013df8 <__sfp_lock_release>:
   13df8:	00008067          	ret

0000000000013dfc <__sinit_lock_acquire>:
   13dfc:	00008067          	ret

0000000000013e00 <__sinit_lock_release>:
  __lock_acquire_recursive (__sinit_lock);
}

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
   13e00:	00008067          	ret

0000000000013e04 <__fp_lock_all>:
_VOID
_DEFUN_VOID(__fp_lock_all)
{
  __sfp_lock_acquire ();

  _CAST_VOID _fwalk (_REENT, __fp_lock);
   13e04:	8101b503          	ld	a0,-2032(gp) # 1b2e0 <_impure_ptr>
   13e08:	000145b7          	lui	a1,0x14
   13e0c:	c5858593          	addi	a1,a1,-936 # 13c58 <__fp_lock>
   13e10:	43c0006f          	j	1424c <_fwalk>

0000000000013e14 <__fp_unlock_all>:
}

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
   13e14:	8101b503          	ld	a0,-2032(gp) # 1b2e0 <_impure_ptr>
   13e18:	000145b7          	lui	a1,0x14
   13e1c:	ab458593          	addi	a1,a1,-1356 # 13ab4 <__fp_unlock>
   13e20:	42c0006f          	j	1424c <_fwalk>

0000000000013e24 <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   13e24:	fd010113          	addi	sp,sp,-48
   13e28:	01213823          	sd	s2,16(sp)

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   13e2c:	0001b937          	lui	s2,0x1b
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   13e30:	02813023          	sd	s0,32(sp)
   13e34:	00913c23          	sd	s1,24(sp)
   13e38:	00058413          	mv	s0,a1
   13e3c:	01313423          	sd	s3,8(sp)
   13e40:	02113423          	sd	ra,40(sp)
   13e44:	00050993          	mv	s3,a0

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   13e48:	ab890913          	addi	s2,s2,-1352 # 1aab8 <__malloc_av_>
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;
   13e4c:	238010ef          	jal	15084 <__malloc_lock>

  top_size = chunksize(top);
   13e50:	01093703          	ld	a4,16(s2)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   13e54:	000017b7          	lui	a5,0x1
   13e58:	fdf78593          	addi	a1,a5,-33 # fdf <_ftext-0xf021>

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   13e5c:	00873483          	ld	s1,8(a4)
   13e60:	ffc4f493          	andi	s1,s1,-4
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   13e64:	40848433          	sub	s0,s1,s0
   13e68:	00b40433          	add	s0,s0,a1
   13e6c:	00c45413          	srli	s0,s0,0xc
   13e70:	fff40413          	addi	s0,s0,-1
   13e74:	00c41413          	slli	s0,s0,0xc

  if (extra < (long)pagesz)  /* Not enough memory to release */
   13e78:	00f44c63          	blt	s0,a5,13e90 <_malloc_trim_r+0x6c>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
   13e7c:	00000513          	li	a0,0
   13e80:	6c5040ef          	jal	18d44 <sbrk>
    if (current_brk != (char*)(top) + top_size)
   13e84:	01093783          	ld	a5,16(s2)
   13e88:	009787b3          	add	a5,a5,s1
   13e8c:	02f50663          	beq	a0,a5,13eb8 <_malloc_trim_r+0x94>
  top_size = chunksize(top);
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;

  if (extra < (long)pagesz)  /* Not enough memory to release */
  {
    MALLOC_UNLOCK;
   13e90:	00098513          	mv	a0,s3
   13e94:	1f4010ef          	jal	15088 <__malloc_unlock>
	MALLOC_UNLOCK;
        return 1;
      }
    }
  }
}
   13e98:	02813083          	ld	ra,40(sp)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;

  if (extra < (long)pagesz)  /* Not enough memory to release */
  {
    MALLOC_UNLOCK;
    return 0;
   13e9c:	00000513          	li	a0,0
	MALLOC_UNLOCK;
        return 1;
      }
    }
  }
}
   13ea0:	02013403          	ld	s0,32(sp)
   13ea4:	01813483          	ld	s1,24(sp)
   13ea8:	01013903          	ld	s2,16(sp)
   13eac:	00813983          	ld	s3,8(sp)
   13eb0:	03010113          	addi	sp,sp,48
   13eb4:	00008067          	ret
      return 0;     /* Apparently we don't own memory; must fail */
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
   13eb8:	40800533          	neg	a0,s0
   13ebc:	689040ef          	jal	18d44 <sbrk>
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
   13ec0:	fff00793          	li	a5,-1
   13ec4:	04f50463          	beq	a0,a5,13f0c <_malloc_trim_r+0xe8>

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
        sbrked_mem -= extra;
   13ec8:	9001a783          	lw	a5,-1792(gp) # 1b3d0 <__malloc_current_mallinfo>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   13ecc:	01093683          	ld	a3,16(s2)
   13ed0:	408484b3          	sub	s1,s1,s0
   13ed4:	0014e493          	ori	s1,s1,1
        sbrked_mem -= extra;
   13ed8:	4087843b          	subw	s0,a5,s0
        check_chunk(top);
	MALLOC_UNLOCK;
   13edc:	00098513          	mv	a0,s3
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   13ee0:	0096b423          	sd	s1,8(a3)
        sbrked_mem -= extra;
   13ee4:	9081a023          	sw	s0,-1792(gp) # 1b3d0 <__malloc_current_mallinfo>
        check_chunk(top);
	MALLOC_UNLOCK;
   13ee8:	1a0010ef          	jal	15088 <__malloc_unlock>
        return 1;
      }
    }
  }
}
   13eec:	02813083          	ld	ra,40(sp)
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
        sbrked_mem -= extra;
        check_chunk(top);
	MALLOC_UNLOCK;
        return 1;
   13ef0:	00100513          	li	a0,1
      }
    }
  }
}
   13ef4:	02013403          	ld	s0,32(sp)
   13ef8:	01813483          	ld	s1,24(sp)
   13efc:	01013903          	ld	s2,16(sp)
   13f00:	00813983          	ld	s3,8(sp)
   13f04:	03010113          	addi	sp,sp,48
   13f08:	00008067          	ret
      new_brk = (char*)(MORECORE (-extra));
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
   13f0c:	00000513          	li	a0,0
   13f10:	635040ef          	jal	18d44 <sbrk>
        top_size = current_brk - (char*)top;
   13f14:	01093703          	ld	a4,16(s2)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   13f18:	01f00693          	li	a3,31
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
   13f1c:	40e507b3          	sub	a5,a0,a4
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   13f20:	f6f6d8e3          	ble	a5,a3,13e90 <_malloc_trim_r+0x6c>
        {
          sbrked_mem = current_brk - sbrk_base;
   13f24:	8201b683          	ld	a3,-2016(gp) # 1b2f0 <__malloc_sbrk_base>
          set_head(top, top_size | PREV_INUSE);
   13f28:	0017e793          	ori	a5,a5,1
   13f2c:	00f73423          	sd	a5,8(a4)
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
        {
          sbrked_mem = current_brk - sbrk_base;
   13f30:	40d50533          	sub	a0,a0,a3
   13f34:	90a1a023          	sw	a0,-1792(gp) # 1b3d0 <__malloc_current_mallinfo>
   13f38:	f59ff06f          	j	13e90 <_malloc_trim_r+0x6c>

0000000000013f3c <_free_r>:
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
   13f3c:	10058263          	beqz	a1,14040 <_free_r+0x104>
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
   13f40:	fe010113          	addi	sp,sp,-32
   13f44:	00813823          	sd	s0,16(sp)
   13f48:	00913423          	sd	s1,8(sp)
   13f4c:	00058413          	mv	s0,a1
   13f50:	00050493          	mv	s1,a0
   13f54:	00113c23          	sd	ra,24(sp)
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;
   13f58:	12c010ef          	jal	15084 <__malloc_lock>

  p = mem2chunk(mem);
  hd = p->size;
   13f5c:	ff843503          	ld	a0,-8(s0)
  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;

  p = mem2chunk(mem);
   13f60:	ff040693          	addi	a3,s0,-16
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   13f64:	0001b5b7          	lui	a1,0x1b
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
   13f68:	ffe57793          	andi	a5,a0,-2
  next = chunk_at_offset(p, sz);
   13f6c:	00f68633          	add	a2,a3,a5
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   13f70:	ab858593          	addi	a1,a1,-1352 # 1aab8 <__malloc_av_>
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   13f74:	00863703          	ld	a4,8(a2)
  
  if (next == top)                            /* merge with top */
   13f78:	0105b803          	ld	a6,16(a1)
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   13f7c:	ffc77713          	andi	a4,a4,-4
  
  if (next == top)                            /* merge with top */
   13f80:	17060663          	beq	a2,a6,140ec <_free_r+0x1b0>
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
   13f84:	00e63423          	sd	a4,8(a2)

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
   13f88:	00157513          	andi	a0,a0,1
   13f8c:	02051663          	bnez	a0,13fb8 <_free_r+0x7c>
  {
    prevsz = p->prev_size;
   13f90:	ff043503          	ld	a0,-16(s0)
    p = chunk_at_offset(p, -prevsz);
   13f94:	40a686b3          	sub	a3,a3,a0
    sz += prevsz;
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   13f98:	0106b803          	ld	a6,16(a3)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -prevsz);
    sz += prevsz;
   13f9c:	00a787b3          	add	a5,a5,a0
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   13fa0:	0001b537          	lui	a0,0x1b
   13fa4:	ac850513          	addi	a0,a0,-1336 # 1aac8 <__malloc_av_+0x10>
   13fa8:	18a80863          	beq	a6,a0,14138 <_free_r+0x1fc>
      islr = 1;
    else
      unlink(p, bck, fwd);
   13fac:	0186b503          	ld	a0,24(a3)
   13fb0:	00a83c23          	sd	a0,24(a6)
   13fb4:	01053823          	sd	a6,16(a0)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   13fb8:	00e60533          	add	a0,a2,a4
   13fbc:	00853503          	ld	a0,8(a0)
   13fc0:	00157513          	andi	a0,a0,1
   13fc4:	0e050a63          	beqz	a0,140b8 <_free_r+0x17c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13fc8:	0017e713          	ori	a4,a5,1
   13fcc:	00e6b423          	sd	a4,8(a3)
  set_foot(p, sz);
   13fd0:	00f68733          	add	a4,a3,a5
   13fd4:	00f73023          	sd	a5,0(a4)
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   13fd8:	1ff00713          	li	a4,511
   13fdc:	06f76463          	bltu	a4,a5,14044 <_free_r+0x108>
   13fe0:	0037d793          	srli	a5,a5,0x3
   13fe4:	0007879b          	sext.w	a5,a5
   13fe8:	0017871b          	addiw	a4,a5,1
   13fec:	0017171b          	slliw	a4,a4,0x1
   13ff0:	00371713          	slli	a4,a4,0x3
   13ff4:	0085b603          	ld	a2,8(a1)
   13ff8:	00e58733          	add	a4,a1,a4
   13ffc:	00073803          	ld	a6,0(a4)
   14000:	4027d79b          	sraiw	a5,a5,0x2
   14004:	00100513          	li	a0,1
   14008:	00f517b3          	sll	a5,a0,a5
   1400c:	00c7e7b3          	or	a5,a5,a2
   14010:	ff070613          	addi	a2,a4,-16
   14014:	00c6bc23          	sd	a2,24(a3)
   14018:	0106b823          	sd	a6,16(a3)
   1401c:	00f5b423          	sd	a5,8(a1)
   14020:	00d73023          	sd	a3,0(a4)
   14024:	00d83c23          	sd	a3,24(a6)

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   14028:	00048513          	mv	a0,s1
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
   1402c:	01813083          	ld	ra,24(sp)
   14030:	01013403          	ld	s0,16(sp)
   14034:	00813483          	ld	s1,8(sp)
   14038:	02010113          	addi	sp,sp,32

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   1403c:	04c0106f          	j	15088 <__malloc_unlock>
   14040:	00008067          	ret


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   14044:	0097d713          	srli	a4,a5,0x9
   14048:	00400613          	li	a2,4
   1404c:	12e66263          	bltu	a2,a4,14170 <_free_r+0x234>
   14050:	0067d713          	srli	a4,a5,0x6
   14054:	0007071b          	sext.w	a4,a4
   14058:	0397051b          	addiw	a0,a4,57
   1405c:	0387061b          	addiw	a2,a4,56
   14060:	0015151b          	slliw	a0,a0,0x1
   14064:	00351513          	slli	a0,a0,0x3
   14068:	00a58533          	add	a0,a1,a0
   1406c:	00053703          	ld	a4,0(a0)
   14070:	ff050513          	addi	a0,a0,-16
   14074:	10e50c63          	beq	a0,a4,1418c <_free_r+0x250>
   14078:	00873603          	ld	a2,8(a4)
   1407c:	ffc67613          	andi	a2,a2,-4
   14080:	00c7f663          	bleu	a2,a5,1408c <_free_r+0x150>
   14084:	01073703          	ld	a4,16(a4)
   14088:	fee518e3          	bne	a0,a4,14078 <_free_r+0x13c>
   1408c:	01873503          	ld	a0,24(a4)
   14090:	00a6bc23          	sd	a0,24(a3)
   14094:	00e6b823          	sd	a4,16(a3)
   14098:	00d53823          	sd	a3,16(a0)

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
   1409c:	01813083          	ld	ra,24(sp)

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   140a0:	00048513          	mv	a0,s1
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
   140a4:	01013403          	ld	s0,16(sp)
   140a8:	00813483          	ld	s1,8(sp)


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   140ac:	00d73c23          	sd	a3,24(a4)

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
   140b0:	02010113          	addi	sp,sp,32

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   140b4:	7d50006f          	j	15088 <__malloc_unlock>
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   140b8:	01063503          	ld	a0,16(a2)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   140bc:	00e787b3          	add	a5,a5,a4
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   140c0:	0001b737          	lui	a4,0x1b
   140c4:	ac870713          	addi	a4,a4,-1336 # 1aac8 <__malloc_av_+0x10>
   140c8:	0ee50263          	beq	a0,a4,141ac <_free_r+0x270>
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   140cc:	01863803          	ld	a6,24(a2)
  }


  set_head(p, sz | PREV_INUSE);
   140d0:	0017e613          	ori	a2,a5,1
  set_foot(p, sz);
   140d4:	00f68733          	add	a4,a3,a5
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   140d8:	01053c23          	sd	a6,24(a0)
   140dc:	00a83823          	sd	a0,16(a6)
  }


  set_head(p, sz | PREV_INUSE);
   140e0:	00c6b423          	sd	a2,8(a3)
  set_foot(p, sz);
   140e4:	00f73023          	sd	a5,0(a4)
   140e8:	ef1ff06f          	j	13fd8 <_free_r+0x9c>
  
  if (next == top)                            /* merge with top */
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   140ec:	00157513          	andi	a0,a0,1
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
   140f0:	00e787b3          	add	a5,a5,a4

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   140f4:	02051063          	bnez	a0,14114 <_free_r+0x1d8>
    {
      prevsz = p->prev_size;
   140f8:	ff043503          	ld	a0,-16(s0)
      p = chunk_at_offset(p, -prevsz);
   140fc:	40a686b3          	sub	a3,a3,a0
      sz += prevsz;
      unlink(p, bck, fwd);
   14100:	0186b703          	ld	a4,24(a3)
   14104:	0106b603          	ld	a2,16(a3)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
   14108:	00a787b3          	add	a5,a5,a0
      unlink(p, bck, fwd);
   1410c:	00e63c23          	sd	a4,24(a2)
   14110:	00c73823          	sd	a2,16(a4)
    }

    set_head(p, sz | PREV_INUSE);
   14114:	0017e613          	ori	a2,a5,1
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   14118:	8281b703          	ld	a4,-2008(gp) # 1b2f8 <__malloc_trim_threshold>
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
      unlink(p, bck, fwd);
    }

    set_head(p, sz | PREV_INUSE);
   1411c:	00c6b423          	sd	a2,8(a3)
    top = p;
   14120:	00d5b823          	sd	a3,16(a1)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   14124:	f0e7e2e3          	bltu	a5,a4,14028 <_free_r+0xec>
      malloc_trim(RCALL top_pad); 
   14128:	8b81b583          	ld	a1,-1864(gp) # 1b388 <__malloc_top_pad>
   1412c:	00048513          	mv	a0,s1
   14130:	cf5ff0ef          	jal	13e24 <_malloc_trim_r>
   14134:	ef5ff06f          	j	14028 <_free_r+0xec>
      islr = 1;
    else
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   14138:	00e605b3          	add	a1,a2,a4
   1413c:	0085b583          	ld	a1,8(a1)
   14140:	0015f593          	andi	a1,a1,1
   14144:	0e059a63          	bnez	a1,14238 <_free_r+0x2fc>
   14148:	01063583          	ld	a1,16(a2)
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   1414c:	01863603          	ld	a2,24(a2)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   14150:	00f707b3          	add	a5,a4,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   14154:	0017e713          	ori	a4,a5,1
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   14158:	00c5bc23          	sd	a2,24(a1)
   1415c:	00b63823          	sd	a1,16(a2)
  }


  set_head(p, sz | PREV_INUSE);
   14160:	00e6b423          	sd	a4,8(a3)
  set_foot(p, sz);
   14164:	00f686b3          	add	a3,a3,a5
   14168:	00f6b023          	sd	a5,0(a3)
   1416c:	ebdff06f          	j	14028 <_free_r+0xec>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   14170:	01400613          	li	a2,20
   14174:	04e66e63          	bltu	a2,a4,141d0 <_free_r+0x294>
   14178:	0007071b          	sext.w	a4,a4
   1417c:	05c7051b          	addiw	a0,a4,92
   14180:	05b7061b          	addiw	a2,a4,91
   14184:	0015151b          	slliw	a0,a0,0x1
   14188:	eddff06f          	j	14064 <_free_r+0x128>
   1418c:	0085b783          	ld	a5,8(a1)
   14190:	4026571b          	sraiw	a4,a2,0x2
   14194:	00100613          	li	a2,1
   14198:	00e61733          	sll	a4,a2,a4
   1419c:	00f767b3          	or	a5,a4,a5
   141a0:	00f5b423          	sd	a5,8(a1)
   141a4:	00050713          	mv	a4,a0
   141a8:	ee9ff06f          	j	14090 <_free_r+0x154>
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
      link_last_remainder(p);   
   141ac:	02d5b423          	sd	a3,40(a1)
   141b0:	02d5b023          	sd	a3,32(a1)
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   141b4:	0017e713          	ori	a4,a5,1
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
      link_last_remainder(p);   
   141b8:	00a6bc23          	sd	a0,24(a3)
   141bc:	00a6b823          	sd	a0,16(a3)
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   141c0:	00e6b423          	sd	a4,8(a3)
  set_foot(p, sz);
   141c4:	00f686b3          	add	a3,a3,a5
   141c8:	00f6b023          	sd	a5,0(a3)
   141cc:	e5dff06f          	j	14028 <_free_r+0xec>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   141d0:	05400613          	li	a2,84
   141d4:	00e66e63          	bltu	a2,a4,141f0 <_free_r+0x2b4>
   141d8:	00c7d713          	srli	a4,a5,0xc
   141dc:	0007071b          	sext.w	a4,a4
   141e0:	06f7051b          	addiw	a0,a4,111
   141e4:	06e7061b          	addiw	a2,a4,110
   141e8:	0015151b          	slliw	a0,a0,0x1
   141ec:	e79ff06f          	j	14064 <_free_r+0x128>
   141f0:	15400613          	li	a2,340
   141f4:	00e66e63          	bltu	a2,a4,14210 <_free_r+0x2d4>
   141f8:	00f7d713          	srli	a4,a5,0xf
   141fc:	0007071b          	sext.w	a4,a4
   14200:	0787051b          	addiw	a0,a4,120
   14204:	0777061b          	addiw	a2,a4,119
   14208:	0015151b          	slliw	a0,a0,0x1
   1420c:	e59ff06f          	j	14064 <_free_r+0x128>
   14210:	55400813          	li	a6,1364
   14214:	0fe00513          	li	a0,254
   14218:	07e00613          	li	a2,126
   1421c:	e4e864e3          	bltu	a6,a4,14064 <_free_r+0x128>
   14220:	0127d713          	srli	a4,a5,0x12
   14224:	0007071b          	sext.w	a4,a4
   14228:	07d7051b          	addiw	a0,a4,125
   1422c:	07c7061b          	addiw	a2,a4,124
   14230:	0015151b          	slliw	a0,a0,0x1
   14234:	e31ff06f          	j	14064 <_free_r+0x128>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   14238:	0017e713          	ori	a4,a5,1
   1423c:	00e6b423          	sd	a4,8(a3)
  set_foot(p, sz);
   14240:	00f686b3          	add	a3,a3,a5
   14244:	00f6b023          	sd	a5,0(a3)
   14248:	de1ff06f          	j	14028 <_free_r+0xec>

000000000001424c <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   1424c:	fc010113          	addi	sp,sp,-64
   14250:	01513423          	sd	s5,8(sp)
   14254:	02113c23          	sd	ra,56(sp)
   14258:	02813823          	sd	s0,48(sp)
   1425c:	02913423          	sd	s1,40(sp)
   14260:	03213023          	sd	s2,32(sp)
   14264:	01313c23          	sd	s3,24(sp)
   14268:	01413823          	sd	s4,16(sp)
   1426c:	01613023          	sd	s6,0(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   14270:	52050a93          	addi	s5,a0,1312
   14274:	080a8063          	beqz	s5,142f4 <_fwalk+0xa8>
   14278:	00058b13          	mv	s6,a1
   1427c:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   14280:	00100993          	li	s3,1
   14284:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   14288:	008aa483          	lw	s1,8(s5)
   1428c:	010ab403          	ld	s0,16(s5)
   14290:	fff4849b          	addiw	s1,s1,-1
   14294:	0204c663          	bltz	s1,142c0 <_fwalk+0x74>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   14298:	01045783          	lhu	a5,16(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   1429c:	fff4849b          	addiw	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   142a0:	00f9fc63          	bleu	a5,s3,142b8 <_fwalk+0x6c>
   142a4:	01241783          	lh	a5,18(s0)
	ret |= (*function) (fp);
   142a8:	00040513          	mv	a0,s0
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   142ac:	01278663          	beq	a5,s2,142b8 <_fwalk+0x6c>
	ret |= (*function) (fp);
   142b0:	000b00e7          	jalr	s6
   142b4:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   142b8:	0b040413          	addi	s0,s0,176
   142bc:	fd249ee3          	bne	s1,s2,14298 <_fwalk+0x4c>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   142c0:	000aba83          	ld	s5,0(s5)
   142c4:	fc0a92e3          	bnez	s5,14288 <_fwalk+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
}
   142c8:	03813083          	ld	ra,56(sp)
   142cc:	000a0513          	mv	a0,s4
   142d0:	03013403          	ld	s0,48(sp)
   142d4:	02813483          	ld	s1,40(sp)
   142d8:	02013903          	ld	s2,32(sp)
   142dc:	01813983          	ld	s3,24(sp)
   142e0:	01013a03          	ld	s4,16(sp)
   142e4:	00813a83          	ld	s5,8(sp)
   142e8:	00013b03          	ld	s6,0(sp)
   142ec:	04010113          	addi	sp,sp,64
   142f0:	00008067          	ret
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   142f4:	00000a13          	li	s4,0
   142f8:	fd1ff06f          	j	142c8 <_fwalk+0x7c>

00000000000142fc <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   142fc:	fb010113          	addi	sp,sp,-80
   14300:	01613823          	sd	s6,16(sp)
   14304:	04113423          	sd	ra,72(sp)
   14308:	04813023          	sd	s0,64(sp)
   1430c:	02913c23          	sd	s1,56(sp)
   14310:	03213823          	sd	s2,48(sp)
   14314:	03313423          	sd	s3,40(sp)
   14318:	03413023          	sd	s4,32(sp)
   1431c:	01513c23          	sd	s5,24(sp)
   14320:	01713423          	sd	s7,8(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   14324:	52050b13          	addi	s6,a0,1312
   14328:	080b0663          	beqz	s6,143b4 <_fwalk_reent+0xb8>
   1432c:	00058b93          	mv	s7,a1
   14330:	00050a93          	mv	s5,a0
   14334:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   14338:	00100993          	li	s3,1
   1433c:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   14340:	008b2483          	lw	s1,8(s6)
   14344:	010b3403          	ld	s0,16(s6)
   14348:	fff4849b          	addiw	s1,s1,-1
   1434c:	0204c863          	bltz	s1,1437c <_fwalk_reent+0x80>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   14350:	01045783          	lhu	a5,16(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   14354:	fff4849b          	addiw	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   14358:	00f9fe63          	bleu	a5,s3,14374 <_fwalk_reent+0x78>
   1435c:	01241783          	lh	a5,18(s0)
	ret |= (*reent_function) (ptr, fp);
   14360:	00040593          	mv	a1,s0
   14364:	000a8513          	mv	a0,s5
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   14368:	01278663          	beq	a5,s2,14374 <_fwalk_reent+0x78>
	ret |= (*reent_function) (ptr, fp);
   1436c:	000b80e7          	jalr	s7
   14370:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   14374:	0b040413          	addi	s0,s0,176
   14378:	fd249ce3          	bne	s1,s2,14350 <_fwalk_reent+0x54>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   1437c:	000b3b03          	ld	s6,0(s6)
   14380:	fc0b10e3          	bnez	s6,14340 <_fwalk_reent+0x44>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*reent_function) (ptr, fp);

  return ret;
}
   14384:	04813083          	ld	ra,72(sp)
   14388:	000a0513          	mv	a0,s4
   1438c:	04013403          	ld	s0,64(sp)
   14390:	03813483          	ld	s1,56(sp)
   14394:	03013903          	ld	s2,48(sp)
   14398:	02813983          	ld	s3,40(sp)
   1439c:	02013a03          	ld	s4,32(sp)
   143a0:	01813a83          	ld	s5,24(sp)
   143a4:	01013b03          	ld	s6,16(sp)
   143a8:	00813b83          	ld	s7,8(sp)
   143ac:	05010113          	addi	sp,sp,80
   143b0:	00008067          	ret
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   143b4:	00000a13          	li	s4,0
   143b8:	fcdff06f          	j	14384 <_fwalk_reent+0x88>

00000000000143bc <_setlocale_r>:
char *
_DEFUN(_setlocale_r, (p, category, locale),
       struct _reent *p _AND
       int category _AND
       _CONST char *locale)
{
   143bc:	fe010113          	addi	sp,sp,-32
   143c0:	00913423          	sd	s1,8(sp)
   143c4:	00113c23          	sd	ra,24(sp)
   143c8:	00813823          	sd	s0,16(sp)
   143cc:	000194b7          	lui	s1,0x19
#ifndef _MB_CAPABLE
  if (locale)
   143d0:	02060063          	beqz	a2,143f0 <_setlocale_r+0x34>
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   143d4:	000195b7          	lui	a1,0x19
   143d8:	28058593          	addi	a1,a1,640 # 19280 <zeroes.4137+0x90>
   143dc:	00060513          	mv	a0,a2
   143e0:	00060413          	mv	s0,a2
   143e4:	6d5010ef          	jal	162b8 <strcmp>
   143e8:	000194b7          	lui	s1,0x19
   143ec:	00051e63          	bnez	a0,14408 <_setlocale_r+0x4c>
	  && strcmp (locale, ""))
        return NULL;
    }
  return "C";
   143f0:	20048513          	addi	a0,s1,512 # 19200 <zeroes.4137+0x10>
	  return NULL;
	}
    }
  return currentlocale ();
#endif /* !_MB_CAPABLE */
}
   143f4:	01813083          	ld	ra,24(sp)
   143f8:	01013403          	ld	s0,16(sp)
   143fc:	00813483          	ld	s1,8(sp)
   14400:	02010113          	addi	sp,sp,32
   14404:	00008067          	ret
       _CONST char *locale)
{
#ifndef _MB_CAPABLE
  if (locale)
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   14408:	20048593          	addi	a1,s1,512
   1440c:	00040513          	mv	a0,s0
   14410:	6a9010ef          	jal	162b8 <strcmp>
   14414:	fc050ee3          	beqz	a0,143f0 <_setlocale_r+0x34>
	  && strcmp (locale, ""))
   14418:	000195b7          	lui	a1,0x19
   1441c:	23858593          	addi	a1,a1,568 # 19238 <zeroes.4137+0x48>
   14420:	00040513          	mv	a0,s0
   14424:	695010ef          	jal	162b8 <strcmp>
   14428:	fc0504e3          	beqz	a0,143f0 <_setlocale_r+0x34>
        return NULL;
   1442c:	00000513          	li	a0,0
   14430:	fc5ff06f          	j	143f4 <_setlocale_r+0x38>

0000000000014434 <__locale_charset>:
_DEFUN_VOID(__locale_charset)
{
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->codeset;
#else
  return lc_ctype_charset;
   14434:	0001b537          	lui	a0,0x1b
#endif
}
   14438:	a1850513          	addi	a0,a0,-1512 # 1aa18 <lc_ctype_charset>
   1443c:	00008067          	ret

0000000000014440 <__locale_mb_cur_max>:
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->mb_cur_max[0];
#else
  return __mb_cur_max;
#endif
}
   14440:	8181a503          	lw	a0,-2024(gp) # 1b2e8 <__mb_cur_max>
   14444:	00008067          	ret

0000000000014448 <__locale_msgcharset>:
_DEFUN_VOID(__locale_msgcharset)
{
#ifdef __HAVE_LOCALE_INFO__
  return (char *) __get_current_messages_locale ()->codeset;
#else
  return lc_message_charset;
   14448:	0001b537          	lui	a0,0x1b
#endif
}
   1444c:	a3850513          	addi	a0,a0,-1480 # 1aa38 <lc_message_charset>
   14450:	00008067          	ret

0000000000014454 <__locale_cjk_lang>:

int
_DEFUN_VOID(__locale_cjk_lang)
{
  return lc_ctype_cjk_lang;
}
   14454:	00000513          	li	a0,0
   14458:	00008067          	ret

000000000001445c <_localeconv_r>:
      lconv.int_p_sign_posn = m->p_sign_posn[0];
#endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
      __mlocale_changed = 0;
    }
#endif /* __HAVE_LOCALE_INFO__ */
  return (struct lconv *) &lconv;
   1445c:	0001b537          	lui	a0,0x1b
}
   14460:	a5850513          	addi	a0,a0,-1448 # 1aa58 <lconv>
   14464:	00008067          	ret

0000000000014468 <setlocale>:
char *
_DEFUN(setlocale, (category, locale),
       int category _AND
       _CONST char *locale)
{
  return _setlocale_r (_REENT, category, locale);
   14468:	00058613          	mv	a2,a1
   1446c:	00050593          	mv	a1,a0
   14470:	8101b503          	ld	a0,-2032(gp) # 1b2e0 <_impure_ptr>
   14474:	f49ff06f          	j	143bc <_setlocale_r>

0000000000014478 <localeconv>:
#endif /* __CYGWIN__ */

struct lconv *
_DEFUN_VOID(localeconv)
{
  return _localeconv_r (_REENT);
   14478:	0001b537          	lui	a0,0x1b
}
   1447c:	a5850513          	addi	a0,a0,-1448 # 1aa58 <lconv>
   14480:	00008067          	ret

0000000000014484 <__smakebuf_r>:
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   14484:	01059783          	lh	a5,16(a1)

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   14488:	f5010113          	addi	sp,sp,-176
   1448c:	08913c23          	sd	s1,152(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   14490:	03079493          	slli	s1,a5,0x30
   14494:	0304d493          	srli	s1,s1,0x30

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   14498:	0a113423          	sd	ra,168(sp)
   1449c:	0a813023          	sd	s0,160(sp)
   144a0:	09213823          	sd	s2,144(sp)
   144a4:	09313423          	sd	s3,136(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   144a8:	0024f713          	andi	a4,s1,2
   144ac:	0e071063          	bnez	a4,1458c <__smakebuf_r+0x108>
   144b0:	00050913          	mv	s2,a0
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
   144b4:	01259503          	lh	a0,18(a1)
   144b8:	00058413          	mv	s0,a1
   144bc:	04054c63          	bltz	a0,14514 <__smakebuf_r+0x90>
   144c0:	00010593          	mv	a1,sp
   144c4:	5b4040ef          	jal	18a78 <fstat>
   144c8:	04054063          	bltz	a0,14508 <__smakebuf_r+0x84>
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   144cc:	01012703          	lw	a4,16(sp)
   144d0:	0000f7b7          	lui	a5,0xf
   144d4:	ffffe9b7          	lui	s3,0xffffe
   144d8:	00f777b3          	and	a5,a4,a5
   144dc:	013789bb          	addw	s3,a5,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   144e0:	00008737          	lui	a4,0x8
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   144e4:	0019b993          	seqz	s3,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   144e8:	0ce78a63          	beq	a5,a4,145bc <__smakebuf_r+0x138>
#else
	  fp->_blksize = 1024;
#endif
	}
      else
	fp->_flags |= __SNPT;
   144ec:	01045703          	lhu	a4,16(s0)
   144f0:	000017b7          	lui	a5,0x1
   144f4:	8007879b          	addiw	a5,a5,-2048
   144f8:	00f767b3          	or	a5,a4,a5
   144fc:	00f41823          	sh	a5,16(s0)
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
   14500:	40000493          	li	s1,1024
   14504:	0340006f          	j	14538 <__smakebuf_r+0xb4>
   14508:	01041783          	lh	a5,16(s0)
   1450c:	03079493          	slli	s1,a5,0x30
   14510:	0304d493          	srli	s1,s1,0x30
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   14514:	03849493          	slli	s1,s1,0x38
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   14518:	00001737          	lui	a4,0x1
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   1451c:	43f4d493          	srai	s1,s1,0x3f
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   14520:	8007071b          	addiw	a4,a4,-2048
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   14524:	c404f493          	andi	s1,s1,-960
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   14528:	00e7e7b3          	or	a5,a5,a4
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   1452c:	40048493          	addi	s1,s1,1024
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   14530:	00f41823          	sh	a5,16(s0)
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
#endif
    {
      couldbetty = 0;
   14534:	00000993          	li	s3,0
	}
      else
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
   14538:	00048593          	mv	a1,s1
   1453c:	00090513          	mv	a0,s2
   14540:	0f0000ef          	jal	14630 <_malloc_r>
   14544:	0c050063          	beqz	a0,14604 <__smakebuf_r+0x180>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
   14548:	01045783          	lhu	a5,16(s0)
	  fp->_bf._size = 1;
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   1454c:	00014737          	lui	a4,0x14
   14550:	abc70713          	addi	a4,a4,-1348 # 13abc <_cleanup_r>
   14554:	04e93c23          	sd	a4,88(s2)
      fp->_flags |= __SMBF;
   14558:	0807e793          	ori	a5,a5,128
   1455c:	00f41823          	sh	a5,16(s0)
      fp->_bf._base = fp->_p = (unsigned char *) p;
   14560:	00a43023          	sd	a0,0(s0)
   14564:	00a43c23          	sd	a0,24(s0)
      fp->_bf._size = size;
   14568:	02942023          	sw	s1,32(s0)
      if (couldbetty && _isatty_r (ptr, fp->_file))
   1456c:	06099e63          	bnez	s3,145e8 <__smakebuf_r+0x164>
	fp->_flags |= __SLBF;
    }
}
   14570:	0a813083          	ld	ra,168(sp)
   14574:	0a013403          	ld	s0,160(sp)
   14578:	09813483          	ld	s1,152(sp)
   1457c:	09013903          	ld	s2,144(sp)
   14580:	08813983          	ld	s3,136(sp)
   14584:	0b010113          	addi	sp,sp,176
   14588:	00008067          	ret
   1458c:	0a813083          	ld	ra,168(sp)
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
   14590:	07758793          	addi	a5,a1,119
   14594:	00f5b023          	sd	a5,0(a1)
   14598:	00f5bc23          	sd	a5,24(a1)
      fp->_bf._size = 1;
   1459c:	00100793          	li	a5,1
      fp->_bf._base = fp->_p = (unsigned char *) p;
      fp->_bf._size = size;
      if (couldbetty && _isatty_r (ptr, fp->_file))
	fp->_flags |= __SLBF;
    }
}
   145a0:	0a013403          	ld	s0,160(sp)
   145a4:	09813483          	ld	s1,152(sp)
   145a8:	09013903          	ld	s2,144(sp)
   145ac:	08813983          	ld	s3,136(sp)
#endif

  if (fp->_flags & __SNBF)
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
      fp->_bf._size = 1;
   145b0:	02f5a023          	sw	a5,32(a1)
      fp->_bf._base = fp->_p = (unsigned char *) p;
      fp->_bf._size = size;
      if (couldbetty && _isatty_r (ptr, fp->_file))
	fp->_flags |= __SLBF;
    }
}
   145b4:	0b010113          	addi	sp,sp,176
   145b8:	00008067          	ret
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   145bc:	04843703          	ld	a4,72(s0)
   145c0:	000167b7          	lui	a5,0x16
   145c4:	24478793          	addi	a5,a5,580 # 16244 <__sseek>
   145c8:	f2f712e3          	bne	a4,a5,144ec <__smakebuf_r+0x68>
	{
	  fp->_flags |= __SOPT;
   145cc:	01045783          	lhu	a5,16(s0)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   145d0:	40000713          	li	a4,1024
   145d4:	08e42423          	sw	a4,136(s0)
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
	{
	  fp->_flags |= __SOPT;
   145d8:	00e7e7b3          	or	a5,a5,a4
   145dc:	00f41823          	sh	a5,16(s0)
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
   145e0:	40000493          	li	s1,1024
	{
	  fp->_flags |= __SOPT;
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   145e4:	f55ff06f          	j	14538 <__smakebuf_r+0xb4>
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
      fp->_bf._base = fp->_p = (unsigned char *) p;
      fp->_bf._size = size;
      if (couldbetty && _isatty_r (ptr, fp->_file))
   145e8:	01241503          	lh	a0,18(s0)
   145ec:	618040ef          	jal	18c04 <isatty>
   145f0:	f80500e3          	beqz	a0,14570 <__smakebuf_r+0xec>
	fp->_flags |= __SLBF;
   145f4:	01045783          	lhu	a5,16(s0)
   145f8:	0017e793          	ori	a5,a5,1
   145fc:	00f41823          	sh	a5,16(s0)
   14600:	f71ff06f          	j	14570 <__smakebuf_r+0xec>
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
   14604:	01041783          	lh	a5,16(s0)
   14608:	2007f713          	andi	a4,a5,512
   1460c:	f60712e3          	bnez	a4,14570 <__smakebuf_r+0xec>
	{
	  fp->_flags |= __SNBF;
   14610:	0027e793          	ori	a5,a5,2
	  fp->_bf._base = fp->_p = fp->_nbuf;
   14614:	07740713          	addi	a4,s0,119
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
   14618:	00f41823          	sh	a5,16(s0)
	  fp->_bf._base = fp->_p = fp->_nbuf;
	  fp->_bf._size = 1;
   1461c:	00100793          	li	a5,1
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
	  fp->_bf._base = fp->_p = fp->_nbuf;
   14620:	00e43023          	sd	a4,0(s0)
   14624:	00e43c23          	sd	a4,24(s0)
	  fp->_bf._size = 1;
   14628:	02f42023          	sw	a5,32(s0)
   1462c:	f45ff06f          	j	14570 <__smakebuf_r+0xec>

0000000000014630 <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   14630:	fa010113          	addi	sp,sp,-96
   14634:	04913423          	sd	s1,72(sp)
   14638:	03313c23          	sd	s3,56(sp)
   1463c:	04113c23          	sd	ra,88(sp)
   14640:	04813823          	sd	s0,80(sp)
   14644:	05213023          	sd	s2,64(sp)
   14648:	03413823          	sd	s4,48(sp)
   1464c:	03513423          	sd	s5,40(sp)
   14650:	03613023          	sd	s6,32(sp)
   14654:	01713c23          	sd	s7,24(sp)
   14658:	01813823          	sd	s8,16(sp)
   1465c:	01913423          	sd	s9,8(sp)
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   14660:	01758493          	addi	s1,a1,23
   14664:	02e00793          	li	a5,46
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   14668:	00050993          	mv	s3,a0
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   1466c:	1c97fa63          	bleu	s1,a5,14840 <_malloc_r+0x210>

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   14670:	800007b7          	lui	a5,0x80000
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   14674:	ff04f493          	andi	s1,s1,-16

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   14678:	fff7c793          	not	a5,a5
   1467c:	2497ee63          	bltu	a5,s1,148d8 <_malloc_r+0x2a8>
   14680:	24b4ec63          	bltu	s1,a1,148d8 <_malloc_r+0x2a8>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   14684:	201000ef          	jal	15084 <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
   14688:	1f700793          	li	a5,503
   1468c:	7097f063          	bleu	s1,a5,14d8c <_malloc_r+0x75c>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   14690:	0094d793          	srli	a5,s1,0x9
   14694:	08000693          	li	a3,128
   14698:	04000513          	li	a0,64
   1469c:	03f00593          	li	a1,63
   146a0:	24079463          	bnez	a5,148e8 <_malloc_r+0x2b8>
    bin = bin_at(idx);
   146a4:	0001b937          	lui	s2,0x1b
   146a8:	ab890913          	addi	s2,s2,-1352 # 1aab8 <__malloc_av_>
   146ac:	00369693          	slli	a3,a3,0x3
   146b0:	00d906b3          	add	a3,s2,a3

    for (victim = last(bin); victim != bin; victim = victim->bk)
   146b4:	0086b403          	ld	s0,8(a3)

  }
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);
   146b8:	ff068693          	addi	a3,a3,-16

    for (victim = last(bin); victim != bin; victim = victim->bk)
   146bc:	24868663          	beq	a3,s0,14908 <_malloc_r+0x2d8>
    {
      victim_size = chunksize(victim);
   146c0:	00843783          	ld	a5,8(s0)
      remainder_size = long_sub_size_t(victim_size, nb);
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   146c4:	01f00613          	li	a2,31
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
    {
      victim_size = chunksize(victim);
   146c8:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   146cc:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   146d0:	02e64063          	blt	a2,a4,146f0 <_malloc_r+0xc0>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
   146d4:	22075e63          	bgez	a4,14910 <_malloc_r+0x2e0>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   146d8:	01843403          	ld	s0,24(s0)
   146dc:	22868663          	beq	a3,s0,14908 <_malloc_r+0x2d8>
    {
      victim_size = chunksize(victim);
   146e0:	00843783          	ld	a5,8(s0)
   146e4:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   146e8:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   146ec:	fee654e3          	ble	a4,a2,146d4 <_malloc_r+0xa4>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
   146f0:	00058693          	mv	a3,a1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
   146f4:	02093403          	ld	s0,32(s2)
   146f8:	01090813          	addi	a6,s2,16
   146fc:	47040a63          	beq	s0,a6,14b70 <_malloc_r+0x540>
  {
    victim_size = chunksize(victim);
   14700:	00843783          	ld	a5,8(s0)
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
   14704:	01f00613          	li	a2,31

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
  {
    victim_size = chunksize(victim);
   14708:	ffc7f793          	andi	a5,a5,-4
    remainder_size = long_sub_size_t(victim_size, nb);
   1470c:	40978733          	sub	a4,a5,s1

    if (remainder_size >= (long)MINSIZE) /* re-split */
   14710:	44e64a63          	blt	a2,a4,14b64 <_malloc_r+0x534>
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    clear_last_remainder;
   14714:	03093423          	sd	a6,40(s2)
   14718:	03093023          	sd	a6,32(s2)

    if (remainder_size >= 0)  /* exhaust */
   1471c:	20075063          	bgez	a4,1491c <_malloc_r+0x2ec>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   14720:	1ff00713          	li	a4,511
   14724:	3cf76c63          	bltu	a4,a5,14afc <_malloc_r+0x4cc>
   14728:	0037d793          	srli	a5,a5,0x3
   1472c:	0007879b          	sext.w	a5,a5
   14730:	0017861b          	addiw	a2,a5,1
   14734:	0016161b          	slliw	a2,a2,0x1
   14738:	00361613          	slli	a2,a2,0x3
   1473c:	00893703          	ld	a4,8(s2)
   14740:	00c90633          	add	a2,s2,a2
   14744:	00063503          	ld	a0,0(a2)
   14748:	4027d79b          	sraiw	a5,a5,0x2
   1474c:	00100593          	li	a1,1
   14750:	00f597b3          	sll	a5,a1,a5
   14754:	00e7e7b3          	or	a5,a5,a4
   14758:	ff060713          	addi	a4,a2,-16
   1475c:	00e43c23          	sd	a4,24(s0)
   14760:	00a43823          	sd	a0,16(s0)
   14764:	00f93423          	sd	a5,8(s2)
   14768:	00863023          	sd	s0,0(a2)
   1476c:	00853c23          	sd	s0,24(a0)
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
   14770:	4026d61b          	sraiw	a2,a3,0x2
   14774:	00100713          	li	a4,1
   14778:	00c71633          	sll	a2,a4,a2
   1477c:	1cc7e063          	bltu	a5,a2,1493c <_malloc_r+0x30c>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
   14780:	00f67733          	and	a4,a2,a5
   14784:	02071463          	bnez	a4,147ac <_malloc_r+0x17c>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
   14788:	00161613          	slli	a2,a2,0x1
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   1478c:	ffc6f693          	andi	a3,a3,-4
      block <<= 1;
      while ((block & binblocks) == 0)
   14790:	00f67733          	and	a4,a2,a5
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   14794:	0046869b          	addiw	a3,a3,4
      block <<= 1;
      while ((block & binblocks) == 0)
   14798:	00071a63          	bnez	a4,147ac <_malloc_r+0x17c>
      {
        idx += BINBLOCKWIDTH;
        block <<= 1;
   1479c:	00161613          	slli	a2,a2,0x1
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   147a0:	00f67733          	and	a4,a2,a5
      {
        idx += BINBLOCKWIDTH;
   147a4:	0046869b          	addiw	a3,a3,4
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   147a8:	fe070ae3          	beqz	a4,1479c <_malloc_r+0x16c>
        for (victim = last(bin); victim != bin; victim = victim->bk)
        {
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
   147ac:	01f00513          	li	a0,31
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
   147b0:	0016889b          	addiw	a7,a3,1
   147b4:	0018989b          	slliw	a7,a7,0x1
   147b8:	00389893          	slli	a7,a7,0x3
   147bc:	011908b3          	add	a7,s2,a7
   147c0:	ff088893          	addi	a7,a7,-16
   147c4:	00088593          	mv	a1,a7
   147c8:	00068313          	mv	t1,a3
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   147cc:	0185b403          	ld	s0,24(a1)
   147d0:	00859a63          	bne	a1,s0,147e4 <_malloc_r+0x1b4>
   147d4:	3a40006f          	j	14b78 <_malloc_r+0x548>
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
   147d8:	3c075263          	bgez	a4,14b9c <_malloc_r+0x56c>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   147dc:	01843403          	ld	s0,24(s0)
   147e0:	38858c63          	beq	a1,s0,14b78 <_malloc_r+0x548>
        {
          victim_size = chunksize(victim);
   147e4:	00843783          	ld	a5,8(s0)
   147e8:	ffc7f793          	andi	a5,a5,-4
          remainder_size = long_sub_size_t(victim_size, nb);
   147ec:	40978733          	sub	a4,a5,s1

          if (remainder_size >= (long)MINSIZE) /* split */
   147f0:	fee554e3          	ble	a4,a0,147d8 <_malloc_r+0x1a8>
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   147f4:	01843783          	ld	a5,24(s0)
   147f8:	01043683          	ld	a3,16(s0)
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
   147fc:	0014e613          	ori	a2,s1,1
   14800:	00c43423          	sd	a2,8(s0)
            unlink(victim, bck, fwd);
   14804:	00f6bc23          	sd	a5,24(a3)
   14808:	00d7b823          	sd	a3,16(a5) # ffffffff80000010 <_gp+0xffffffff7ffe4540>
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
   1480c:	009404b3          	add	s1,s0,s1
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
   14810:	02993423          	sd	s1,40(s2)
   14814:	02993023          	sd	s1,32(s2)
            set_head(remainder, remainder_size | PREV_INUSE);
   14818:	00176793          	ori	a5,a4,1
          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
   1481c:	0104bc23          	sd	a6,24(s1)
   14820:	0104b823          	sd	a6,16(s1)
            set_head(remainder, remainder_size | PREV_INUSE);
   14824:	00f4b423          	sd	a5,8(s1)
            set_foot(remainder, remainder_size);
   14828:	00e484b3          	add	s1,s1,a4
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   1482c:	00098513          	mv	a0,s3
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
            set_foot(remainder, remainder_size);
   14830:	00e4b023          	sd	a4,0(s1)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   14834:	055000ef          	jal	15088 <__malloc_unlock>
            return chunk2mem(victim);
   14838:	01040513          	addi	a0,s0,16
   1483c:	0680006f          	j	148a4 <_malloc_r+0x274>
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   14840:	02000493          	li	s1,32
   14844:	08b4ea63          	bltu	s1,a1,148d8 <_malloc_r+0x2a8>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   14848:	03d000ef          	jal	15084 <__malloc_lock>
   1484c:	00a00793          	li	a5,10
   14850:	00400693          	li	a3,4
  {
    idx = smallbin_index(nb); 

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
   14854:	0001b937          	lui	s2,0x1b
   14858:	ab890913          	addi	s2,s2,-1352 # 1aab8 <__malloc_av_>
   1485c:	00379793          	slli	a5,a5,0x3
   14860:	00f907b3          	add	a5,s2,a5
    victim = last(q);
   14864:	0087b403          	ld	s0,8(a5)

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
   14868:	ff078713          	addi	a4,a5,-16
   1486c:	32e40063          	beq	s0,a4,14b8c <_malloc_r+0x55c>
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   14870:	00843783          	ld	a5,8(s0)
      unlink(victim, bck, fwd);
   14874:	01843683          	ld	a3,24(s0)
   14878:	01043603          	ld	a2,16(s0)
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   1487c:	ffc7f793          	andi	a5,a5,-4
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
        set_inuse_bit_at_offset(victim, victim_size);
   14880:	00f407b3          	add	a5,s0,a5
   14884:	0087b703          	ld	a4,8(a5)
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   14888:	00d63c23          	sd	a3,24(a2)
   1488c:	00c6b823          	sd	a2,16(a3)
        set_inuse_bit_at_offset(victim, victim_size);
   14890:	00176713          	ori	a4,a4,1
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   14894:	00098513          	mv	a0,s3
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
        set_inuse_bit_at_offset(victim, victim_size);
   14898:	00e7b423          	sd	a4,8(a5)
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   1489c:	7ec000ef          	jal	15088 <__malloc_unlock>
        return chunk2mem(victim);
   148a0:	01040513          	addi	a0,s0,16
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
  return chunk2mem(victim);

#endif /* MALLOC_PROVIDED */
}
   148a4:	05813083          	ld	ra,88(sp)
   148a8:	05013403          	ld	s0,80(sp)
   148ac:	04813483          	ld	s1,72(sp)
   148b0:	04013903          	ld	s2,64(sp)
   148b4:	03813983          	ld	s3,56(sp)
   148b8:	03013a03          	ld	s4,48(sp)
   148bc:	02813a83          	ld	s5,40(sp)
   148c0:	02013b03          	ld	s6,32(sp)
   148c4:	01813b83          	ld	s7,24(sp)
   148c8:	01013c03          	ld	s8,16(sp)
   148cc:	00813c83          	ld	s9,8(sp)
   148d0:	06010113          	addi	sp,sp,96
   148d4:	00008067          	ret
  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   148d8:	00c00793          	li	a5,12
   148dc:	00f9a023          	sw	a5,0(s3) # ffffffffffffe000 <_gp+0xfffffffffffe2530>
    return 0;
   148e0:	00000513          	li	a0,0
   148e4:	fc1ff06f          	j	148a4 <_malloc_r+0x274>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   148e8:	00400713          	li	a4,4
   148ec:	1ef76463          	bltu	a4,a5,14ad4 <_malloc_r+0x4a4>
   148f0:	0064d593          	srli	a1,s1,0x6
   148f4:	0005859b          	sext.w	a1,a1
   148f8:	0395851b          	addiw	a0,a1,57
   148fc:	0015169b          	slliw	a3,a0,0x1
   14900:	0385859b          	addiw	a1,a1,56
   14904:	da1ff06f          	j	146a4 <_malloc_r+0x74>
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   14908:	00050693          	mv	a3,a0
   1490c:	de9ff06f          	j	146f4 <_malloc_r+0xc4>
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   14910:	01843683          	ld	a3,24(s0)
   14914:	01043603          	ld	a2,16(s0)
   14918:	f69ff06f          	j	14880 <_malloc_r+0x250>

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   1491c:	00f407b3          	add	a5,s0,a5
   14920:	0087b703          	ld	a4,8(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   14924:	00098513          	mv	a0,s3

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   14928:	00176713          	ori	a4,a4,1
   1492c:	00e7b423          	sd	a4,8(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   14930:	758000ef          	jal	15088 <__malloc_unlock>
      return chunk2mem(victim);
   14934:	01040513          	addi	a0,s0,16
   14938:	f6dff06f          	j	148a4 <_malloc_r+0x274>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   1493c:	01093403          	ld	s0,16(s2)
   14940:	00843703          	ld	a4,8(s0)
   14944:	ffc77b93          	andi	s7,a4,-4
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   14948:	009be863          	bltu	s7,s1,14958 <_malloc_r+0x328>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   1494c:	409b87b3          	sub	a5,s7,s1
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   14950:	01f00713          	li	a4,31
   14954:	14f74c63          	blt	a4,a5,14aac <_malloc_r+0x47c>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   14958:	8b81b783          	ld	a5,-1864(gp) # 1b388 <__malloc_top_pad>

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   1495c:	8201b683          	ld	a3,-2016(gp) # 1b2f0 <__malloc_sbrk_base>
   14960:	fff00713          	li	a4,-1
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   14964:	00f487b3          	add	a5,s1,a5
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
   14968:	01740a33          	add	s4,s0,s7

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   1496c:	02078b13          	addi	s6,a5,32

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   14970:	00e68c63          	beq	a3,a4,14988 <_malloc_r+0x358>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
   14974:	00001b37          	lui	s6,0x1
   14978:	01fb0b13          	addi	s6,s6,31 # 101f <_ftext-0xefe1>
   1497c:	01678b33          	add	s6,a5,s6
   14980:	fffff7b7          	lui	a5,0xfffff
   14984:	00fb7b33          	and	s6,s6,a5

  brk = (char*)(MORECORE (sbrk_size));
   14988:	000b0513          	mv	a0,s6
   1498c:	3b8040ef          	jal	18d44 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   14990:	fff00793          	li	a5,-1
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
   14994:	00050a93          	mv	s5,a0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   14998:	26f50263          	beq	a0,a5,14bfc <_malloc_r+0x5cc>
   1499c:	25456e63          	bltu	a0,s4,14bf8 <_malloc_r+0x5c8>
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
   149a0:	90018c13          	addi	s8,gp,-1792 # 1b3d0 <__malloc_current_mallinfo>
   149a4:	000c2783          	lw	a5,0(s8)
   149a8:	00fb07bb          	addw	a5,s6,a5
   149ac:	00fc2023          	sw	a5,0(s8)

  if (brk == old_end /* can just add bytes to current top, unless
   149b0:	355a0463          	beq	s4,s5,14cf8 <_malloc_r+0x6c8>
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
   149b4:	8201b683          	ld	a3,-2016(gp) # 1b2f0 <__malloc_sbrk_base>
   149b8:	fff00713          	li	a4,-1
   149bc:	36e68263          	beq	a3,a4,14d20 <_malloc_r+0x6f0>
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
   149c0:	414a8a33          	sub	s4,s5,s4
   149c4:	00fa07bb          	addw	a5,s4,a5
   149c8:	00fc2023          	sw	a5,0(s8)

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
   149cc:	00faf713          	andi	a4,s5,15
    if (front_misalign > 0) 
   149d0:	000017b7          	lui	a5,0x1
   149d4:	00070a63          	beqz	a4,149e8 <_malloc_r+0x3b8>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
      brk += correction;
   149d8:	40ea8ab3          	sub	s5,s5,a4
   149dc:	01078a13          	addi	s4,a5,16 # 1010 <_ftext-0xeff0>
   149e0:	010a8a93          	addi	s5,s5,16
   149e4:	40ea07b3          	sub	a5,s4,a4
    }
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
   149e8:	00001a37          	lui	s4,0x1
   149ec:	fffa0a13          	addi	s4,s4,-1 # fff <_ftext-0xf001>
   149f0:	016a8b33          	add	s6,s5,s6
   149f4:	014b7b33          	and	s6,s6,s4
   149f8:	41678a33          	sub	s4,a5,s6

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
   149fc:	000a0513          	mv	a0,s4
   14a00:	344040ef          	jal	18d44 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE))
   14a04:	fff00793          	li	a5,-1
   14a08:	30f50663          	beq	a0,a5,14d14 <_malloc_r+0x6e4>
   14a0c:	41550733          	sub	a4,a0,s5
   14a10:	01470733          	add	a4,a4,s4
   14a14:	00176713          	ori	a4,a4,1
   14a18:	000a0a1b          	sext.w	s4,s4
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   14a1c:	000c2783          	lw	a5,0(s8)

    top = (mchunkptr)brk;
   14a20:	01593823          	sd	s5,16(s2)
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
   14a24:	00eab423          	sd	a4,8(s5)
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   14a28:	00fa07bb          	addw	a5,s4,a5
   14a2c:	00fc2023          	sw	a5,0(s8)

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
   14a30:	03240c63          	beq	s0,s2,14a68 <_malloc_r+0x438>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
   14a34:	01f00613          	li	a2,31
   14a38:	27767463          	bleu	s7,a2,14ca0 <_malloc_r+0x670>
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
   14a3c:	00843683          	ld	a3,8(s0)
        set_head(top, PREV_INUSE); /* will force null return from malloc */
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
   14a40:	fe8b8713          	addi	a4,s7,-24
   14a44:	ff077713          	andi	a4,a4,-16
      set_head_size(old_top, old_top_size);
   14a48:	0016f693          	andi	a3,a3,1
   14a4c:	00e6e6b3          	or	a3,a3,a4
   14a50:	00d43423          	sd	a3,8(s0)
      chunk_at_offset(old_top, old_top_size          )->size =
   14a54:	00900593          	li	a1,9
   14a58:	00e406b3          	add	a3,s0,a4
   14a5c:	00b6b423          	sd	a1,8(a3)
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
   14a60:	00b6b823          	sd	a1,16(a3)
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
   14a64:	2ce66263          	bltu	a2,a4,14d28 <_malloc_r+0x6f8>
        fREe(RCALL chunk2mem(old_top));
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
   14a68:	8b01b683          	ld	a3,-1872(gp) # 1b380 <__malloc_max_sbrked_mem>
   14a6c:	00f6f463          	bleu	a5,a3,14a74 <_malloc_r+0x444>
    max_sbrked_mem = sbrked_mem;
   14a70:	8af1b823          	sd	a5,-1872(gp) # 1b380 <__malloc_max_sbrked_mem>
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
   14a74:	8a81b683          	ld	a3,-1880(gp) # 1b378 <__malloc_max_total_mem>
   14a78:	01093403          	ld	s0,16(s2)
   14a7c:	00f6f463          	bleu	a5,a3,14a84 <_malloc_r+0x454>
    max_total_mem = sbrked_mem;
   14a80:	8af1b423          	sd	a5,-1880(gp) # 1b378 <__malloc_max_total_mem>
   14a84:	00843703          	ld	a4,8(s0)
   14a88:	ffc77713          	andi	a4,a4,-4
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
    remainder_size = long_sub_size_t(chunksize(top), nb);
   14a8c:	409707b3          	sub	a5,a4,s1
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   14a90:	00976663          	bltu	a4,s1,14a9c <_malloc_r+0x46c>
   14a94:	01f00713          	li	a4,31
   14a98:	00f74a63          	blt	a4,a5,14aac <_malloc_r+0x47c>
    {
      MALLOC_UNLOCK;
   14a9c:	00098513          	mv	a0,s3
   14aa0:	5e8000ef          	jal	15088 <__malloc_unlock>
      return 0; /* propagate failure */
   14aa4:	00000513          	li	a0,0
   14aa8:	dfdff06f          	j	148a4 <_malloc_r+0x274>
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
   14aac:	0014e713          	ori	a4,s1,1
   14ab0:	00e43423          	sd	a4,8(s0)
  top = chunk_at_offset(victim, nb);
   14ab4:	009404b3          	add	s1,s0,s1
   14ab8:	00993823          	sd	s1,16(s2)
  set_head(top, remainder_size | PREV_INUSE);
   14abc:	0017e793          	ori	a5,a5,1
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   14ac0:	00098513          	mv	a0,s3
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
   14ac4:	00f4b423          	sd	a5,8(s1)
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   14ac8:	5c0000ef          	jal	15088 <__malloc_unlock>
  return chunk2mem(victim);
   14acc:	01040513          	addi	a0,s0,16
   14ad0:	dd5ff06f          	j	148a4 <_malloc_r+0x274>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   14ad4:	01400713          	li	a4,20
   14ad8:	0ef77a63          	bleu	a5,a4,14bcc <_malloc_r+0x59c>
   14adc:	05400713          	li	a4,84
   14ae0:	18f76063          	bltu	a4,a5,14c60 <_malloc_r+0x630>
   14ae4:	00c4d593          	srli	a1,s1,0xc
   14ae8:	0005859b          	sext.w	a1,a1
   14aec:	06f5851b          	addiw	a0,a1,111
   14af0:	0015169b          	slliw	a3,a0,0x1
   14af4:	06e5859b          	addiw	a1,a1,110
   14af8:	badff06f          	j	146a4 <_malloc_r+0x74>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   14afc:	0097d713          	srli	a4,a5,0x9
   14b00:	00400613          	li	a2,4
   14b04:	0ce67e63          	bleu	a4,a2,14be0 <_malloc_r+0x5b0>
   14b08:	01400613          	li	a2,20
   14b0c:	1ce66663          	bltu	a2,a4,14cd8 <_malloc_r+0x6a8>
   14b10:	0007071b          	sext.w	a4,a4
   14b14:	05c7059b          	addiw	a1,a4,92
   14b18:	05b7061b          	addiw	a2,a4,91
   14b1c:	0015959b          	slliw	a1,a1,0x1
   14b20:	00359593          	slli	a1,a1,0x3
   14b24:	00b905b3          	add	a1,s2,a1
   14b28:	0005b703          	ld	a4,0(a1)
   14b2c:	ff058593          	addi	a1,a1,-16
   14b30:	14e58863          	beq	a1,a4,14c80 <_malloc_r+0x650>
   14b34:	00873603          	ld	a2,8(a4)
   14b38:	ffc67613          	andi	a2,a2,-4
   14b3c:	00c7f663          	bleu	a2,a5,14b48 <_malloc_r+0x518>
   14b40:	01073703          	ld	a4,16(a4)
   14b44:	fee598e3          	bne	a1,a4,14b34 <_malloc_r+0x504>
   14b48:	01873583          	ld	a1,24(a4)
   14b4c:	00893783          	ld	a5,8(s2)
   14b50:	00b43c23          	sd	a1,24(s0)
   14b54:	00e43823          	sd	a4,16(s0)
   14b58:	0085b823          	sd	s0,16(a1)
   14b5c:	00873c23          	sd	s0,24(a4)
   14b60:	c11ff06f          	j	14770 <_malloc_r+0x140>
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
   14b64:	0014e793          	ori	a5,s1,1
   14b68:	00f43423          	sd	a5,8(s0)
   14b6c:	ca1ff06f          	j	1480c <_malloc_r+0x1dc>
   14b70:	00893783          	ld	a5,8(s2)
   14b74:	bfdff06f          	j	14770 <_malloc_r+0x140>
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   14b78:	0013031b          	addiw	t1,t1,1
   14b7c:	00337793          	andi	a5,t1,3
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
   14b80:	01058593          	addi	a1,a1,16
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   14b84:	c40794e3          	bnez	a5,147cc <_malloc_r+0x19c>
   14b88:	0900006f          	j	14c18 <_malloc_r+0x5e8>
#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
    {
      q = next_bin(q);
      victim = last(q);
   14b8c:	0187b403          	ld	s0,24(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
   14b90:	0026869b          	addiw	a3,a3,2
    {
      q = next_bin(q);
      victim = last(q);
    }
#endif
    if (victim != q)
   14b94:	b68780e3          	beq	a5,s0,146f4 <_malloc_r+0xc4>
   14b98:	cd9ff06f          	j	14870 <_malloc_r+0x240>
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   14b9c:	00f407b3          	add	a5,s0,a5
   14ba0:	0087b703          	ld	a4,8(a5)
            unlink(victim, bck, fwd);
   14ba4:	01843683          	ld	a3,24(s0)
   14ba8:	01043603          	ld	a2,16(s0)
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   14bac:	00176713          	ori	a4,a4,1
   14bb0:	00e7b423          	sd	a4,8(a5)
            unlink(victim, bck, fwd);
   14bb4:	00d63c23          	sd	a3,24(a2)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   14bb8:	00098513          	mv	a0,s3
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
            unlink(victim, bck, fwd);
   14bbc:	00c6b823          	sd	a2,16(a3)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   14bc0:	4c8000ef          	jal	15088 <__malloc_unlock>
            return chunk2mem(victim);
   14bc4:	01040513          	addi	a0,s0,16
   14bc8:	cddff06f          	j	148a4 <_malloc_r+0x274>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   14bcc:	0007879b          	sext.w	a5,a5
   14bd0:	05c7851b          	addiw	a0,a5,92
   14bd4:	05b7859b          	addiw	a1,a5,91
   14bd8:	0015169b          	slliw	a3,a0,0x1
   14bdc:	ac9ff06f          	j	146a4 <_malloc_r+0x74>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   14be0:	0067d713          	srli	a4,a5,0x6
   14be4:	0007071b          	sext.w	a4,a4
   14be8:	0397059b          	addiw	a1,a4,57
   14bec:	0387061b          	addiw	a2,a4,56
   14bf0:	0015959b          	slliw	a1,a1,0x1
   14bf4:	f2dff06f          	j	14b20 <_malloc_r+0x4f0>

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
   14bf8:	db2404e3          	beq	s0,s2,149a0 <_malloc_r+0x370>
   14bfc:	01093403          	ld	s0,16(s2)
   14c00:	00843703          	ld	a4,8(s0)
   14c04:	ffc77713          	andi	a4,a4,-4
   14c08:	e85ff06f          	j	14a8c <_malloc_r+0x45c>
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
      } while (first(q) == q);
   14c0c:	0108b783          	ld	a5,16(a7)
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
   14c10:	fff6869b          	addiw	a3,a3,-1
       q = prev_bin(q);
      } while (first(q) == q);
   14c14:	16f89863          	bne	a7,a5,14d84 <_malloc_r+0x754>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   14c18:	0036f793          	andi	a5,a3,3
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
   14c1c:	ff088893          	addi	a7,a7,-16

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   14c20:	fe0796e3          	bnez	a5,14c0c <_malloc_r+0x5dc>
        {
          binblocks &= ~block;
   14c24:	00893783          	ld	a5,8(s2)
   14c28:	fff64713          	not	a4,a2
   14c2c:	00f777b3          	and	a5,a4,a5
   14c30:	00f93423          	sd	a5,8(s2)
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
   14c34:	00161613          	slli	a2,a2,0x1
   14c38:	d0c7e2e3          	bltu	a5,a2,1493c <_malloc_r+0x30c>
   14c3c:	d00600e3          	beqz	a2,1493c <_malloc_r+0x30c>
      {
        while ((block & binblocks) == 0)
   14c40:	00f67733          	and	a4,a2,a5
   14c44:	00030693          	mv	a3,t1
   14c48:	b60714e3          	bnez	a4,147b0 <_malloc_r+0x180>
        {
          idx += BINBLOCKWIDTH;
          block <<= 1;
   14c4c:	00161613          	slli	a2,a2,0x1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   14c50:	00f67733          	and	a4,a2,a5
        {
          idx += BINBLOCKWIDTH;
   14c54:	0046869b          	addiw	a3,a3,4

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   14c58:	fe070ae3          	beqz	a4,14c4c <_malloc_r+0x61c>
   14c5c:	b55ff06f          	j	147b0 <_malloc_r+0x180>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   14c60:	15400713          	li	a4,340
   14c64:	04f76463          	bltu	a4,a5,14cac <_malloc_r+0x67c>
   14c68:	00f4d593          	srli	a1,s1,0xf
   14c6c:	0005859b          	sext.w	a1,a1
   14c70:	0785851b          	addiw	a0,a1,120
   14c74:	0015169b          	slliw	a3,a0,0x1
   14c78:	0775859b          	addiw	a1,a1,119
   14c7c:	a29ff06f          	j	146a4 <_malloc_r+0x74>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   14c80:	00893783          	ld	a5,8(s2)
   14c84:	4026571b          	sraiw	a4,a2,0x2
   14c88:	00100613          	li	a2,1
   14c8c:	00e61733          	sll	a4,a2,a4
   14c90:	00f767b3          	or	a5,a4,a5
   14c94:	00f93423          	sd	a5,8(s2)
   14c98:	00058713          	mv	a4,a1
   14c9c:	eb5ff06f          	j	14b50 <_malloc_r+0x520>
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
   14ca0:	00100793          	li	a5,1
   14ca4:	00fab423          	sd	a5,8(s5)
   14ca8:	df5ff06f          	j	14a9c <_malloc_r+0x46c>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   14cac:	55400713          	li	a4,1364
   14cb0:	0fe00693          	li	a3,254
   14cb4:	07f00513          	li	a0,127
   14cb8:	07e00593          	li	a1,126
   14cbc:	9ef764e3          	bltu	a4,a5,146a4 <_malloc_r+0x74>
   14cc0:	0124d593          	srli	a1,s1,0x12
   14cc4:	0005859b          	sext.w	a1,a1
   14cc8:	07d5851b          	addiw	a0,a1,125
   14ccc:	0015169b          	slliw	a3,a0,0x1
   14cd0:	07c5859b          	addiw	a1,a1,124
   14cd4:	9d1ff06f          	j	146a4 <_malloc_r+0x74>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   14cd8:	05400613          	li	a2,84
   14cdc:	06e66063          	bltu	a2,a4,14d3c <_malloc_r+0x70c>
   14ce0:	00c7d713          	srli	a4,a5,0xc
   14ce4:	0007071b          	sext.w	a4,a4
   14ce8:	06f7059b          	addiw	a1,a4,111
   14cec:	06e7061b          	addiw	a2,a4,110
   14cf0:	0015959b          	slliw	a1,a1,0x1
   14cf4:	e2dff06f          	j	14b20 <_malloc_r+0x4f0>

  sbrked_mem += sbrk_size;

  if (brk == old_end /* can just add bytes to current top, unless
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
   14cf8:	034a1713          	slli	a4,s4,0x34
   14cfc:	ca071ce3          	bnez	a4,149b4 <_malloc_r+0x384>
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
   14d00:	01093683          	ld	a3,16(s2)
   14d04:	016b8733          	add	a4,s7,s6
   14d08:	00176713          	ori	a4,a4,1
   14d0c:	00e6b423          	sd	a4,8(a3)
   14d10:	d59ff06f          	j	14a68 <_malloc_r+0x438>
    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE))
   14d14:	00100713          	li	a4,1
   14d18:	00000a13          	li	s4,0
   14d1c:	d01ff06f          	j	14a1c <_malloc_r+0x3ec>
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
   14d20:	8351b023          	sd	s5,-2016(gp) # 1b2f0 <__malloc_sbrk_base>
   14d24:	ca9ff06f          	j	149cc <_malloc_r+0x39c>
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
        fREe(RCALL chunk2mem(old_top));
   14d28:	01040593          	addi	a1,s0,16
   14d2c:	00098513          	mv	a0,s3
   14d30:	a0cff0ef          	jal	13f3c <_free_r>
   14d34:	000c2783          	lw	a5,0(s8)
   14d38:	d31ff06f          	j	14a68 <_malloc_r+0x438>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   14d3c:	15400613          	li	a2,340
   14d40:	00e66e63          	bltu	a2,a4,14d5c <_malloc_r+0x72c>
   14d44:	00f7d713          	srli	a4,a5,0xf
   14d48:	0007071b          	sext.w	a4,a4
   14d4c:	0787059b          	addiw	a1,a4,120
   14d50:	0777061b          	addiw	a2,a4,119
   14d54:	0015959b          	slliw	a1,a1,0x1
   14d58:	dc9ff06f          	j	14b20 <_malloc_r+0x4f0>
   14d5c:	55400513          	li	a0,1364
   14d60:	0fe00593          	li	a1,254
   14d64:	07e00613          	li	a2,126
   14d68:	dae56ce3          	bltu	a0,a4,14b20 <_malloc_r+0x4f0>
   14d6c:	0127d713          	srli	a4,a5,0x12
   14d70:	0007071b          	sext.w	a4,a4
   14d74:	07d7059b          	addiw	a1,a4,125
   14d78:	07c7061b          	addiw	a2,a4,124
   14d7c:	0015959b          	slliw	a1,a1,0x1
   14d80:	da1ff06f          	j	14b20 <_malloc_r+0x4f0>
   14d84:	00893783          	ld	a5,8(s2)
   14d88:	eadff06f          	j	14c34 <_malloc_r+0x604>
   14d8c:	0034d693          	srli	a3,s1,0x3
   14d90:	0006869b          	sext.w	a3,a3
   14d94:	0016879b          	addiw	a5,a3,1
   14d98:	0017979b          	slliw	a5,a5,0x1
   14d9c:	ab9ff06f          	j	14854 <_malloc_r+0x224>

0000000000014da0 <memchr>:
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   14da0:	00757793          	andi	a5,a0,7
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
  unsigned char d = c;
   14da4:	0ff5f813          	andi	a6,a1,255
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   14da8:	0c078c63          	beqz	a5,14e80 <memchr+0xe0>
    {
      if (!length--)
   14dac:	fff60793          	addi	a5,a2,-1
   14db0:	06060463          	beqz	a2,14e18 <memchr+0x78>
        return NULL;
      if (*src == d)
   14db4:	00054703          	lbu	a4,0(a0)
   14db8:	07070263          	beq	a4,a6,14e1c <memchr+0x7c>
   14dbc:	00080693          	mv	a3,a6
   14dc0:	0140006f          	j	14dd4 <memchr+0x34>
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
   14dc4:	04078a63          	beqz	a5,14e18 <memchr+0x78>
        return NULL;
      if (*src == d)
   14dc8:	00054703          	lbu	a4,0(a0)
   14dcc:	fff78793          	addi	a5,a5,-1
   14dd0:	04d70663          	beq	a4,a3,14e1c <memchr+0x7c>
        return (void *) src;
      src++;
   14dd4:	00150513          	addi	a0,a0,1
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   14dd8:	00757713          	andi	a4,a0,7
   14ddc:	fe0714e3          	bnez	a4,14dc4 <memchr+0x24>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
   14de0:	00700693          	li	a3,7
   14de4:	02f6ee63          	bltu	a3,a5,14e20 <memchr+0x80>
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   14de8:	02078863          	beqz	a5,14e18 <memchr+0x78>
    {
      if (*src == d)
   14dec:	00054703          	lbu	a4,0(a0)
   14df0:	03070663          	beq	a4,a6,14e1c <memchr+0x7c>
   14df4:	00150713          	addi	a4,a0,1
   14df8:	00f507b3          	add	a5,a0,a5
   14dfc:	00080613          	mv	a2,a6
   14e00:	0100006f          	j	14e10 <memchr+0x70>
   14e04:	00170713          	addi	a4,a4,1
   14e08:	fff74683          	lbu	a3,-1(a4)
   14e0c:	00c68863          	beq	a3,a2,14e1c <memchr+0x7c>
        return (void *) src;
      src++;
   14e10:	00070513          	mv	a0,a4
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   14e14:	fee798e3          	bne	a5,a4,14e04 <memchr+0x64>
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
        return NULL;
   14e18:	00000513          	li	a0,0
        return (void *) src;
      src++;
    }

  return NULL;
}
   14e1c:	00008067          	ret
   14e20:	0ff5f593          	andi	a1,a1,255
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
   14e24:	0085971b          	slliw	a4,a1,0x8
   14e28:	00b765b3          	or	a1,a4,a1
   14e2c:	00058713          	mv	a4,a1
      mask = mask << 16 | mask;
   14e30:	01071613          	slli	a2,a4,0x10
   14e34:	00c76733          	or	a4,a4,a2
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
        {
          if (DETECTCHAR (*asrc, mask))
   14e38:	0001b637          	lui	a2,0x1b
   14e3c:	35063303          	ld	t1,848(a2) # 1b350 <__wctomb+0x50>
   14e40:	0001b637          	lui	a2,0x1b
   14e44:	35863883          	ld	a7,856(a2) # 1b358 <__wctomb+0x58>
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;
   14e48:	02071613          	slli	a2,a4,0x20
   14e4c:	00e66633          	or	a2,a2,a4

      while (length >= LBLOCKSIZE)
   14e50:	00068593          	mv	a1,a3
        {
          if (DETECTCHAR (*asrc, mask))
   14e54:	00053703          	ld	a4,0(a0)
   14e58:	00e64733          	xor	a4,a2,a4
   14e5c:	006706b3          	add	a3,a4,t1
   14e60:	fff74713          	not	a4,a4
   14e64:	00e6f733          	and	a4,a3,a4
   14e68:	01177733          	and	a4,a4,a7
   14e6c:	f80710e3          	bnez	a4,14dec <memchr+0x4c>
            break;
          length -= LBLOCKSIZE;
   14e70:	ff878793          	addi	a5,a5,-8
          asrc++;
   14e74:	00850513          	addi	a0,a0,8
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
   14e78:	fcf5eee3          	bltu	a1,a5,14e54 <memchr+0xb4>
   14e7c:	f6dff06f          	j	14de8 <memchr+0x48>
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   14e80:	00060793          	mv	a5,a2
   14e84:	f5dff06f          	j	14de0 <memchr+0x40>

0000000000014e88 <memcpy>:

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   14e88:	00a5c7b3          	xor	a5,a1,a0
   14e8c:	0077f793          	andi	a5,a5,7
    *(a-1) = tt; \
  }

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
   14e90:	00c508b3          	add	a7,a0,a2
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   14e94:	0e079263          	bnez	a5,14f78 <memcpy+0xf0>
   14e98:	00700793          	li	a5,7
   14e9c:	0ec7fe63          	bleu	a2,a5,14f98 <memcpy+0x110>
      while (a < end)
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
   14ea0:	00757793          	andi	a5,a0,7
   14ea4:	04079a63          	bnez	a5,14ef8 <memcpy+0x70>
    while ((uintptr_t)a & msk)
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   14ea8:	ff88f813          	andi	a6,a7,-8

  if (__builtin_expect(la < lend-8, 0))
   14eac:	fc080793          	addi	a5,a6,-64
   14eb0:	00050713          	mv	a4,a0
   14eb4:	06f56663          	bltu	a0,a5,14f20 <memcpy+0x98>
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   14eb8:	00058693          	mv	a3,a1
   14ebc:	00070793          	mv	a5,a4
   14ec0:	03077863          	bleu	a6,a4,14ef0 <memcpy+0x68>
    BODY(la, lb, long);
   14ec4:	0006b603          	ld	a2,0(a3)
   14ec8:	00878793          	addi	a5,a5,8
   14ecc:	00868693          	addi	a3,a3,8
   14ed0:	fec7bc23          	sd	a2,-8(a5)
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   14ed4:	ff07e8e3          	bltu	a5,a6,14ec4 <memcpy+0x3c>
   14ed8:	fff74793          	not	a5,a4
   14edc:	01078833          	add	a6,a5,a6
   14ee0:	ff887813          	andi	a6,a6,-8
   14ee4:	00880813          	addi	a6,a6,8
   14ee8:	01070733          	add	a4,a4,a6
   14eec:	010585b3          	add	a1,a1,a6
    BODY(la, lb, long);

  a = (char*)la;
  b = (const char*)lb;
  if (__builtin_expect(a < end, 0))
   14ef0:	09176863          	bltu	a4,a7,14f80 <memcpy+0xf8>
    goto small;
  return aa;
}
   14ef4:	00008067          	ret
   14ef8:	00050713          	mv	a4,a0
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
      BODY(a, b, char);
   14efc:	0005c683          	lbu	a3,0(a1)
   14f00:	00170713          	addi	a4,a4,1
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   14f04:	00777793          	andi	a5,a4,7
      BODY(a, b, char);
   14f08:	fed70fa3          	sb	a3,-1(a4)
   14f0c:	00158593          	addi	a1,a1,1
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   14f10:	fe0796e3          	bnez	a5,14efc <memcpy+0x74>
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   14f14:	ff88f813          	andi	a6,a7,-8

  if (__builtin_expect(la < lend-8, 0))
   14f18:	fc080793          	addi	a5,a6,-64
   14f1c:	f8f77ee3          	bleu	a5,a4,14eb8 <memcpy+0x30>
  {
    while (la < lend-8)
    {
      long b0 = *lb++;
   14f20:	0005b383          	ld	t2,0(a1)
      long b1 = *lb++;
   14f24:	0085b283          	ld	t0,8(a1)
      long b2 = *lb++;
   14f28:	0105bf83          	ld	t6,16(a1)
      long b3 = *lb++;
   14f2c:	0185bf03          	ld	t5,24(a1)
      long b4 = *lb++;
   14f30:	0205be83          	ld	t4,32(a1)
      long b5 = *lb++;
   14f34:	0285be03          	ld	t3,40(a1)
      long b6 = *lb++;
   14f38:	0305b303          	ld	t1,48(a1)
      long b7 = *lb++;
   14f3c:	0385b603          	ld	a2,56(a1)
   14f40:	04858593          	addi	a1,a1,72
   14f44:	04870713          	addi	a4,a4,72
      long b8 = *lb++;
   14f48:	ff85b683          	ld	a3,-8(a1)
      *la++ = b0;
   14f4c:	fa773c23          	sd	t2,-72(a4)
      *la++ = b1;
   14f50:	fc573023          	sd	t0,-64(a4)
      *la++ = b2;
   14f54:	fdf73423          	sd	t6,-56(a4)
      *la++ = b3;
   14f58:	fde73823          	sd	t5,-48(a4)
      *la++ = b4;
   14f5c:	fdd73c23          	sd	t4,-40(a4)
      *la++ = b5;
   14f60:	ffc73023          	sd	t3,-32(a4)
      *la++ = b6;
   14f64:	fe673423          	sd	t1,-24(a4)
      *la++ = b7;
   14f68:	fec73823          	sd	a2,-16(a4)
      *la++ = b8;
   14f6c:	fed73c23          	sd	a3,-8(a4)
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);

  if (__builtin_expect(la < lend-8, 0))
  {
    while (la < lend-8)
   14f70:	faf768e3          	bltu	a4,a5,14f20 <memcpy+0x98>
   14f74:	f45ff06f          	j	14eb8 <memcpy+0x30>
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   14f78:	00050713          	mv	a4,a0
   14f7c:	03157463          	bleu	a7,a0,14fa4 <memcpy+0x11c>
      while (a < end)
        BODY(a, b, char);
   14f80:	0005c783          	lbu	a5,0(a1)
   14f84:	00170713          	addi	a4,a4,1
   14f88:	00158593          	addi	a1,a1,1
   14f8c:	fef70fa3          	sb	a5,-1(a4)
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
      while (a < end)
   14f90:	ff1768e3          	bltu	a4,a7,14f80 <memcpy+0xf8>
   14f94:	00008067          	ret
   14f98:	00050713          	mv	a4,a0
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   14f9c:	ff1562e3          	bltu	a0,a7,14f80 <memcpy+0xf8>
   14fa0:	f55ff06f          	j	14ef4 <memcpy+0x6c>
   14fa4:	00008067          	ret

0000000000014fa8 <memset>:
   14fa8:	00f00813          	li	a6,15
   14fac:	00050713          	mv	a4,a0
   14fb0:	02c87a63          	bleu	a2,a6,14fe4 <memset+0x3c>
   14fb4:	00f77793          	andi	a5,a4,15
   14fb8:	0a079063          	bnez	a5,15058 <memset+0xb0>
   14fbc:	06059e63          	bnez	a1,15038 <memset+0x90>
   14fc0:	ff067693          	andi	a3,a2,-16
   14fc4:	00f67613          	andi	a2,a2,15
   14fc8:	00e686b3          	add	a3,a3,a4
   14fcc:	00b73023          	sd	a1,0(a4)
   14fd0:	00b73423          	sd	a1,8(a4)
   14fd4:	01070713          	addi	a4,a4,16
   14fd8:	fed76ae3          	bltu	a4,a3,14fcc <memset+0x24>
   14fdc:	00061463          	bnez	a2,14fe4 <memset+0x3c>
   14fe0:	00008067          	ret
   14fe4:	40c806b3          	sub	a3,a6,a2
   14fe8:	00269693          	slli	a3,a3,0x2
   14fec:	00000297          	auipc	t0,0x0
   14ff0:	005686b3          	add	a3,a3,t0
   14ff4:	00c68067          	jr	a3,12
   14ff8:	00b70723          	sb	a1,14(a4)
   14ffc:	00b706a3          	sb	a1,13(a4)
   15000:	00b70623          	sb	a1,12(a4)
   15004:	00b705a3          	sb	a1,11(a4)
   15008:	00b70523          	sb	a1,10(a4)
   1500c:	00b704a3          	sb	a1,9(a4)
   15010:	00b70423          	sb	a1,8(a4)
   15014:	00b703a3          	sb	a1,7(a4)
   15018:	00b70323          	sb	a1,6(a4)
   1501c:	00b702a3          	sb	a1,5(a4)
   15020:	00b70223          	sb	a1,4(a4)
   15024:	00b701a3          	sb	a1,3(a4)
   15028:	00b70123          	sb	a1,2(a4)
   1502c:	00b700a3          	sb	a1,1(a4)
   15030:	00b70023          	sb	a1,0(a4)
   15034:	00008067          	ret
   15038:	0ff5f593          	andi	a1,a1,255
   1503c:	00859693          	slli	a3,a1,0x8
   15040:	00d5e5b3          	or	a1,a1,a3
   15044:	01059693          	slli	a3,a1,0x10
   15048:	00d5e5b3          	or	a1,a1,a3
   1504c:	02059693          	slli	a3,a1,0x20
   15050:	00d5e5b3          	or	a1,a1,a3
   15054:	f6dff06f          	j	14fc0 <memset+0x18>
   15058:	00279693          	slli	a3,a5,0x2
   1505c:	00000297          	auipc	t0,0x0
   15060:	005686b3          	add	a3,a3,t0
   15064:	00008293          	mv	t0,ra
   15068:	f98680e7          	jalr	a3,-104
   1506c:	00028093          	mv	ra,t0
   15070:	ff078793          	addi	a5,a5,-16
   15074:	40f70733          	sub	a4,a4,a5
   15078:	00f60633          	add	a2,a2,a5
   1507c:	f6c874e3          	bleu	a2,a6,14fe4 <memset+0x3c>
   15080:	f3dff06f          	j	14fbc <memset+0x14>

0000000000015084 <__malloc_lock>:
   15084:	00008067          	ret

0000000000015088 <__malloc_unlock>:
}

void
__malloc_unlock (ptr)
     struct _reent *ptr;
{
   15088:	00008067          	ret

000000000001508c <_Balloc>:
{
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
   1508c:	07853783          	ld	a5,120(a0)
#define _Kmax 15
*/

_Bigint *
_DEFUN (Balloc, (ptr, k), struct _reent *ptr _AND int k)
{
   15090:	fe010113          	addi	sp,sp,-32
   15094:	00813823          	sd	s0,16(sp)
   15098:	00913423          	sd	s1,8(sp)
   1509c:	00113c23          	sd	ra,24(sp)
   150a0:	01213023          	sd	s2,0(sp)
   150a4:	00050413          	mv	s0,a0
   150a8:	00058493          	mv	s1,a1
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
   150ac:	02078e63          	beqz	a5,150e8 <_Balloc+0x5c>
	{
	  return NULL;
	}
    }

  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
   150b0:	00349513          	slli	a0,s1,0x3
   150b4:	00a787b3          	add	a5,a5,a0
   150b8:	0007b503          	ld	a0,0(a5)
   150bc:	04050663          	beqz	a0,15108 <_Balloc+0x7c>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
   150c0:	00053703          	ld	a4,0(a0)
   150c4:	00e7b023          	sd	a4,0(a5)
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
      rv->_k = k;
      rv->_maxwds = x;
    }
  rv->_sign = rv->_wds = 0;
   150c8:	00052a23          	sw	zero,20(a0)
   150cc:	00052823          	sw	zero,16(a0)
  return rv;
}
   150d0:	01813083          	ld	ra,24(sp)
   150d4:	01013403          	ld	s0,16(sp)
   150d8:	00813483          	ld	s1,8(sp)
   150dc:	00013903          	ld	s2,0(sp)
   150e0:	02010113          	addi	sp,sp,32
   150e4:	00008067          	ret

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
    {
      /* Allocate a list of pointers to the mprec objects */
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
   150e8:	04100613          	li	a2,65
   150ec:	00800593          	li	a1,8
   150f0:	638020ef          	jal	17728 <_calloc_r>
   150f4:	06a43c23          	sd	a0,120(s0)
   150f8:	00050793          	mv	a5,a0
						      sizeof (struct _Bigint *),
						      _Kmax + 1);
      if (_REENT_MP_FREELIST(ptr) == NULL)
   150fc:	fa051ae3          	bnez	a0,150b0 <_Balloc+0x24>
	{
	  return NULL;
   15100:	00000513          	li	a0,0
   15104:	fcdff06f          	j	150d0 <_Balloc+0x44>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
    }
  else
    {
      x = 1 << k;
   15108:	00100913          	li	s2,1
   1510c:	0099193b          	sllw	s2,s2,s1
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
   15110:	fff9061b          	addiw	a2,s2,-1
   15114:	00860613          	addi	a2,a2,8
   15118:	00261613          	slli	a2,a2,0x2
   1511c:	00100593          	li	a1,1
   15120:	00040513          	mv	a0,s0
   15124:	604020ef          	jal	17728 <_calloc_r>
				  1,
				  sizeof (_Bigint) +
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
   15128:	fc050ce3          	beqz	a0,15100 <_Balloc+0x74>
      rv->_k = k;
   1512c:	00952423          	sw	s1,8(a0)
      rv->_maxwds = x;
   15130:	01252623          	sw	s2,12(a0)
   15134:	f95ff06f          	j	150c8 <_Balloc+0x3c>

0000000000015138 <_Bfree>:

void
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
   15138:	02058063          	beqz	a1,15158 <_Bfree+0x20>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   1513c:	0085a783          	lw	a5,8(a1)
   15140:	07853703          	ld	a4,120(a0)
   15144:	00379793          	slli	a5,a5,0x3
   15148:	00f707b3          	add	a5,a4,a5
   1514c:	0007b703          	ld	a4,0(a5)
   15150:	00e5b023          	sd	a4,0(a1)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   15154:	00b7b023          	sd	a1,0(a5)
   15158:	00008067          	ret

000000000001515c <__multadd>:
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   1515c:	fc010113          	addi	sp,sp,-64
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   15160:	00010837          	lui	a6,0x10
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   15164:	02813823          	sd	s0,48(sp)
   15168:	02913423          	sd	s1,40(sp)
   1516c:	03213023          	sd	s2,32(sp)
   15170:	00058493          	mv	s1,a1
#ifdef Pack_32
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
   15174:	0145a403          	lw	s0,20(a1)
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   15178:	00050913          	mv	s2,a0
   1517c:	02113c23          	sd	ra,56(sp)
   15180:	01313c23          	sd	s3,24(sp)
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
  x = b->_x;
   15184:	01858593          	addi	a1,a1,24
  i = 0;
   15188:	00000513          	li	a0,0
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   1518c:	fff8081b          	addiw	a6,a6,-1
  x = b->_x;
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
   15190:	0005a783          	lw	a5,0(a1)
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   15194:	00458593          	addi	a1,a1,4
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
   15198:	0015051b          	addiw	a0,a0,1
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   1519c:	0107f733          	and	a4,a5,a6
   151a0:	02c7073b          	mulw	a4,a4,a2
      z = (xi >> 16) * m + (y >> 16);
   151a4:	0107d79b          	srliw	a5,a5,0x10
   151a8:	02c787bb          	mulw	a5,a5,a2
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   151ac:	00d7073b          	addw	a4,a4,a3
      z = (xi >> 16) * m + (y >> 16);
   151b0:	0107569b          	srliw	a3,a4,0x10
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   151b4:	01077733          	and	a4,a4,a6
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
   151b8:	00d786bb          	addw	a3,a5,a3
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   151bc:	0106979b          	slliw	a5,a3,0x10
   151c0:	00e7873b          	addw	a4,a5,a4
   151c4:	fee5ae23          	sw	a4,-4(a1)
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
      a = (int) (z >> 16);
   151c8:	0106d69b          	srliw	a3,a3,0x10
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
   151cc:	fc8542e3          	blt	a0,s0,15190 <__multadd+0x34>
  if (a)
   151d0:	02068263          	beqz	a3,151f4 <__multadd+0x98>
    {
      if (wds >= b->_maxwds)
   151d4:	00c4a783          	lw	a5,12(s1)
   151d8:	02f45e63          	ble	a5,s0,15214 <__multadd+0xb8>
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
	}
      b->_x[wds++] = a;
   151dc:	00440793          	addi	a5,s0,4
   151e0:	00279793          	slli	a5,a5,0x2
   151e4:	00f487b3          	add	a5,s1,a5
   151e8:	00d7a423          	sw	a3,8(a5)
      b->_wds = wds;
   151ec:	0014041b          	addiw	s0,s0,1
   151f0:	0084aa23          	sw	s0,20(s1)
    }
  return b;
}
   151f4:	03813083          	ld	ra,56(sp)
   151f8:	00048513          	mv	a0,s1
   151fc:	03013403          	ld	s0,48(sp)
   15200:	02813483          	ld	s1,40(sp)
   15204:	02013903          	ld	s2,32(sp)
   15208:	01813983          	ld	s3,24(sp)
   1520c:	04010113          	addi	sp,sp,64
   15210:	00008067          	ret
  while (++i < wds);
  if (a)
    {
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
   15214:	0084a583          	lw	a1,8(s1)
   15218:	00090513          	mv	a0,s2
   1521c:	00d13423          	sd	a3,8(sp)
   15220:	0015859b          	addiw	a1,a1,1
   15224:	e69ff0ef          	jal	1508c <_Balloc>
	  Bcopy (b1, b);
   15228:	0144a603          	lw	a2,20(s1)
  while (++i < wds);
  if (a)
    {
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
   1522c:	00050993          	mv	s3,a0
	  Bcopy (b1, b);
   15230:	01048593          	addi	a1,s1,16
   15234:	00260613          	addi	a2,a2,2
   15238:	01050513          	addi	a0,a0,16
   1523c:	00261613          	slli	a2,a2,0x2
   15240:	c49ff0ef          	jal	14e88 <memcpy>
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   15244:	0084a703          	lw	a4,8(s1)
   15248:	07893783          	ld	a5,120(s2)
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
   1524c:	00813683          	ld	a3,8(sp)
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   15250:	00371713          	slli	a4,a4,0x3
   15254:	00e787b3          	add	a5,a5,a4
   15258:	0007b703          	ld	a4,0(a5)
   1525c:	00e4b023          	sd	a4,0(s1)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   15260:	0097b023          	sd	s1,0(a5)
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
   15264:	00098493          	mv	s1,s3
   15268:	f75ff06f          	j	151dc <__multadd+0x80>

000000000001526c <__s2b>:
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   1526c:	fc010113          	addi	sp,sp,-64
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
   15270:	0086879b          	addiw	a5,a3,8
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   15274:	03213023          	sd	s2,32(sp)
   15278:	00068913          	mv	s2,a3
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
   1527c:	00900693          	li	a3,9
   15280:	02d7c6bb          	divw	a3,a5,a3
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   15284:	02813823          	sd	s0,48(sp)
   15288:	02913423          	sd	s1,40(sp)
   1528c:	01313c23          	sd	s3,24(sp)
   15290:	01413823          	sd	s4,16(sp)
   15294:	02113c23          	sd	ra,56(sp)
   15298:	01513423          	sd	s5,8(sp)
   1529c:	01613023          	sd	s6,0(sp)
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   152a0:	00100793          	li	a5,1
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   152a4:	00058413          	mv	s0,a1
   152a8:	00050993          	mv	s3,a0
   152ac:	00060a13          	mv	s4,a2
   152b0:	00070493          	mv	s1,a4
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   152b4:	00000593          	li	a1,0
   152b8:	00d7d863          	ble	a3,a5,152c8 <__s2b+0x5c>
   152bc:	0017979b          	slliw	a5,a5,0x1
   152c0:	0015859b          	addiw	a1,a1,1
   152c4:	fed7cce3          	blt	a5,a3,152bc <__s2b+0x50>
#ifdef Pack_32
  b = Balloc (ptr, k);
   152c8:	00098513          	mv	a0,s3
   152cc:	dc1ff0ef          	jal	1508c <_Balloc>
  b->_x[0] = y9;
  b->_wds = 1;
   152d0:	00100793          	li	a5,1
   152d4:	00f52a23          	sw	a5,20(a0)

  x = (nd + 8) / 9;
  for (k = 0, y = 1; x > y; y <<= 1, k++);
#ifdef Pack_32
  b = Balloc (ptr, k);
  b->_x[0] = y9;
   152d8:	00952c23          	sw	s1,24(a0)
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
  if (9 < nd0)
   152dc:	00900793          	li	a5,9
   152e0:	0b47d663          	ble	s4,a5,1538c <__s2b+0x120>
   152e4:	ff6a0b1b          	addiw	s6,s4,-10
   152e8:	020b1b13          	slli	s6,s6,0x20
   152ec:	020b5b13          	srli	s6,s6,0x20
    {
      s += 9;
   152f0:	00940a93          	addi	s5,s0,9
   152f4:	00ab0793          	addi	a5,s6,10
   152f8:	00f40433          	add	s0,s0,a5
   152fc:	000a8493          	mv	s1,s5
      do
	b = multadd (ptr, b, 10, *s++ - '0');
   15300:	00148493          	addi	s1,s1,1
   15304:	fff4c683          	lbu	a3,-1(s1)
   15308:	00050593          	mv	a1,a0
   1530c:	00a00613          	li	a2,10
   15310:	fd06869b          	addiw	a3,a3,-48
   15314:	00098513          	mv	a0,s3
   15318:	e45ff0ef          	jal	1515c <__multadd>
      while (++i < nd0);
   1531c:	fe8492e3          	bne	s1,s0,15300 <__s2b+0x94>
   15320:	016a8433          	add	s0,s5,s6
      s++;
   15324:	00240413          	addi	s0,s0,2
    }
  else
    s += 10;
  for (; i < nd; i++)
   15328:	032a5e63          	ble	s2,s4,15364 <__s2b+0xf8>
   1532c:	fff9091b          	addiw	s2,s2,-1
   15330:	414904bb          	subw	s1,s2,s4
   15334:	02049493          	slli	s1,s1,0x20
   15338:	0204d493          	srli	s1,s1,0x20
   1533c:	00148493          	addi	s1,s1,1
   15340:	009404b3          	add	s1,s0,s1
    b = multadd (ptr, b, 10, *s++ - '0');
   15344:	00140413          	addi	s0,s0,1
   15348:	fff44683          	lbu	a3,-1(s0)
   1534c:	00050593          	mv	a1,a0
   15350:	00a00613          	li	a2,10
   15354:	fd06869b          	addiw	a3,a3,-48
   15358:	00098513          	mv	a0,s3
   1535c:	e01ff0ef          	jal	1515c <__multadd>
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
  for (; i < nd; i++)
   15360:	fe9412e3          	bne	s0,s1,15344 <__s2b+0xd8>
    b = multadd (ptr, b, 10, *s++ - '0');
  return b;
}
   15364:	03813083          	ld	ra,56(sp)
   15368:	03013403          	ld	s0,48(sp)
   1536c:	02813483          	ld	s1,40(sp)
   15370:	02013903          	ld	s2,32(sp)
   15374:	01813983          	ld	s3,24(sp)
   15378:	01013a03          	ld	s4,16(sp)
   1537c:	00813a83          	ld	s5,8(sp)
   15380:	00013b03          	ld	s6,0(sp)
   15384:	04010113          	addi	sp,sp,64
   15388:	00008067          	ret
	b = multadd (ptr, b, 10, *s++ - '0');
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
   1538c:	00a40413          	addi	s0,s0,10
  b = Balloc (ptr, k + 1);
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
   15390:	00078a13          	mv	s4,a5
   15394:	f95ff06f          	j	15328 <__s2b+0xbc>

0000000000015398 <__hi0bits>:
_DEFUN (hi0bits,
	(x), register __ULong x)
{
  register int k = 0;

  if (!(x & 0xffff0000))
   15398:	ffff06b7          	lui	a3,0xffff0
   1539c:	00d576b3          	and	a3,a0,a3
}

int
_DEFUN (hi0bits,
	(x), register __ULong x)
{
   153a0:	00050793          	mv	a5,a0
  register int k = 0;
   153a4:	00000713          	li	a4,0

  if (!(x & 0xffff0000))
   153a8:	00069663          	bnez	a3,153b4 <__hi0bits+0x1c>
    {
      k = 16;
      x <<= 16;
   153ac:	0105179b          	slliw	a5,a0,0x10
{
  register int k = 0;

  if (!(x & 0xffff0000))
    {
      k = 16;
   153b0:	01000713          	li	a4,16
      x <<= 16;
    }
  if (!(x & 0xff000000))
   153b4:	ff0006b7          	lui	a3,0xff000
   153b8:	00d7f6b3          	and	a3,a5,a3
   153bc:	00069663          	bnez	a3,153c8 <__hi0bits+0x30>
    {
      k += 8;
   153c0:	0087071b          	addiw	a4,a4,8
      x <<= 8;
   153c4:	0087979b          	slliw	a5,a5,0x8
    }
  if (!(x & 0xf0000000))
   153c8:	f00006b7          	lui	a3,0xf0000
   153cc:	00d7f6b3          	and	a3,a5,a3
   153d0:	00069663          	bnez	a3,153dc <__hi0bits+0x44>
    {
      k += 4;
   153d4:	0047071b          	addiw	a4,a4,4
      x <<= 4;
   153d8:	0047979b          	slliw	a5,a5,0x4
    }
  if (!(x & 0xc0000000))
   153dc:	c00006b7          	lui	a3,0xc0000
   153e0:	00d7f6b3          	and	a3,a5,a3
   153e4:	00069663          	bnez	a3,153f0 <__hi0bits+0x58>
    {
      k += 2;
   153e8:	0027071b          	addiw	a4,a4,2
      x <<= 2;
   153ec:	0027979b          	slliw	a5,a5,0x2
    }
  if (!(x & 0x80000000))
   153f0:	0007ce63          	bltz	a5,1540c <__hi0bits+0x74>
    {
      k++;
      if (!(x & 0x40000000))
   153f4:	02179693          	slli	a3,a5,0x21
	return 32;
   153f8:	02000513          	li	a0,32
      x <<= 2;
    }
  if (!(x & 0x80000000))
    {
      k++;
      if (!(x & 0x40000000))
   153fc:	0006c463          	bltz	a3,15404 <__hi0bits+0x6c>
	return 32;
    }
  return k;
}
   15400:	00008067          	ret
      k += 2;
      x <<= 2;
    }
  if (!(x & 0x80000000))
    {
      k++;
   15404:	0017051b          	addiw	a0,a4,1
   15408:	00008067          	ret
   1540c:	00070513          	mv	a0,a4
      if (!(x & 0x40000000))
	return 32;
    }
  return k;
}
   15410:	00008067          	ret

0000000000015414 <__lo0bits>:

int
_DEFUN (lo0bits, (y), __ULong *y)
{
  register int k;
  register __ULong x = *y;
   15414:	00052783          	lw	a5,0(a0)
  return k;
}

int
_DEFUN (lo0bits, (y), __ULong *y)
{
   15418:	00050693          	mv	a3,a0
  register int k;
  register __ULong x = *y;

  if (x & 7)
   1541c:	0077f713          	andi	a4,a5,7
   15420:	02070463          	beqz	a4,15448 <__lo0bits+0x34>
    {
      if (x & 1)
   15424:	0017f713          	andi	a4,a5,1
	return 0;
   15428:	00000513          	li	a0,0
  register int k;
  register __ULong x = *y;

  if (x & 7)
    {
      if (x & 1)
   1542c:	08071263          	bnez	a4,154b0 <__lo0bits+0x9c>
	return 0;
      if (x & 2)
   15430:	0027f713          	andi	a4,a5,2
   15434:	08071063          	bnez	a4,154b4 <__lo0bits+0xa0>
	{
	  *y = x >> 1;
	  return 1;
	}
      *y = x >> 2;
   15438:	0027d79b          	srliw	a5,a5,0x2
   1543c:	00f6a023          	sw	a5,0(a3) # ffffffffc0000000 <_gp+0xffffffffbffe4530>
      return 2;
   15440:	00200513          	li	a0,2
   15444:	00008067          	ret
    }
  k = 0;
  if (!(x & 0xffff))
   15448:	0107961b          	slliw	a2,a5,0x10
   1544c:	0106561b          	srliw	a2,a2,0x10
	  return 1;
	}
      *y = x >> 2;
      return 2;
    }
  k = 0;
   15450:	00000713          	li	a4,0
  if (!(x & 0xffff))
   15454:	00061663          	bnez	a2,15460 <__lo0bits+0x4c>
    {
      k = 16;
      x >>= 16;
   15458:	0107d79b          	srliw	a5,a5,0x10
      return 2;
    }
  k = 0;
  if (!(x & 0xffff))
    {
      k = 16;
   1545c:	01000713          	li	a4,16
      x >>= 16;
    }
  if (!(x & 0xff))
   15460:	0ff7f613          	andi	a2,a5,255
   15464:	00061663          	bnez	a2,15470 <__lo0bits+0x5c>
    {
      k += 8;
   15468:	0087071b          	addiw	a4,a4,8
      x >>= 8;
   1546c:	0087d79b          	srliw	a5,a5,0x8
    }
  if (!(x & 0xf))
   15470:	00f7f613          	andi	a2,a5,15
   15474:	00061663          	bnez	a2,15480 <__lo0bits+0x6c>
    {
      k += 4;
   15478:	0047071b          	addiw	a4,a4,4
      x >>= 4;
   1547c:	0047d79b          	srliw	a5,a5,0x4
    }
  if (!(x & 0x3))
   15480:	0037f613          	andi	a2,a5,3
   15484:	00061663          	bnez	a2,15490 <__lo0bits+0x7c>
    {
      k += 2;
   15488:	0027071b          	addiw	a4,a4,2
      x >>= 2;
   1548c:	0027d79b          	srliw	a5,a5,0x2
    }
  if (!(x & 1))
   15490:	0017f613          	andi	a2,a5,1
   15494:	00061a63          	bnez	a2,154a8 <__lo0bits+0x94>
    {
      k++;
      x >>= 1;
   15498:	0017d79b          	srliw	a5,a5,0x1
      if (!x & 1)
	return 32;
   1549c:	02000513          	li	a0,32
    }
  if (!(x & 1))
    {
      k++;
      x >>= 1;
      if (!x & 1)
   154a0:	00078863          	beqz	a5,154b0 <__lo0bits+0x9c>
      k += 2;
      x >>= 2;
    }
  if (!(x & 1))
    {
      k++;
   154a4:	0017071b          	addiw	a4,a4,1
      x >>= 1;
      if (!x & 1)
	return 32;
    }
  *y = x;
   154a8:	00f6a023          	sw	a5,0(a3)
  return k;
   154ac:	00070513          	mv	a0,a4
}
   154b0:	00008067          	ret
    {
      if (x & 1)
	return 0;
      if (x & 2)
	{
	  *y = x >> 1;
   154b4:	0017d79b          	srliw	a5,a5,0x1
   154b8:	00f6a023          	sw	a5,0(a3)
	  return 1;
   154bc:	00100513          	li	a0,1
   154c0:	00008067          	ret

00000000000154c4 <__i2b>:
  return k;
}

_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
   154c4:	ff010113          	addi	sp,sp,-16
   154c8:	00813023          	sd	s0,0(sp)
   154cc:	00058413          	mv	s0,a1
  _Bigint *b;

  b = Balloc (ptr, 1);
   154d0:	00100593          	li	a1,1
  return k;
}

_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
   154d4:	00113423          	sd	ra,8(sp)
  _Bigint *b;

  b = Balloc (ptr, 1);
   154d8:	bb5ff0ef          	jal	1508c <_Balloc>
  b->_x[0] = i;
  b->_wds = 1;
  return b;
}
   154dc:	00813083          	ld	ra,8(sp)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
  b->_x[0] = i;
  b->_wds = 1;
   154e0:	00100713          	li	a4,1
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
  b->_x[0] = i;
   154e4:	00852c23          	sw	s0,24(a0)
  b->_wds = 1;
   154e8:	00e52a23          	sw	a4,20(a0)
  return b;
}
   154ec:	00013403          	ld	s0,0(sp)
   154f0:	01010113          	addi	sp,sp,16
   154f4:	00008067          	ret

00000000000154f8 <__multiply>:

_Bigint *
_DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b)
{
   154f8:	fd010113          	addi	sp,sp,-48
   154fc:	01313423          	sd	s3,8(sp)
   15500:	01413023          	sd	s4,0(sp)
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
   15504:	0145a983          	lw	s3,20(a1)
   15508:	01462a03          	lw	s4,20(a2)
  return b;
}

_Bigint *
_DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b)
{
   1550c:	00913c23          	sd	s1,24(sp)
   15510:	01213823          	sd	s2,16(sp)
   15514:	02113423          	sd	ra,40(sp)
   15518:	02813023          	sd	s0,32(sp)
   1551c:	00058913          	mv	s2,a1
   15520:	00060493          	mv	s1,a2
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
   15524:	0149dc63          	ble	s4,s3,1553c <__multiply+0x44>
   15528:	00098713          	mv	a4,s3
   1552c:	00060913          	mv	s2,a2
   15530:	000a0993          	mv	s3,s4
   15534:	00058493          	mv	s1,a1
   15538:	00070a13          	mv	s4,a4
    }
  k = a->_k;
  wa = a->_wds;
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
   1553c:	00c92783          	lw	a5,12(s2)
    {
      c = a;
      a = b;
      b = c;
    }
  k = a->_k;
   15540:	00892583          	lw	a1,8(s2)
  wa = a->_wds;
  wb = b->_wds;
  wc = wa + wb;
   15544:	0149843b          	addw	s0,s3,s4
  if (wc > a->_maxwds)
    k++;
   15548:	0087a7b3          	slt	a5,a5,s0
  c = Balloc (ptr, k);
   1554c:	00f585bb          	addw	a1,a1,a5
   15550:	b3dff0ef          	jal	1508c <_Balloc>
  for (x = c->_x, xa = x + wc; x < xa; x++)
   15554:	00040893          	mv	a7,s0
   15558:	01850313          	addi	t1,a0,24
   1555c:	00289893          	slli	a7,a7,0x2
   15560:	011308b3          	add	a7,t1,a7
   15564:	00030793          	mv	a5,t1
   15568:	01137863          	bleu	a7,t1,15578 <__multiply+0x80>
    *x = 0;
   1556c:	0007a023          	sw	zero,0(a5)
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
   15570:	00478793          	addi	a5,a5,4
   15574:	ff17ece3          	bltu	a5,a7,1556c <__multiply+0x74>
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
  xb = b->_x;
   15578:	01848613          	addi	a2,s1,24
  xbe = xb + wb;
   1557c:	002a1e13          	slli	t3,s4,0x2
  if (wc > a->_maxwds)
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
   15580:	01890e93          	addi	t4,s2,24
  xae = xa + wa;
   15584:	00299813          	slli	a6,s3,0x2
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
    {
      if ((y = *xb & 0xffff) != 0)
   15588:	000105b7          	lui	a1,0x10
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
   1558c:	01c60e33          	add	t3,a2,t3
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
   15590:	010e8833          	add	a6,t4,a6
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
    {
      if ((y = *xb & 0xffff) != 0)
   15594:	fff5859b          	addiw	a1,a1,-1
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   15598:	11c67463          	bleu	t3,a2,156a0 <__multiply+0x1a8>
    {
      if ((y = *xb & 0xffff) != 0)
   1559c:	00062383          	lw	t2,0(a2)
   155a0:	00b3f4b3          	and	s1,t2,a1
   155a4:	06048a63          	beqz	s1,15618 <__multiply+0x120>
   155a8:	00030293          	mv	t0,t1
   155ac:	000e8f93          	mv	t6,t4
   155b0:	00000793          	li	a5,0
   155b4:	0080006f          	j	155bc <__multiply+0xc4>
   155b8:	00038293          	mv	t0,t2
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   155bc:	000fa683          	lw	a3,0(t6)
   155c0:	0002af03          	lw	t5,0(t0) # 1505c <memset+0xb4>
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   155c4:	00428393          	addi	t2,t0,4
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   155c8:	00b6f733          	and	a4,a3,a1
   155cc:	0297073b          	mulw	a4,a4,s1
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   155d0:	0106d69b          	srliw	a3,a3,0x10
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   155d4:	00bf7933          	and	s2,t5,a1
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   155d8:	010f5f1b          	srliw	t5,t5,0x10
   155dc:	004f8f93          	addi	t6,t6,4
   155e0:	029686bb          	mulw	a3,a3,s1
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   155e4:	0127073b          	addw	a4,a4,s2
   155e8:	00f707bb          	addw	a5,a4,a5
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   155ec:	0107d71b          	srliw	a4,a5,0x10
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   155f0:	00b7f7b3          	and	a5,a5,a1
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   155f4:	01e686bb          	addw	a3,a3,t5
   155f8:	00e6873b          	addw	a4,a3,a4
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   155fc:	0107169b          	slliw	a3,a4,0x10
   15600:	00f6e7b3          	or	a5,a3,a5
   15604:	fef3ae23          	sw	a5,-4(t2)
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
	      carry = z2 >> 16;
   15608:	0107579b          	srliw	a5,a4,0x10
	      Storeinc (xc, z2, z);
	    }
	  while (x < xae);
   1560c:	fb0fe6e3          	bltu	t6,a6,155b8 <__multiply+0xc0>
	  *xc = carry;
   15610:	00f2a223          	sw	a5,4(t0)
   15614:	00062383          	lw	t2,0(a2)
	}
      if ((y = *xb >> 16) != 0)
   15618:	0103d39b          	srliw	t2,t2,0x10
   1561c:	06038c63          	beqz	t2,15694 <__multiply+0x19c>
	{
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
   15620:	00032783          	lw	a5,0(t1) # 10000 <_ftext>
   15624:	00030293          	mv	t0,t1
	  while (x < xae);
	  *xc = carry;
	}
      if ((y = *xb >> 16) != 0)
	{
	  x = xa;
   15628:	000e8f93          	mv	t6,t4
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
   1562c:	00078f13          	mv	t5,a5
	}
      if ((y = *xb >> 16) != 0)
	{
	  x = xa;
	  xc = xc0;
	  carry = 0;
   15630:	00000693          	li	a3,0
   15634:	0080006f          	j	1563c <__multiply+0x144>
   15638:	00048293          	mv	t0,s1
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   1563c:	000fa703          	lw	a4,0(t6)
   15640:	010f5f1b          	srliw	t5,t5,0x10
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   15644:	00b7f7b3          	and	a5,a5,a1
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   15648:	00b77733          	and	a4,a4,a1
   1564c:	0277073b          	mulw	a4,a4,t2
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   15650:	00428493          	addi	s1,t0,4
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   15654:	004f8f93          	addi	t6,t6,4
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   15658:	01e7073b          	addw	a4,a4,t5
   1565c:	00d706bb          	addw	a3,a4,a3
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   15660:	0106971b          	slliw	a4,a3,0x10
   15664:	00f767b3          	or	a5,a4,a5
   15668:	fef4ae23          	sw	a5,-4(s1)
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   1566c:	ffefd703          	lhu	a4,-2(t6)
   15670:	0042af03          	lw	t5,4(t0)
   15674:	0106d69b          	srliw	a3,a3,0x10
   15678:	0277073b          	mulw	a4,a4,t2
   1567c:	00bf77b3          	and	a5,t5,a1
   15680:	00f707bb          	addw	a5,a4,a5
   15684:	00d787bb          	addw	a5,a5,a3
	      carry = z2 >> 16;
   15688:	0107d69b          	srliw	a3,a5,0x10
	    }
	  while (x < xae);
   1568c:	fb0fe6e3          	bltu	t6,a6,15638 <__multiply+0x140>
	  *xc = z2;
   15690:	00f2a223          	sw	a5,4(t0)
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   15694:	00460613          	addi	a2,a2,4
   15698:	00430313          	addi	t1,t1,4
   1569c:	f1c660e3          	bltu	a2,t3,1559c <__multiply+0xa4>
	  while (x < xae);
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
   156a0:	02805463          	blez	s0,156c8 <__multiply+0x1d0>
   156a4:	ffc8a783          	lw	a5,-4(a7)
   156a8:	ffc88893          	addi	a7,a7,-4
   156ac:	00078863          	beqz	a5,156bc <__multiply+0x1c4>
   156b0:	0180006f          	j	156c8 <__multiply+0x1d0>
   156b4:	0008a783          	lw	a5,0(a7)
   156b8:	00079863          	bnez	a5,156c8 <__multiply+0x1d0>
   156bc:	fff4041b          	addiw	s0,s0,-1
   156c0:	ffc88893          	addi	a7,a7,-4
   156c4:	fe0418e3          	bnez	s0,156b4 <__multiply+0x1bc>
  c->_wds = wc;
  return c;
}
   156c8:	02813083          	ld	ra,40(sp)
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
  c->_wds = wc;
   156cc:	00852a23          	sw	s0,20(a0)
  return c;
}
   156d0:	01813483          	ld	s1,24(sp)
   156d4:	02013403          	ld	s0,32(sp)
   156d8:	01013903          	ld	s2,16(sp)
   156dc:	00813983          	ld	s3,8(sp)
   156e0:	00013a03          	ld	s4,0(sp)
   156e4:	03010113          	addi	sp,sp,48
   156e8:	00008067          	ret

00000000000156ec <__pow5mult>:

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   156ec:	fd010113          	addi	sp,sp,-48
   156f0:	02813023          	sd	s0,32(sp)
   156f4:	01213823          	sd	s2,16(sp)
   156f8:	01313423          	sd	s3,8(sp)
   156fc:	02113423          	sd	ra,40(sp)
   15700:	00913c23          	sd	s1,24(sp)
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
   15704:	00367793          	andi	a5,a2,3
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   15708:	00060413          	mv	s0,a2
   1570c:	00050993          	mv	s3,a0
   15710:	00058913          	mv	s2,a1
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
   15714:	0a079e63          	bnez	a5,157d0 <__pow5mult+0xe4>
    b = multadd (ptr, b, p05[i - 1], 0);

  if (!(k >>= 2))
   15718:	4024541b          	sraiw	s0,s0,0x2
   1571c:	06040663          	beqz	s0,15788 <__pow5mult+0x9c>
    return b;
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
   15720:	0709b483          	ld	s1,112(s3)
   15724:	0c048a63          	beqz	s1,157f8 <__pow5mult+0x10c>
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
      p5->_next = 0;
    }
  for (;;)
    {
      if (k & 1)
   15728:	00147793          	andi	a5,s0,1
   1572c:	02079063          	bnez	a5,1574c <__pow5mult+0x60>
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
	}
      if (!(k >>= 1))
   15730:	4014541b          	sraiw	s0,s0,0x1
   15734:	04040a63          	beqz	s0,15788 <__pow5mult+0x9c>
	break;
      if (!(p51 = p5->_next))
   15738:	0004b503          	ld	a0,0(s1)
   1573c:	06050663          	beqz	a0,157a8 <__pow5mult+0xbc>
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   15740:	00050493          	mv	s1,a0
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
      p5->_next = 0;
    }
  for (;;)
    {
      if (k & 1)
   15744:	00147793          	andi	a5,s0,1
   15748:	fe0784e3          	beqz	a5,15730 <__pow5mult+0x44>
	{
	  b1 = mult (ptr, b, p5);
   1574c:	00048613          	mv	a2,s1
   15750:	00090593          	mv	a1,s2
   15754:	00098513          	mv	a0,s3
   15758:	da1ff0ef          	jal	154f8 <__multiply>

void
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
   1575c:	06090663          	beqz	s2,157c8 <__pow5mult+0xdc>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   15760:	00892783          	lw	a5,8(s2)
   15764:	0789b703          	ld	a4,120(s3)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
	}
      if (!(k >>= 1))
   15768:	4014541b          	sraiw	s0,s0,0x1
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   1576c:	00379793          	slli	a5,a5,0x3
   15770:	00f707b3          	add	a5,a4,a5
   15774:	0007b703          	ld	a4,0(a5)
   15778:	00e93023          	sd	a4,0(s2)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   1577c:	0127b023          	sd	s2,0(a5)
    {
      if (k & 1)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
   15780:	00050913          	mv	s2,a0
	}
      if (!(k >>= 1))
   15784:	fa041ae3          	bnez	s0,15738 <__pow5mult+0x4c>
	  p51->_next = 0;
	}
      p5 = p51;
    }
  return b;
}
   15788:	02813083          	ld	ra,40(sp)
   1578c:	00090513          	mv	a0,s2
   15790:	02013403          	ld	s0,32(sp)
   15794:	01813483          	ld	s1,24(sp)
   15798:	01013903          	ld	s2,16(sp)
   1579c:	00813983          	ld	s3,8(sp)
   157a0:	03010113          	addi	sp,sp,48
   157a4:	00008067          	ret
	}
      if (!(k >>= 1))
	break;
      if (!(p51 = p5->_next))
	{
	  p51 = p5->_next = mult (ptr, p5, p5);
   157a8:	00048613          	mv	a2,s1
   157ac:	00048593          	mv	a1,s1
   157b0:	00098513          	mv	a0,s3
   157b4:	d45ff0ef          	jal	154f8 <__multiply>
   157b8:	00a4b023          	sd	a0,0(s1)
	  p51->_next = 0;
   157bc:	00053023          	sd	zero,0(a0)
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   157c0:	00050493          	mv	s1,a0
   157c4:	f81ff06f          	j	15744 <__pow5mult+0x58>
    {
      if (k & 1)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
   157c8:	00050913          	mv	s2,a0
   157cc:	f65ff06f          	j	15730 <__pow5mult+0x44>
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
    b = multadd (ptr, b, p05[i - 1], 0);
   157d0:	fff7879b          	addiw	a5,a5,-1
   157d4:	00019737          	lui	a4,0x19
   157d8:	f5070713          	addi	a4,a4,-176 # 18f50 <p05.2568>
   157dc:	00279793          	slli	a5,a5,0x2
   157e0:	00f707b3          	add	a5,a4,a5
   157e4:	0007a603          	lw	a2,0(a5)
   157e8:	00000693          	li	a3,0
   157ec:	971ff0ef          	jal	1515c <__multadd>
   157f0:	00050913          	mv	s2,a0
   157f4:	f25ff06f          	j	15718 <__pow5mult+0x2c>
_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
   157f8:	00100593          	li	a1,1
   157fc:	00098513          	mv	a0,s3
   15800:	88dff0ef          	jal	1508c <_Balloc>
  b->_x[0] = i;
   15804:	27100793          	li	a5,625
   15808:	00f52c23          	sw	a5,24(a0)
  b->_wds = 1;
   1580c:	00100793          	li	a5,1
   15810:	00f52a23          	sw	a5,20(a0)
    return b;
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
    {
      /* first time */
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
   15814:	06a9b823          	sd	a0,112(s3)
_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
   15818:	00050493          	mv	s1,a0
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
    {
      /* first time */
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
      p5->_next = 0;
   1581c:	00053023          	sd	zero,0(a0)
   15820:	f09ff06f          	j	15728 <__pow5mult+0x3c>

0000000000015824 <__lshift>:
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   15824:	fc010113          	addi	sp,sp,-64
   15828:	01513423          	sd	s5,8(sp)
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   1582c:	0145aa83          	lw	s5,20(a1) # 10014 <_ftext+0x14>
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   15830:	02813823          	sd	s0,48(sp)
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   15834:	00c5a783          	lw	a5,12(a1)
  int i, k1, n, n1;
  _Bigint *b1;
  __ULong *x, *x1, *xe, z;

#ifdef Pack_32
  n = k >> 5;
   15838:	4056541b          	sraiw	s0,a2,0x5
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   1583c:	01540abb          	addw	s5,s0,s5
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   15840:	02913423          	sd	s1,40(sp)
   15844:	03213023          	sd	s2,32(sp)
   15848:	01313c23          	sd	s3,24(sp)
   1584c:	01413823          	sd	s4,16(sp)
   15850:	02113c23          	sd	ra,56(sp)
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   15854:	001a849b          	addiw	s1,s5,1
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   15858:	00058913          	mv	s2,a1
   1585c:	00060993          	mv	s3,a2
   15860:	00050a13          	mv	s4,a0
#ifdef Pack_32
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
   15864:	0085a583          	lw	a1,8(a1)
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   15868:	0097d863          	ble	s1,a5,15878 <__lshift+0x54>
   1586c:	0017979b          	slliw	a5,a5,0x1
    k1++;
   15870:	0015859b          	addiw	a1,a1,1
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   15874:	fe97cce3          	blt	a5,s1,1586c <__lshift+0x48>
    k1++;
  b1 = Balloc (ptr, k1);
   15878:	000a0513          	mv	a0,s4
   1587c:	811ff0ef          	jal	1508c <_Balloc>
  x1 = b1->_x;
   15880:	01850793          	addi	a5,a0,24
  for (i = 0; i < n; i++)
   15884:	0e805c63          	blez	s0,1597c <__lshift+0x158>
   15888:	fff4071b          	addiw	a4,s0,-1
   1588c:	02071713          	slli	a4,a4,0x20
   15890:	02075713          	srli	a4,a4,0x20
   15894:	00170713          	addi	a4,a4,1
   15898:	00271713          	slli	a4,a4,0x2
   1589c:	00e78733          	add	a4,a5,a4
    *x1++ = 0;
   158a0:	00478793          	addi	a5,a5,4
   158a4:	fe07ae23          	sw	zero,-4(a5)
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
   158a8:	fee79ce3          	bne	a5,a4,158a0 <__lshift+0x7c>
    *x1++ = 0;
  x = b->_x;
  xe = x + b->_wds;
   158ac:	01492883          	lw	a7,20(s2)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
    *x1++ = 0;
  x = b->_x;
   158b0:	01890793          	addi	a5,s2,24
  xe = x + b->_wds;
#ifdef Pack_32
  if (k &= 0x1f)
   158b4:	01f9f613          	andi	a2,s3,31
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
    *x1++ = 0;
  x = b->_x;
  xe = x + b->_wds;
   158b8:	00289893          	slli	a7,a7,0x2
   158bc:	011788b3          	add	a7,a5,a7
#ifdef Pack_32
  if (k &= 0x1f)
   158c0:	08060863          	beqz	a2,15950 <__lshift+0x12c>
    {
      k1 = 32 - k;
   158c4:	02000313          	li	t1,32
   158c8:	40c3033b          	subw	t1,t1,a2
      z = 0;
   158cc:	00000693          	li	a3,0
   158d0:	0080006f          	j	158d8 <__lshift+0xb4>
   158d4:	00080713          	mv	a4,a6
      do
	{
	  *x1++ = *x << k | z;
   158d8:	0007a583          	lw	a1,0(a5)
   158dc:	00470813          	addi	a6,a4,4
	  z = *x++ >> k1;
   158e0:	00478793          	addi	a5,a5,4
    {
      k1 = 32 - k;
      z = 0;
      do
	{
	  *x1++ = *x << k | z;
   158e4:	00c595bb          	sllw	a1,a1,a2
   158e8:	00d5e6b3          	or	a3,a1,a3
   158ec:	fed82e23          	sw	a3,-4(a6) # fffc <_ftext-0x4>
	  z = *x++ >> k1;
   158f0:	ffc7a683          	lw	a3,-4(a5)
   158f4:	0066d6bb          	srlw	a3,a3,t1
	}
      while (x < xe);
   158f8:	fd17eee3          	bltu	a5,a7,158d4 <__lshift+0xb0>
      if ((*x1 = z) != 0)
   158fc:	00d72223          	sw	a3,4(a4)
   15900:	00068463          	beqz	a3,15908 <__lshift+0xe4>
	++n1;
   15904:	002a849b          	addiw	s1,s5,2
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   15908:	00892783          	lw	a5,8(s2)
   1590c:	078a3703          	ld	a4,120(s4)
#endif
  else
    do
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
   15910:	fff4849b          	addiw	s1,s1,-1
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   15914:	00379793          	slli	a5,a5,0x3
   15918:	00f707b3          	add	a5,a4,a5
   1591c:	0007b703          	ld	a4,0(a5)
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   15920:	03813083          	ld	ra,56(sp)
#endif
  else
    do
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
   15924:	00952a23          	sw	s1,20(a0)
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   15928:	00e93023          	sd	a4,0(s2)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   1592c:	0127b023          	sd	s2,0(a5)
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   15930:	03013403          	ld	s0,48(sp)
   15934:	02813483          	ld	s1,40(sp)
   15938:	02013903          	ld	s2,32(sp)
   1593c:	01813983          	ld	s3,24(sp)
   15940:	01013a03          	ld	s4,16(sp)
   15944:	00813a83          	ld	s5,8(sp)
   15948:	04010113          	addi	sp,sp,64
   1594c:	00008067          	ret
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
   15950:	00478793          	addi	a5,a5,4
   15954:	ffc7a683          	lw	a3,-4(a5)
   15958:	00470713          	addi	a4,a4,4
   1595c:	fed72e23          	sw	a3,-4(a4)
    while (x < xe);
   15960:	fb17f4e3          	bleu	a7,a5,15908 <__lshift+0xe4>
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
   15964:	00478793          	addi	a5,a5,4
   15968:	ffc7a683          	lw	a3,-4(a5)
   1596c:	00470713          	addi	a4,a4,4
   15970:	fed72e23          	sw	a3,-4(a4)
    while (x < xe);
   15974:	fd17eee3          	bltu	a5,a7,15950 <__lshift+0x12c>
   15978:	f91ff06f          	j	15908 <__lshift+0xe4>
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
   1597c:	00078713          	mv	a4,a5
   15980:	f2dff06f          	j	158ac <__lshift+0x88>

0000000000015984 <__mcmp>:
_DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
{
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
   15984:	01452783          	lw	a5,20(a0)
  j = b->_wds;
   15988:	0145a703          	lw	a4,20(a1)
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   1598c:	40e787bb          	subw	a5,a5,a4
   15990:	04079263          	bnez	a5,159d4 <__mcmp+0x50>
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   15994:	00271713          	slli	a4,a4,0x2
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
   15998:	01850513          	addi	a0,a0,24
  xa = xa0 + j;
  xb0 = b->_x;
   1599c:	01858593          	addi	a1,a1,24
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   159a0:	00e507b3          	add	a5,a0,a4
  xb0 = b->_x;
  xb = xb0 + j;
   159a4:	00e585b3          	add	a1,a1,a4
   159a8:	0080006f          	j	159b0 <__mcmp+0x2c>
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
   159ac:	02f57863          	bleu	a5,a0,159dc <__mcmp+0x58>
  xa = xa0 + j;
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
   159b0:	ffc78793          	addi	a5,a5,-4
   159b4:	ffc58593          	addi	a1,a1,-4
   159b8:	0007a703          	lw	a4,0(a5)
   159bc:	0005a683          	lw	a3,0(a1)
   159c0:	fed706e3          	beq	a4,a3,159ac <__mcmp+0x28>
	return *xa < *xb ? -1 : 1;
   159c4:	00d737b3          	sltu	a5,a4,a3
   159c8:	40f007bb          	negw	a5,a5
   159cc:	0017e513          	ori	a0,a5,1
   159d0:	00008067          	ret
   159d4:	00078513          	mv	a0,a5
      if (xa <= xa0)
	break;
    }
  return 0;
}
   159d8:	00008067          	ret
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
	break;
    }
  return 0;
   159dc:	00000513          	li	a0,0
   159e0:	00008067          	ret

00000000000159e4 <__mdiff>:
_DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
{
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
   159e4:	0145a703          	lw	a4,20(a1)
  j = b->_wds;
   159e8:	01462783          	lw	a5,20(a2)
}

_Bigint *
_DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
	_Bigint * a _AND _Bigint * b)
{
   159ec:	fd010113          	addi	sp,sp,-48
   159f0:	01213823          	sd	s2,16(sp)
   159f4:	01313423          	sd	s3,8(sp)
   159f8:	02113423          	sd	ra,40(sp)
   159fc:	02813023          	sd	s0,32(sp)
   15a00:	00913c23          	sd	s1,24(sp)
   15a04:	01413023          	sd	s4,0(sp)
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   15a08:	40f7073b          	subw	a4,a4,a5
}

_Bigint *
_DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
	_Bigint * a _AND _Bigint * b)
{
   15a0c:	00058913          	mv	s2,a1
   15a10:	00060993          	mv	s3,a2
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   15a14:	04071863          	bnez	a4,15a64 <__mdiff+0x80>
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   15a18:	00279713          	slli	a4,a5,0x2
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
   15a1c:	01858813          	addi	a6,a1,24
  xa = xa0 + j;
  xb0 = b->_x;
   15a20:	01860413          	addi	s0,a2,24
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   15a24:	00e807b3          	add	a5,a6,a4
  xb0 = b->_x;
  xb = xb0 + j;
   15a28:	00e40733          	add	a4,s0,a4
   15a2c:	0080006f          	j	15a34 <__mdiff+0x50>
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
   15a30:	16f87263          	bleu	a5,a6,15b94 <__mdiff+0x1b0>
  xa = xa0 + j;
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
   15a34:	ffc78793          	addi	a5,a5,-4
   15a38:	ffc70713          	addi	a4,a4,-4
   15a3c:	0007a583          	lw	a1,0(a5)
   15a40:	00072683          	lw	a3,0(a4)
   15a44:	fed586e3          	beq	a1,a3,15a30 <__mdiff+0x4c>
	return *xa < *xb ? -1 : 1;
   15a48:	18d5f063          	bleu	a3,a1,15bc8 <__mdiff+0x1e4>
   15a4c:	00090793          	mv	a5,s2
   15a50:	00080493          	mv	s1,a6
   15a54:	00098913          	mv	s2,s3
  if (i < 0)
    {
      c = a;
      a = b;
      b = c;
      i = 1;
   15a58:	00100a13          	li	s4,1
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   15a5c:	00078993          	mv	s3,a5
   15a60:	0140006f          	j	15a74 <__mdiff+0x90>
      c = Balloc (ptr, 0);
      c->_wds = 1;
      c->_x[0] = 0;
      return c;
    }
  if (i < 0)
   15a64:	16074a63          	bltz	a4,15bd8 <__mdiff+0x1f4>
   15a68:	01860493          	addi	s1,a2,24
   15a6c:	01858413          	addi	s0,a1,24
      a = b;
      b = c;
      i = 1;
    }
  else
    i = 0;
   15a70:	00000a13          	li	s4,0
  c = Balloc (ptr, a->_k);
   15a74:	00892583          	lw	a1,8(s2)
   15a78:	e14ff0ef          	jal	1508c <_Balloc>
  c->_sign = i;
  wa = a->_wds;
   15a7c:	01492e03          	lw	t3,20(s2)
  xa = a->_x;
  xae = xa + wa;
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   15a80:	0149af03          	lw	t5,20(s3)
  xc = c->_x;
  borrow = 0;
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   15a84:	00010337          	lui	t1,0x10
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
   15a88:	002e1e93          	slli	t4,t3,0x2
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   15a8c:	002f1f13          	slli	t5,t5,0x2
      i = 1;
    }
  else
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
   15a90:	01452823          	sw	s4,16(a0)
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
   15a94:	01d40eb3          	add	t4,s0,t4
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   15a98:	01e48f33          	add	t5,s1,t5
  xc = c->_x;
   15a9c:	01850813          	addi	a6,a0,24
  borrow = 0;
   15aa0:	00000693          	li	a3,0
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   15aa4:	fff3031b          	addiw	t1,t1,-1
   15aa8:	00042583          	lw	a1,0(s0)
   15aac:	0004a883          	lw	a7,0(s1)
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   15ab0:	00480813          	addi	a6,a6,4
  xc = c->_x;
  borrow = 0;
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   15ab4:	0065f633          	and	a2,a1,t1
   15ab8:	00d606bb          	addw	a3,a2,a3
   15abc:	0068f733          	and	a4,a7,t1
   15ac0:	40e6873b          	subw	a4,a3,a4
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   15ac4:	0105d59b          	srliw	a1,a1,0x10
   15ac8:	0108d69b          	srliw	a3,a7,0x10
   15acc:	40d585bb          	subw	a1,a1,a3
   15ad0:	4107569b          	sraiw	a3,a4,0x10
   15ad4:	00d586bb          	addw	a3,a1,a3
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   15ad8:	0106979b          	slliw	a5,a3,0x10
   15adc:	00677733          	and	a4,a4,t1
   15ae0:	00e7e7b3          	or	a5,a5,a4
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   15ae4:	00448493          	addi	s1,s1,4
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   15ae8:	fef82e23          	sw	a5,-4(a6)
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   15aec:	00440413          	addi	s0,s0,4
      borrow = z >> 16;
   15af0:	4106d69b          	sraiw	a3,a3,0x10
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
   15af4:	fbe4eae3          	bltu	s1,t5,15aa8 <__mdiff+0xc4>
  while (xa < xae)
   15af8:	07d47063          	bleu	t4,s0,15b58 <__mdiff+0x174>
    {
      y = (*xa & 0xffff) + borrow;
   15afc:	00010f37          	lui	t5,0x10
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   15b00:	00080313          	mv	t1,a6
    }
  while (xb < xbe);
  while (xa < xae)
   15b04:	00040893          	mv	a7,s0
    {
      y = (*xa & 0xffff) + borrow;
   15b08:	ffff0f1b          	addiw	t5,t5,-1
   15b0c:	0008a583          	lw	a1,0(a7)
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   15b10:	00430313          	addi	t1,t1,4 # 10004 <_ftext+0x4>
  while (xa < xae)
    {
      y = (*xa & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
   15b14:	00488893          	addi	a7,a7,4
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
  while (xa < xae)
    {
      y = (*xa & 0xffff) + borrow;
   15b18:	01e5f633          	and	a2,a1,t5
   15b1c:	00d606bb          	addw	a3,a2,a3
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
   15b20:	4106d71b          	sraiw	a4,a3,0x10
   15b24:	0105d59b          	srliw	a1,a1,0x10
   15b28:	00e5873b          	addw	a4,a1,a4
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   15b2c:	01e6f6b3          	and	a3,a3,t5
   15b30:	0107179b          	slliw	a5,a4,0x10
   15b34:	00d7e7b3          	or	a5,a5,a3
   15b38:	fef32e23          	sw	a5,-4(t1)
    {
      y = (*xa & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
      borrow = z >> 16;
   15b3c:	4107569b          	sraiw	a3,a4,0x10
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
  while (xa < xae)
   15b40:	fdd8e6e3          	bltu	a7,t4,15b0c <__mdiff+0x128>
   15b44:	fff44413          	not	s0,s0
   15b48:	01d40eb3          	add	t4,s0,t4
   15b4c:	ffcefe93          	andi	t4,t4,-4
   15b50:	004e8e93          	addi	t4,t4,4
   15b54:	01d80833          	add	a6,a6,t4
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   15b58:	ffc80813          	addi	a6,a6,-4
   15b5c:	00079a63          	bnez	a5,15b70 <__mdiff+0x18c>
   15b60:	ffc80813          	addi	a6,a6,-4
   15b64:	00082783          	lw	a5,0(a6)
    wa--;
   15b68:	fffe0e1b          	addiw	t3,t3,-1
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   15b6c:	fe078ae3          	beqz	a5,15b60 <__mdiff+0x17c>
    wa--;
  c->_wds = wa;
  return c;
}
   15b70:	02813083          	ld	ra,40(sp)
   15b74:	02013403          	ld	s0,32(sp)
   15b78:	01813483          	ld	s1,24(sp)
   15b7c:	01013903          	ld	s2,16(sp)
   15b80:	00813983          	ld	s3,8(sp)
   15b84:	00013a03          	ld	s4,0(sp)
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
    wa--;
  c->_wds = wa;
   15b88:	01c52a23          	sw	t3,20(a0)
  return c;
}
   15b8c:	03010113          	addi	sp,sp,48
   15b90:	00008067          	ret
#endif

  i = cmp (a, b);
  if (!i)
    {
      c = Balloc (ptr, 0);
   15b94:	00000593          	li	a1,0
   15b98:	cf4ff0ef          	jal	1508c <_Balloc>
#endif
  while (!*--xc)
    wa--;
  c->_wds = wa;
  return c;
}
   15b9c:	02813083          	ld	ra,40(sp)

  i = cmp (a, b);
  if (!i)
    {
      c = Balloc (ptr, 0);
      c->_wds = 1;
   15ba0:	00100793          	li	a5,1
#endif
  while (!*--xc)
    wa--;
  c->_wds = wa;
  return c;
}
   15ba4:	02013403          	ld	s0,32(sp)
   15ba8:	01813483          	ld	s1,24(sp)
   15bac:	01013903          	ld	s2,16(sp)
   15bb0:	00813983          	ld	s3,8(sp)
   15bb4:	00013a03          	ld	s4,0(sp)

  i = cmp (a, b);
  if (!i)
    {
      c = Balloc (ptr, 0);
      c->_wds = 1;
   15bb8:	00f52a23          	sw	a5,20(a0)
      c->_x[0] = 0;
   15bbc:	00052c23          	sw	zero,24(a0)
#endif
  while (!*--xc)
    wa--;
  c->_wds = wa;
  return c;
}
   15bc0:	03010113          	addi	sp,sp,48
   15bc4:	00008067          	ret
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   15bc8:	00040493          	mv	s1,s0
      a = b;
      b = c;
      i = 1;
    }
  else
    i = 0;
   15bcc:	00000a13          	li	s4,0
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   15bd0:	00080413          	mv	s0,a6
   15bd4:	ea1ff06f          	j	15a74 <__mdiff+0x90>
   15bd8:	00090793          	mv	a5,s2
   15bdc:	01890493          	addi	s1,s2,24
   15be0:	01898413          	addi	s0,s3,24
   15be4:	00098913          	mv	s2,s3
  if (i < 0)
    {
      c = a;
      a = b;
      b = c;
      i = 1;
   15be8:	00100a13          	li	s4,1
   15bec:	00078993          	mv	s3,a5
   15bf0:	e85ff06f          	j	15a74 <__mdiff+0x90>

0000000000015bf4 <__ulp>:
  return c;
}

double
_DEFUN (ulp, (_x), double _x)
{
   15bf4:	e20507d3          	fmv.x.d	a5,fa0
  union double_union x, a;
  register __Long L;

  x.d = _x;

  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
   15bf8:	7ff00737          	lui	a4,0x7ff00
   15bfc:	4207d793          	srai	a5,a5,0x20
   15c00:	00e7f7b3          	and	a5,a5,a4
   15c04:	fcc00737          	lui	a4,0xfcc00
   15c08:	00e787bb          	addw	a5,a5,a4
#ifndef Sudden_Underflow
  if (L > 0)
   15c0c:	00f05863          	blez	a5,15c1c <__ulp+0x28>
      L = -L >> Exp_shift;
      if (L < Exp_shift)
	{
	  word0 (a) = 0x80000 >> L;
#ifndef _DOUBLE_IS_32BITS
	  word1 (a) = 0;
   15c10:	02079793          	slli	a5,a5,0x20
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
#endif
	}
    }
#endif
  return a.d;
   15c14:	f2078553          	fmv.d.x	fa0,a5
}
   15c18:	00008067          	ret

#ifndef Sudden_Underflow
    }
  else
    {
      L = -L >> Exp_shift;
   15c1c:	40f007bb          	negw	a5,a5
   15c20:	4147d79b          	sraiw	a5,a5,0x14
      if (L < Exp_shift)
   15c24:	01300713          	li	a4,19
   15c28:	04f75063          	ble	a5,a4,15c68 <__ulp+0x74>
#endif
	}
      else
	{
	  word0 (a) = 0;
	  L -= Exp_shift;
   15c2c:	fec7869b          	addiw	a3,a5,-20
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
   15c30:	01e00613          	li	a2,30
	  word1 (a) = 0;
#endif
	}
      else
	{
	  word0 (a) = 0;
   15c34:	00000793          	li	a5,0
	  L -= Exp_shift;
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
   15c38:	00100713          	li	a4,1
   15c3c:	00d64663          	blt	a2,a3,15c48 <__ulp+0x54>
   15c40:	fff6c693          	not	a3,a3
   15c44:	00d7173b          	sllw	a4,a4,a3
   15c48:	fff00693          	li	a3,-1
   15c4c:	02069693          	slli	a3,a3,0x20
   15c50:	02071713          	slli	a4,a4,0x20
   15c54:	02075713          	srli	a4,a4,0x20
   15c58:	00d7f7b3          	and	a5,a5,a3
   15c5c:	00e7e7b3          	or	a5,a5,a4
#endif
	}
    }
#endif
  return a.d;
   15c60:	f2078553          	fmv.d.x	fa0,a5
}
   15c64:	00008067          	ret
  else
    {
      L = -L >> Exp_shift;
      if (L < Exp_shift)
	{
	  word0 (a) = 0x80000 >> L;
   15c68:	00080737          	lui	a4,0x80
#ifndef _DOUBLE_IS_32BITS
	  word1 (a) = 0;
   15c6c:	40f757bb          	sraw	a5,a4,a5
   15c70:	fa1ff06f          	j	15c10 <__ulp+0x1c>

0000000000015c74 <__b2d>:
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   15c74:	fd010113          	addi	sp,sp,-48
   15c78:	02813023          	sd	s0,32(sp)
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
   15c7c:	01452403          	lw	s0,20(a0)
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   15c80:	00913c23          	sd	s1,24(sp)
#else
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
   15c84:	01850493          	addi	s1,a0,24
  xa = xa0 + a->_wds;
   15c88:	00241413          	slli	s0,s0,0x2
   15c8c:	00848433          	add	s0,s1,s0
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   15c90:	01213823          	sd	s2,16(sp)
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
  y = *--xa;
   15c94:	ffc42903          	lw	s2,-4(s0)
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   15c98:	01313423          	sd	s3,8(sp)
   15c9c:	01413023          	sd	s4,0(sp)
  y = *--xa;
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
   15ca0:	00090513          	mv	a0,s2
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   15ca4:	00058a13          	mv	s4,a1
   15ca8:	02113423          	sd	ra,40(sp)
  y = *--xa;
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
   15cac:	eecff0ef          	jal	15398 <__hi0bits>
  *e = 32 - k;
   15cb0:	02000793          	li	a5,32
   15cb4:	40a7873b          	subw	a4,a5,a0
   15cb8:	00ea2023          	sw	a4,0(s4)
#ifdef Pack_32
  if (k < Ebits)
   15cbc:	00a00713          	li	a4,10
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
  y = *--xa;
   15cc0:	ffc40993          	addi	s3,s0,-4
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
  *e = 32 - k;
#ifdef Pack_32
  if (k < Ebits)
   15cc4:	06a74a63          	blt	a4,a0,15d38 <__b2d+0xc4>
    {
      d0 = Exp_1 | y >> (Ebits - k);
   15cc8:	00b00693          	li	a3,11
   15ccc:	40a686bb          	subw	a3,a3,a0
   15cd0:	3ff00737          	lui	a4,0x3ff00
   15cd4:	00d957bb          	srlw	a5,s2,a3
   15cd8:	00e7e7b3          	or	a5,a5,a4
   15cdc:	02079793          	slli	a5,a5,0x20
   15ce0:	00000713          	li	a4,0
      w = xa > xa0 ? *--xa : 0;
   15ce4:	0134f663          	bleu	s3,s1,15cf0 <__b2d+0x7c>
   15ce8:	ff842703          	lw	a4,-8(s0)
   15cec:	00d7573b          	srlw	a4,a4,a3
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
   15cf0:	0155051b          	addiw	a0,a0,21
   15cf4:	00a9153b          	sllw	a0,s2,a0
   15cf8:	00e56533          	or	a0,a0,a4
  if (k -= Ebits)
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
      y = xa > xa0 ? *--xa : 0;
#ifndef _DOUBLE_IS_32BITS
      d1 = z << k | y >> (32 - k);
   15cfc:	fff00713          	li	a4,-1
   15d00:	02051513          	slli	a0,a0,0x20
   15d04:	02071713          	slli	a4,a4,0x20
   15d08:	02055513          	srli	a0,a0,0x20
   15d0c:	00e7f7b3          	and	a5,a5,a4
   15d10:	00a7e7b3          	or	a5,a5,a0
#else
#undef d0
#undef d1
#endif
  return d.d;
}
   15d14:	02813083          	ld	ra,40(sp)
  word1 (d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
  return d.d;
   15d18:	f2078553          	fmv.d.x	fa0,a5
}
   15d1c:	02013403          	ld	s0,32(sp)
   15d20:	01813483          	ld	s1,24(sp)
   15d24:	01013903          	ld	s2,16(sp)
   15d28:	00813983          	ld	s3,8(sp)
   15d2c:	00013a03          	ld	s4,0(sp)
   15d30:	03010113          	addi	sp,sp,48
   15d34:	00008067          	ret
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
  if (k -= Ebits)
   15d38:	ff55051b          	addiw	a0,a0,-11
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   15d3c:	0534f263          	bleu	s3,s1,15d80 <__b2d+0x10c>
   15d40:	ff842683          	lw	a3,-8(s0)
  if (k -= Ebits)
   15d44:	04050263          	beqz	a0,15d88 <__b2d+0x114>
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   15d48:	40a7863b          	subw	a2,a5,a0
   15d4c:	00a917bb          	sllw	a5,s2,a0
   15d50:	3ff00937          	lui	s2,0x3ff00
   15d54:	00c6d73b          	srlw	a4,a3,a2
   15d58:	0127e7b3          	or	a5,a5,s2
   15d5c:	00e7e7b3          	or	a5,a5,a4
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   15d60:	ff840713          	addi	a4,s0,-8
  if (k -= Ebits)
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   15d64:	02079793          	slli	a5,a5,0x20
      y = xa > xa0 ? *--xa : 0;
   15d68:	04e4fa63          	bleu	a4,s1,15dbc <__b2d+0x148>
   15d6c:	ff442703          	lw	a4,-12(s0)
   15d70:	00a6953b          	sllw	a0,a3,a0
   15d74:	00c756bb          	srlw	a3,a4,a2
   15d78:	00a6e533          	or	a0,a3,a0
   15d7c:	f81ff06f          	j	15cfc <__b2d+0x88>
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   15d80:	00000693          	li	a3,0
  if (k -= Ebits)
   15d84:	02051063          	bnez	a0,15da4 <__b2d+0x130>
      d1 = z << k | y >> (32 - k);
#endif
    }
  else
    {
      d0 = Exp_1 | y;
   15d88:	3ff00737          	lui	a4,0x3ff00
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   15d8c:	00e967b3          	or	a5,s2,a4
   15d90:	02069693          	slli	a3,a3,0x20
   15d94:	0206d693          	srli	a3,a3,0x20
   15d98:	02079793          	slli	a5,a5,0x20
   15d9c:	00d7e7b3          	or	a5,a5,a3
   15da0:	f75ff06f          	j	15d14 <__b2d+0xa0>
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
  if (k -= Ebits)
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   15da4:	00a917bb          	sllw	a5,s2,a0
   15da8:	3ff00737          	lui	a4,0x3ff00
   15dac:	00e7e7b3          	or	a5,a5,a4
   15db0:	02079793          	slli	a5,a5,0x20
   15db4:	00000513          	li	a0,0
   15db8:	f45ff06f          	j	15cfc <__b2d+0x88>
   15dbc:	00a6953b          	sllw	a0,a3,a0
   15dc0:	f3dff06f          	j	15cfc <__b2d+0x88>

0000000000015dc4 <__d2b>:
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   15dc4:	fc010113          	addi	sp,sp,-64
   15dc8:	02813823          	sd	s0,48(sp)
   15dcc:	e2058453          	fmv.x.d	s0,fa1
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   15dd0:	00100593          	li	a1,1
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   15dd4:	02913423          	sd	s1,40(sp)
   15dd8:	03213023          	sd	s2,32(sp)
   15ddc:	01313c23          	sd	s3,24(sp)
   15de0:	01413823          	sd	s4,16(sp)
   15de4:	00068993          	mv	s3,a3
   15de8:	02113c23          	sd	ra,56(sp)
   15dec:	00060a13          	mv	s4,a2
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   15df0:	a9cff0ef          	jal	1508c <_Balloc>
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;

  z = d0 & Frac_mask;
   15df4:	42045793          	srai	a5,s0,0x20
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   15df8:	02179493          	slli	s1,a5,0x21
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;

  z = d0 & Frac_mask;
   15dfc:	001006b7          	lui	a3,0x100
   15e00:	fff6871b          	addiw	a4,a3,-1
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   15e04:	0354d493          	srli	s1,s1,0x35
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   15e08:	00050913          	mv	s2,a0
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;

  z = d0 & Frac_mask;
   15e0c:	00e7f7b3          	and	a5,a5,a4
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   15e10:	00048463          	beqz	s1,15e18 <__d2b+0x54>
    z |= Exp_msk1;
   15e14:	00d7e7b3          	or	a5,a5,a3
   15e18:	00f12623          	sw	a5,12(sp)
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
   15e1c:	0004041b          	sext.w	s0,s0
   15e20:	08040063          	beqz	s0,15ea0 <__d2b+0xdc>
    {
      y = d1;
      k = lo0bits (&y);
   15e24:	00810513          	addi	a0,sp,8
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
    {
      y = d1;
   15e28:	00812423          	sw	s0,8(sp)
      k = lo0bits (&y);
   15e2c:	de8ff0ef          	jal	15414 <__lo0bits>
      if (k)
	{
         x[0] = y | z << (32 - k);
   15e30:	00c12783          	lw	a5,12(sp)
#ifndef _DOUBLE_IS_32BITS
  if (d1)
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
   15e34:	0a051463          	bnez	a0,15edc <__d2b+0x118>
	{
         x[0] = y | z << (32 - k);
	  z >>= k;
	}
      else
	x[0] = y;
   15e38:	00812703          	lw	a4,8(sp)
   15e3c:	00e92c23          	sw	a4,24(s2) # 3ff00018 <_gp+0x3fee4548>
      i = b->_wds = (x[1] = z) ? 2 : 1;
   15e40:	0017b413          	seqz	s0,a5
   15e44:	00200713          	li	a4,2
   15e48:	4087043b          	subw	s0,a4,s0
   15e4c:	00f92e23          	sw	a5,28(s2)
   15e50:	00892a23          	sw	s0,20(s2)
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
   15e54:	06049663          	bnez	s1,15ec0 <__d2b+0xfc>
#endif
#ifndef Sudden_Underflow
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
   15e58:	bce5051b          	addiw	a0,a0,-1074
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
   15e5c:	00241793          	slli	a5,s0,0x2
#endif
#ifndef Sudden_Underflow
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
   15e60:	00aa2023          	sw	a0,0(s4)
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
   15e64:	00f907b3          	add	a5,s2,a5
   15e68:	0147a503          	lw	a0,20(a5)
   15e6c:	0054141b          	slliw	s0,s0,0x5
   15e70:	d28ff0ef          	jal	15398 <__hi0bits>
   15e74:	40a4053b          	subw	a0,s0,a0
   15e78:	00a9a023          	sw	a0,0(s3)
      *bits = (i + 2) * 16 - hi0bits (x[i]);
#endif
    }
#endif
  return b;
}
   15e7c:	03813083          	ld	ra,56(sp)
   15e80:	00090513          	mv	a0,s2
   15e84:	03013403          	ld	s0,48(sp)
   15e88:	02813483          	ld	s1,40(sp)
   15e8c:	02013903          	ld	s2,32(sp)
   15e90:	01813983          	ld	s3,24(sp)
   15e94:	01013a03          	ld	s4,16(sp)
   15e98:	04010113          	addi	sp,sp,64
   15e9c:	00008067          	ret
    {
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
   15ea0:	00c10513          	addi	a0,sp,12
   15ea4:	d70ff0ef          	jal	15414 <__lo0bits>
      x[0] = z;
   15ea8:	00c12783          	lw	a5,12(sp)
      i = b->_wds = 1;
   15eac:	00100413          	li	s0,1
   15eb0:	00892a23          	sw	s0,20(s2)
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
      x[0] = z;
   15eb4:	00f92c23          	sw	a5,24(s2)
      i = b->_wds = 1;
#ifndef _DOUBLE_IS_32BITS
      k += 32;
   15eb8:	0205051b          	addiw	a0,a0,32
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
   15ebc:	f8048ee3          	beqz	s1,15e58 <__d2b+0x94>
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   15ec0:	bcd4849b          	addiw	s1,s1,-1075
   15ec4:	00a484bb          	addw	s1,s1,a0
      *bits = P - k;
   15ec8:	03500793          	li	a5,53
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   15ecc:	009a2023          	sw	s1,0(s4)
      *bits = P - k;
   15ed0:	40a7853b          	subw	a0,a5,a0
   15ed4:	00a9a023          	sw	a0,0(s3)
   15ed8:	fa5ff06f          	j	15e7c <__d2b+0xb8>
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
	{
         x[0] = y | z << (32 - k);
   15edc:	02000713          	li	a4,32
   15ee0:	00812683          	lw	a3,8(sp)
   15ee4:	40a7073b          	subw	a4,a4,a0
   15ee8:	00e7973b          	sllw	a4,a5,a4
   15eec:	00d76733          	or	a4,a4,a3
	  z >>= k;
   15ef0:	00a7d7bb          	srlw	a5,a5,a0
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
	{
         x[0] = y | z << (32 - k);
   15ef4:	00e92c23          	sw	a4,24(s2)
	  z >>= k;
   15ef8:	00f12623          	sw	a5,12(sp)
   15efc:	f45ff06f          	j	15e40 <__d2b+0x7c>

0000000000015f00 <__ratio>:
#undef d1

double
_DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)

{
   15f00:	fd010113          	addi	sp,sp,-48
   15f04:	00913c23          	sd	s1,24(sp)
   15f08:	00058493          	mv	s1,a1
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   15f0c:	00810593          	addi	a1,sp,8
#undef d1

double
_DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)

{
   15f10:	02113423          	sd	ra,40(sp)
   15f14:	02813023          	sd	s0,32(sp)
   15f18:	01213823          	sd	s2,16(sp)
   15f1c:	00050913          	mv	s2,a0
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   15f20:	d55ff0ef          	jal	15c74 <__b2d>
  db.d = b2d (b, &kb);
   15f24:	00c10593          	addi	a1,sp,12
   15f28:	00048513          	mv	a0,s1

{
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   15f2c:	e2050453          	fmv.x.d	s0,fa0
  db.d = b2d (b, &kb);
   15f30:	d45ff0ef          	jal	15c74 <__b2d>
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   15f34:	01492703          	lw	a4,20(s2)
   15f38:	0144a783          	lw	a5,20(s1)
   15f3c:	00c12603          	lw	a2,12(sp)
{
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
  db.d = b2d (b, &kb);
   15f40:	e20506d3          	fmv.x.d	a3,fa0
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   15f44:	40f707bb          	subw	a5,a4,a5
   15f48:	0057971b          	slliw	a4,a5,0x5
   15f4c:	00812783          	lw	a5,8(sp)
   15f50:	40c787bb          	subw	a5,a5,a2
   15f54:	00f707bb          	addw	a5,a4,a5
      word0 (db) += (k >> 2) * Exp_msk1;
      if (k &= 3)
	db.d *= 1 << k;
    }
#else
  if (k > 0)
   15f58:	04f05463          	blez	a5,15fa0 <__ratio+0xa0>
   15f5c:	00040713          	mv	a4,s0
    word0 (da) += k * Exp_msk1;
   15f60:	0147979b          	slliw	a5,a5,0x14
   15f64:	42045413          	srai	s0,s0,0x20
   15f68:	00f407bb          	addw	a5,s0,a5
   15f6c:	02071413          	slli	s0,a4,0x20
   15f70:	02079793          	slli	a5,a5,0x20
   15f74:	02045413          	srli	s0,s0,0x20
   15f78:	00f46433          	or	s0,s0,a5
      k = -k;
      word0 (db) += k * Exp_msk1;
    }
#endif
  return da.d / db.d;
}
   15f7c:	f20407d3          	fmv.d.x	fa5,s0
   15f80:	f2068753          	fmv.d.x	fa4,a3
   15f84:	02813083          	ld	ra,40(sp)
   15f88:	02013403          	ld	s0,32(sp)
   15f8c:	1ae7f553          	fdiv.d	fa0,fa5,fa4
   15f90:	01813483          	ld	s1,24(sp)
   15f94:	01013903          	ld	s2,16(sp)
   15f98:	03010113          	addi	sp,sp,48
   15f9c:	00008067          	ret
   15fa0:	00068613          	mv	a2,a3
  if (k > 0)
    word0 (da) += k * Exp_msk1;
  else
    {
      k = -k;
      word0 (db) += k * Exp_msk1;
   15fa4:	0147979b          	slliw	a5,a5,0x14
   15fa8:	4206d693          	srai	a3,a3,0x20
   15fac:	40f687bb          	subw	a5,a3,a5
   15fb0:	02061693          	slli	a3,a2,0x20
   15fb4:	02079793          	slli	a5,a5,0x20
   15fb8:	0206d693          	srli	a3,a3,0x20
   15fbc:	00f6e6b3          	or	a3,a3,a5
   15fc0:	fbdff06f          	j	15f7c <__ratio+0x7c>

0000000000015fc4 <_mprec_log10>:
double
_DEFUN (_mprec_log10, (dig),
	int dig)
{
  double v = 1.0;
  if (dig < 24)
   15fc4:	01700793          	li	a5,23
   15fc8:	02a7d263          	ble	a0,a5,15fec <_mprec_log10+0x28>
   15fcc:	0001b7b7          	lui	a5,0x1b
   15fd0:	3287b507          	fld	fa0,808(a5) # 1b328 <__wctomb+0x28>
    return tens[dig];
  while (dig > 0)
    {
      v *= 10;
   15fd4:	0001b7b7          	lui	a5,0x1b
   15fd8:	3307b787          	fld	fa5,816(a5) # 1b330 <__wctomb+0x30>
      dig--;
   15fdc:	fff5051b          	addiw	a0,a0,-1
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
  while (dig > 0)
    {
      v *= 10;
   15fe0:	12f57553          	fmul.d	fa0,fa0,fa5
	int dig)
{
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
  while (dig > 0)
   15fe4:	fe051ce3          	bnez	a0,15fdc <_mprec_log10+0x18>
    {
      v *= 10;
      dig--;
    }
  return v;
}
   15fe8:	00008067          	ret
_DEFUN (_mprec_log10, (dig),
	int dig)
{
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
   15fec:	000197b7          	lui	a5,0x19
   15ff0:	f5078793          	addi	a5,a5,-176 # 18f50 <p05.2568>
   15ff4:	00351513          	slli	a0,a0,0x3
   15ff8:	00a78533          	add	a0,a5,a0
   15ffc:	01053507          	fld	fa0,16(a0)
   16000:	00008067          	ret

0000000000016004 <__copybits>:
#endif

	ce = c + ((n-1) >> kshift) + 1;
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
   16004:	01462703          	lw	a4,20(a2)
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   16008:	fff5859b          	addiw	a1,a1,-1
   1600c:	4055d81b          	sraiw	a6,a1,0x5
   16010:	00180813          	addi	a6,a6,1
	x = b->_x;
   16014:	01860793          	addi	a5,a2,24
#ifdef Pack_32
	xe = x + b->_wds;
   16018:	00271713          	slli	a4,a4,0x2
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   1601c:	00281813          	slli	a6,a6,0x2
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
   16020:	00e786b3          	add	a3,a5,a4
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   16024:	01050833          	add	a6,a0,a6
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
	while(x < xe)
   16028:	02d7f863          	bleu	a3,a5,16058 <__copybits+0x54>
   1602c:	00050713          	mv	a4,a0
		*c++ = *x++;
   16030:	00478793          	addi	a5,a5,4
   16034:	ffc7a583          	lw	a1,-4(a5)
   16038:	00470713          	addi	a4,a4,4 # 3ff00004 <_gp+0x3fee4534>
   1603c:	feb72e23          	sw	a1,-4(a4)

	ce = c + ((n-1) >> kshift) + 1;
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
	while(x < xe)
   16040:	fed7e8e3          	bltu	a5,a3,16030 <__copybits+0x2c>
   16044:	40c687b3          	sub	a5,a3,a2
   16048:	fe778793          	addi	a5,a5,-25
   1604c:	ffc7f793          	andi	a5,a5,-4
   16050:	00478793          	addi	a5,a5,4
   16054:	00f50533          	add	a0,a0,a5
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   16058:	01057863          	bleu	a6,a0,16068 <__copybits+0x64>
		*c++ = 0;
   1605c:	00450513          	addi	a0,a0,4
   16060:	fe052e23          	sw	zero,-4(a0)
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   16064:	ff056ce3          	bltu	a0,a6,1605c <__copybits+0x58>
   16068:	00008067          	ret

000000000001606c <__any_on>:
{
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
	nwds = b->_wds;
   1606c:	01452783          	lw	a5,20(a0)
	n = k >> kshift;
   16070:	4055d71b          	sraiw	a4,a1,0x5
	int k)
{
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
   16074:	01850693          	addi	a3,a0,24
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
   16078:	04e7c463          	blt	a5,a4,160c0 <__any_on+0x54>
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   1607c:	04f75063          	ble	a5,a4,160bc <__any_on+0x50>
		x1 = x2 = x[n];
   16080:	00070793          	mv	a5,a4
   16084:	00279793          	slli	a5,a5,0x2
	x = b->_x;
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   16088:	01f5f593          	andi	a1,a1,31
		x1 = x2 = x[n];
   1608c:	00f687b3          	add	a5,a3,a5
	x = b->_x;
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   16090:	04059063          	bnez	a1,160d0 <__any_on+0x64>
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
	while(x > x0)
   16094:	04f6fa63          	bleu	a5,a3,160e8 <__any_on+0x7c>
		if (*--x)
   16098:	ffc7a503          	lw	a0,-4(a5)
   1609c:	ffc78793          	addi	a5,a5,-4
   160a0:	00051a63          	bnez	a0,160b4 <__any_on+0x48>
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
	while(x > x0)
   160a4:	02f6f463          	bleu	a5,a3,160cc <__any_on+0x60>
		if (*--x)
   160a8:	ffc78793          	addi	a5,a5,-4
   160ac:	0007a703          	lw	a4,0(a5)
   160b0:	fe070ae3          	beqz	a4,160a4 <__any_on+0x38>
	else if (n < nwds && (k &= kmask)) {
		x1 = x2 = x[n];
		x1 >>= k;
		x1 <<= k;
		if (x1 != x2)
			return 1;
   160b4:	00100513          	li	a0,1
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
}
   160b8:	00008067          	ret
   160bc:	00070793          	mv	a5,a4
   160c0:	00279793          	slli	a5,a5,0x2
   160c4:	00f687b3          	add	a5,a3,a5
   160c8:	fcdff06f          	j	16094 <__any_on+0x28>
   160cc:	00008067          	ret
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
		x1 = x2 = x[n];
   160d0:	0007a603          	lw	a2,0(a5)
		x1 >>= k;
		x1 <<= k;
		if (x1 != x2)
			return 1;
   160d4:	00100513          	li	a0,1
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
		x1 = x2 = x[n];
		x1 >>= k;
   160d8:	00b6573b          	srlw	a4,a2,a1
		x1 <<= k;
		if (x1 != x2)
   160dc:	00b715bb          	sllw	a1,a4,a1
   160e0:	fab60ae3          	beq	a2,a1,16094 <__any_on+0x28>
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
}
   160e4:	00008067          	ret
	x0 = x;
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
   160e8:	00000513          	li	a0,0
   160ec:	00008067          	ret

00000000000160f0 <__fpclassifyd>:

#include "fdlibm.h"

int
__fpclassifyd (double x)
{
   160f0:	e20507d3          	fmv.x.d	a5,fa0

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
   160f4:	00200513          	li	a0,2
int
__fpclassifyd (double x)
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);
   160f8:	4207d713          	srai	a4,a5,0x20
   160fc:	0007879b          	sext.w	a5,a5

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   16100:	00f766b3          	or	a3,a4,a5
   16104:	00069463          	bnez	a3,1610c <__fpclassifyd+0x1c>
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
}
   16108:	00008067          	ret
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   1610c:	800006b7          	lui	a3,0x80000
   16110:	04d70863          	beq	a4,a3,16160 <__fpclassifyd+0x70>
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
   16114:	fff006b7          	lui	a3,0xfff00
   16118:	00d706bb          	addw	a3,a4,a3
   1611c:	7fe00637          	lui	a2,0x7fe00
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
   16120:	00400513          	li	a0,4
  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
   16124:	fec6e2e3          	bltu	a3,a2,16108 <__fpclassifyd+0x18>
   16128:	7ff006b7          	lui	a3,0x7ff00
   1612c:	00d706bb          	addw	a3,a4,a3
   16130:	fcc6ece3          	bltu	a3,a2,16108 <__fpclassifyd+0x18>
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   16134:	800006b7          	lui	a3,0x80000
   16138:	fff6c693          	not	a3,a3
   1613c:	00d77733          	and	a4,a4,a3
   16140:	001006b7          	lui	a3,0x100
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
   16144:	00300513          	li	a0,3
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   16148:	fcd760e3          	bltu	a4,a3,16108 <__fpclassifyd+0x18>
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
   1614c:	7ff006b7          	lui	a3,0x7ff00
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
   16150:	00000513          	li	a0,0
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
   16154:	fad71ae3          	bne	a4,a3,16108 <__fpclassifyd+0x18>
  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
   16158:	0017b513          	seqz	a0,a5
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
}
   1615c:	00008067          	ret
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
   16160:	fc079ae3          	bnez	a5,16134 <__fpclassifyd+0x44>
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
}
   16164:	00008067          	ret

0000000000016168 <__sread>:
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   16168:	01259503          	lh	a0,18(a1)
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   1616c:	ff010113          	addi	sp,sp,-16
   16170:	00813023          	sd	s0,0(sp)
   16174:	00058413          	mv	s0,a1
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   16178:	00060593          	mv	a1,a2
   1617c:	00068613          	mv	a2,a3
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   16180:	00113423          	sd	ra,8(sp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   16184:	0cd020ef          	jal	18a50 <read>
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
   16188:	02054063          	bltz	a0,161a8 <__sread+0x40>
    fp->_offset += ret;
   1618c:	09043783          	ld	a5,144(s0)
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   16190:	00813083          	ld	ra,8(sp)
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
   16194:	00a787b3          	add	a5,a5,a0
   16198:	08f43823          	sd	a5,144(s0)
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   1619c:	00013403          	ld	s0,0(sp)
   161a0:	01010113          	addi	sp,sp,16
   161a4:	00008067          	ret
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   161a8:	01045703          	lhu	a4,16(s0)
   161ac:	fffff7b7          	lui	a5,0xfffff
  return ret;
}
   161b0:	00813083          	ld	ra,8(sp)
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   161b4:	fff7879b          	addiw	a5,a5,-1
   161b8:	00f777b3          	and	a5,a4,a5
   161bc:	00f41823          	sh	a5,16(s0)
  return ret;
}
   161c0:	00013403          	ld	s0,0(sp)
   161c4:	01010113          	addi	sp,sp,16
   161c8:	00008067          	ret

00000000000161cc <__seofread>:
       _PTR cookie _AND
       char *buf   _AND
       _READ_WRITE_BUFSIZE_TYPE len)
{
  return 0;
}
   161cc:	00000513          	li	a0,0
   161d0:	00008067          	ret

00000000000161d4 <__swrite>:
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   161d4:	01059703          	lh	a4,16(a1)
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   161d8:	fd010113          	addi	sp,sp,-48
   161dc:	02813023          	sd	s0,32(sp)
   161e0:	00913c23          	sd	s1,24(sp)
   161e4:	02113423          	sd	ra,40(sp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   161e8:	10077793          	andi	a5,a4,256
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   161ec:	00058413          	mv	s0,a1
   161f0:	00060493          	mv	s1,a2
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   161f4:	02078063          	beqz	a5,16214 <__swrite+0x40>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
   161f8:	01259503          	lh	a0,18(a1)
   161fc:	00200613          	li	a2,2
   16200:	00000593          	li	a1,0
   16204:	00d13423          	sd	a3,8(sp)
   16208:	035020ef          	jal	18a3c <lseek>
   1620c:	01041703          	lh	a4,16(s0)
   16210:	00813683          	ld	a3,8(sp)
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   16214:	fffff7b7          	lui	a5,0xfffff
   16218:	fff7879b          	addiw	a5,a5,-1
   1621c:	00f777b3          	and	a5,a4,a5
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   16220:	01241503          	lh	a0,18(s0)
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   16224:	00f41823          	sh	a5,16(s0)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   16228:	00048593          	mv	a1,s1
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
}
   1622c:	02813083          	ld	ra,40(sp)
   16230:	02013403          	ld	s0,32(sp)
   16234:	01813483          	ld	s1,24(sp)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   16238:	00068613          	mv	a2,a3
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
}
   1623c:	03010113          	addi	sp,sp,48
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   16240:	0250206f          	j	18a64 <write>

0000000000016244 <__sseek>:
       int whence)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   16244:	01259503          	lh	a0,18(a1)
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
   16248:	ff010113          	addi	sp,sp,-16
   1624c:	00813023          	sd	s0,0(sp)
   16250:	00058413          	mv	s0,a1
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   16254:	00060593          	mv	a1,a2
   16258:	00068613          	mv	a2,a3
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
   1625c:	00113423          	sd	ra,8(sp)
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   16260:	7dc020ef          	jal	18a3c <lseek>
  if (ret == -1L)
   16264:	fff00793          	li	a5,-1
    fp->_flags &= ~__SOFF;
   16268:	01045703          	lhu	a4,16(s0)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
   1626c:	02f50263          	beq	a0,a5,16290 <__sseek+0x4c>
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   16270:	00813083          	ld	ra,8(sp)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   16274:	000017b7          	lui	a5,0x1
   16278:	00f767b3          	or	a5,a4,a5
      fp->_offset = ret;
   1627c:	08a43823          	sd	a0,144(s0)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   16280:	00f41823          	sh	a5,16(s0)
      fp->_offset = ret;
    }
  return ret;
}
   16284:	00013403          	ld	s0,0(sp)
   16288:	01010113          	addi	sp,sp,16
   1628c:	00008067          	ret
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
   16290:	fffff7b7          	lui	a5,0xfffff
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   16294:	00813083          	ld	ra,8(sp)
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
   16298:	fff7879b          	addiw	a5,a5,-1
   1629c:	00f777b3          	and	a5,a4,a5
   162a0:	00f41823          	sh	a5,16(s0)
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   162a4:	00013403          	ld	s0,0(sp)
   162a8:	01010113          	addi	sp,sp,16
   162ac:	00008067          	ret

00000000000162b0 <__sclose>:
       struct _reent *ptr _AND
       void *cookie)
{
  FILE *fp = (FILE *) cookie;

  return _close_r (ptr, fp->_file);
   162b0:	01259503          	lh	a0,18(a1)
   162b4:	05d0206f          	j	18b10 <close>

00000000000162b8 <strcmp>:
   162b8:	00b56733          	or	a4,a0,a1
   162bc:	fff00393          	li	t2,-1
   162c0:	00777713          	andi	a4,a4,7
   162c4:	0c071c63          	bnez	a4,1639c <strcmp+0xe4>
   162c8:	00005e17          	auipc	t3,0x5
   162cc:	098e3e03          	ld	t3,152(t3) # 1b360 <mask>
   162d0:	00053603          	ld	a2,0(a0)
   162d4:	0005b683          	ld	a3,0(a1)
   162d8:	01c672b3          	and	t0,a2,t3
   162dc:	01c66333          	or	t1,a2,t3
   162e0:	01c282b3          	add	t0,t0,t3
   162e4:	0062e2b3          	or	t0,t0,t1
   162e8:	0c729e63          	bne	t0,t2,163c4 <strcmp+0x10c>
   162ec:	04d61663          	bne	a2,a3,16338 <strcmp+0x80>
   162f0:	00853603          	ld	a2,8(a0)
   162f4:	0085b683          	ld	a3,8(a1)
   162f8:	01c672b3          	and	t0,a2,t3
   162fc:	01c66333          	or	t1,a2,t3
   16300:	01c282b3          	add	t0,t0,t3
   16304:	0062e2b3          	or	t0,t0,t1
   16308:	0a729a63          	bne	t0,t2,163bc <strcmp+0x104>
   1630c:	02d61663          	bne	a2,a3,16338 <strcmp+0x80>
   16310:	01053603          	ld	a2,16(a0)
   16314:	0105b683          	ld	a3,16(a1)
   16318:	01c672b3          	and	t0,a2,t3
   1631c:	01c66333          	or	t1,a2,t3
   16320:	01c282b3          	add	t0,t0,t3
   16324:	0062e2b3          	or	t0,t0,t1
   16328:	0a729463          	bne	t0,t2,163d0 <strcmp+0x118>
   1632c:	01850513          	addi	a0,a0,24
   16330:	01858593          	addi	a1,a1,24
   16334:	f8d60ee3          	beq	a2,a3,162d0 <strcmp+0x18>
   16338:	03061713          	slli	a4,a2,0x30
   1633c:	03069793          	slli	a5,a3,0x30
   16340:	02f71a63          	bne	a4,a5,16374 <strcmp+0xbc>
   16344:	02061713          	slli	a4,a2,0x20
   16348:	02069793          	slli	a5,a3,0x20
   1634c:	02f71463          	bne	a4,a5,16374 <strcmp+0xbc>
   16350:	01061713          	slli	a4,a2,0x10
   16354:	01069793          	slli	a5,a3,0x10
   16358:	00f71e63          	bne	a4,a5,16374 <strcmp+0xbc>
   1635c:	03065713          	srli	a4,a2,0x30
   16360:	0306d793          	srli	a5,a3,0x30
   16364:	40f70533          	sub	a0,a4,a5
   16368:	0ff57593          	andi	a1,a0,255
   1636c:	02059063          	bnez	a1,1638c <strcmp+0xd4>
   16370:	00008067          	ret
   16374:	03075713          	srli	a4,a4,0x30
   16378:	0307d793          	srli	a5,a5,0x30
   1637c:	40f70533          	sub	a0,a4,a5
   16380:	0ff57593          	andi	a1,a0,255
   16384:	00059463          	bnez	a1,1638c <strcmp+0xd4>
   16388:	00008067          	ret
   1638c:	0ff77713          	andi	a4,a4,255
   16390:	0ff7f793          	andi	a5,a5,255
   16394:	40f70533          	sub	a0,a4,a5
   16398:	00008067          	ret
   1639c:	00054603          	lbu	a2,0(a0)
   163a0:	0005c683          	lbu	a3,0(a1)
   163a4:	00150513          	addi	a0,a0,1
   163a8:	00158593          	addi	a1,a1,1
   163ac:	00d61463          	bne	a2,a3,163b4 <strcmp+0xfc>
   163b0:	fe0616e3          	bnez	a2,1639c <strcmp+0xe4>
   163b4:	40d60533          	sub	a0,a2,a3
   163b8:	00008067          	ret
   163bc:	00850513          	addi	a0,a0,8
   163c0:	00858593          	addi	a1,a1,8
   163c4:	fcd61ce3          	bne	a2,a3,1639c <strcmp+0xe4>
   163c8:	00000513          	li	a0,0
   163cc:	00008067          	ret
   163d0:	01050513          	addi	a0,a0,16
   163d4:	01058593          	addi	a1,a1,16
   163d8:	fcd612e3          	bne	a2,a3,1639c <strcmp+0xe4>
   163dc:	00000513          	li	a0,0
   163e0:	00008067          	ret

00000000000163e4 <strlen>:
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  while (*str++)
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
   163e4:	00757793          	andi	a5,a0,7
   163e8:	00050593          	mv	a1,a0
   163ec:	06079a63          	bnez	a5,16460 <strlen+0x7c>
   163f0:	0001b7b7          	lui	a5,0x1b
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));

  unsigned long* ls = (unsigned long*)str;
  while (!__libc_detect_null(*ls++))
   163f4:	3607b683          	ld	a3,864(a5) # 1b360 <mask>
   163f8:	fff00613          	li	a2,-1
   163fc:	00850513          	addi	a0,a0,8
   16400:	ff853783          	ld	a5,-8(a0)
   16404:	00d7f733          	and	a4,a5,a3
   16408:	00d70733          	add	a4,a4,a3
   1640c:	00d7e7b3          	or	a5,a5,a3
   16410:	00f767b3          	or	a5,a4,a5
   16414:	fec784e3          	beq	a5,a2,163fc <strlen+0x18>

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   16418:	ff854783          	lbu	a5,-8(a0)
  while (!__libc_detect_null(*ls++))
    ;
  asm volatile ("" : "+r"(ls)); /* prevent "optimization" */

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);
   1641c:	40b505b3          	sub	a1,a0,a1

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   16420:	06078263          	beqz	a5,16484 <strlen+0xa0>
  if (c1 == 0)            return ret + 1 - sl;
   16424:	ff954783          	lbu	a5,-7(a0)
   16428:	04078a63          	beqz	a5,1647c <strlen+0x98>
  if (c2 == 0)            return ret + 2 - sl;
   1642c:	ffa54783          	lbu	a5,-6(a0)
   16430:	06078263          	beqz	a5,16494 <strlen+0xb0>
  if (sl == 4 || c3 == 0) return ret + 3 - sl;
   16434:	ffb54783          	lbu	a5,-5(a0)
   16438:	04078a63          	beqz	a5,1648c <strlen+0xa8>

  c0 = str[4-sl], c1 = str[5-sl], c2 = str[6-sl], c3 = str[7-sl];
  if (c0 == 0)            return ret + 4 - sl;
   1643c:	ffc54783          	lbu	a5,-4(a0)
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
  if (sl == 4 || c3 == 0) return ret + 3 - sl;

  c0 = str[4-sl], c1 = str[5-sl], c2 = str[6-sl], c3 = str[7-sl];
   16440:	ffd54703          	lbu	a4,-3(a0)
   16444:	ffe54683          	lbu	a3,-2(a0)
  if (c0 == 0)            return ret + 4 - sl;
   16448:	04078a63          	beqz	a5,1649c <strlen+0xb8>
  if (c1 == 0)            return ret + 5 - sl;
   1644c:	04070c63          	beqz	a4,164a4 <strlen+0xc0>
  if (c2 == 0)            return ret + 6 - sl;
                          return ret + 7 - sl;
   16450:	fff58513          	addi	a0,a1,-1
  if (sl == 4 || c3 == 0) return ret + 3 - sl;

  c0 = str[4-sl], c1 = str[5-sl], c2 = str[6-sl], c3 = str[7-sl];
  if (c0 == 0)            return ret + 4 - sl;
  if (c1 == 0)            return ret + 5 - sl;
  if (c2 == 0)            return ret + 6 - sl;
   16454:	04068c63          	beqz	a3,164ac <strlen+0xc8>
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   16458:	00008067          	ret
  {
    char ch = *str;
    str++;
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   1645c:	f8070ae3          	beqz	a4,163f0 <strlen+0xc>
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
   16460:	00054783          	lbu	a5,0(a0)
    str++;
   16464:	00150513          	addi	a0,a0,1
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   16468:	00757713          	andi	a4,a0,7
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
    str++;
    if (!ch)
   1646c:	fe0798e3          	bnez	a5,1645c <strlen+0x78>
      return str - start - 1;
   16470:	40b50533          	sub	a0,a0,a1
   16474:	fff50513          	addi	a0,a0,-1
   16478:	00008067          	ret
  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
   1647c:	ff958513          	addi	a0,a1,-7
   16480:	00008067          	ret

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   16484:	ff858513          	addi	a0,a1,-8
   16488:	00008067          	ret
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
  if (sl == 4 || c3 == 0) return ret + 3 - sl;
   1648c:	ffb58513          	addi	a0,a1,-5
   16490:	00008067          	ret
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
   16494:	ffa58513          	addi	a0,a1,-6
   16498:	00008067          	ret
  if (sl == 4 || c3 == 0) return ret + 3 - sl;

  c0 = str[4-sl], c1 = str[5-sl], c2 = str[6-sl], c3 = str[7-sl];
  if (c0 == 0)            return ret + 4 - sl;
   1649c:	ffc58513          	addi	a0,a1,-4
   164a0:	00008067          	ret
  if (c1 == 0)            return ret + 5 - sl;
   164a4:	ffd58513          	addi	a0,a1,-3
   164a8:	00008067          	ret
  if (c2 == 0)            return ret + 6 - sl;
   164ac:	ffe58513          	addi	a0,a1,-2
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   164b0:	00008067          	ret

00000000000164b4 <__sprint_r.part.0>:
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   164b4:	0ac5a783          	lw	a5,172(a1)
/*
 * Flush out all the vectors defined by the given uio,
 * then reset it so that it can be reused.
 */
int
_DEFUN(__sprint_r, (ptr, fp, uio),
   164b8:	fb010113          	addi	sp,sp,-80
   164bc:	01613823          	sd	s6,16(sp)
   164c0:	04113423          	sd	ra,72(sp)
   164c4:	04813023          	sd	s0,64(sp)
   164c8:	02913c23          	sd	s1,56(sp)
   164cc:	03213823          	sd	s2,48(sp)
   164d0:	03313423          	sd	s3,40(sp)
   164d4:	03413023          	sd	s4,32(sp)
   164d8:	01513c23          	sd	s5,24(sp)
   164dc:	01713423          	sd	s7,8(sp)
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   164e0:	03279713          	slli	a4,a5,0x32
/*
 * Flush out all the vectors defined by the given uio,
 * then reset it so that it can be reused.
 */
int
_DEFUN(__sprint_r, (ptr, fp, uio),
   164e4:	00060b13          	mv	s6,a2
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   164e8:	0a075863          	bgez	a4,16598 <__sprint_r.part.0+0xe4>
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   164ec:	01063783          	ld	a5,16(a2) # 7fe00010 <_gp+0x7fde4540>
   164f0:	00058a13          	mv	s4,a1
   164f4:	00050a93          	mv	s5,a0
	if (fp->_flags2 & __SWID) {
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
   164f8:	00063b83          	ld	s7,0(a2)
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   164fc:	fff00993          	li	s3,-1
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   16500:	08078863          	beqz	a5,16590 <__sprint_r.part.0+0xdc>
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
   16504:	008bb903          	ld	s2,8(s7)
   16508:	000bb483          	ld	s1,0(s7)
			for (i = 0; i < len; i++) {
   1650c:	00000413          	li	s0,0

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
   16510:	00295913          	srli	s2,s2,0x2
   16514:	0009091b          	sext.w	s2,s2
			for (i = 0; i < len; i++) {
   16518:	01204863          	bgtz	s2,16528 <__sprint_r.part.0+0x74>
   1651c:	0600006f          	j	1657c <__sprint_r.part.0+0xc8>
   16520:	00448493          	addi	s1,s1,4
   16524:	04890a63          	beq	s2,s0,16578 <__sprint_r.part.0+0xc4>
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   16528:	0004a583          	lw	a1,0(s1)
   1652c:	000a0613          	mv	a2,s4
   16530:	000a8513          	mv	a0,s5
   16534:	524010ef          	jal	17a58 <_fputwc_r>
		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
   16538:	0014041b          	addiw	s0,s0,1
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   1653c:	ff3512e3          	bne	a0,s3,16520 <__sprint_r.part.0+0x6c>
					err = -1;
   16540:	00098513          	mv	a0,s3
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
	uio->uio_iovcnt = 0;
	return (err);
}
   16544:	04813083          	ld	ra,72(sp)
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
   16548:	000b3823          	sd	zero,16(s6)
	uio->uio_iovcnt = 0;
   1654c:	000b2423          	sw	zero,8(s6)
	return (err);
}
   16550:	04013403          	ld	s0,64(sp)
   16554:	03813483          	ld	s1,56(sp)
   16558:	03013903          	ld	s2,48(sp)
   1655c:	02813983          	ld	s3,40(sp)
   16560:	02013a03          	ld	s4,32(sp)
   16564:	01813a83          	ld	s5,24(sp)
   16568:	01013b03          	ld	s6,16(sp)
   1656c:	00813b83          	ld	s7,8(sp)
   16570:	05010113          	addi	sp,sp,80
   16574:	00008067          	ret
   16578:	010b3783          	ld	a5,16(s6)
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
   1657c:	00291913          	slli	s2,s2,0x2
   16580:	412787b3          	sub	a5,a5,s2
   16584:	00fb3823          	sd	a5,16(s6)
   16588:	010b8b93          	addi	s7,s7,16
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   1658c:	f6079ce3          	bnez	a5,16504 <__sprint_r.part.0+0x50>
_DEFUN(__sprint_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;
   16590:	00000513          	li	a0,0
   16594:	fb1ff06f          	j	16544 <__sprint_r.part.0+0x90>
				}
			}
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
   16598:	564010ef          	jal	17afc <__sfvwrite_r>
   1659c:	fa9ff06f          	j	16544 <__sprint_r.part.0+0x90>

00000000000165a0 <__sprint_r>:
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   165a0:	01063703          	ld	a4,16(a2)
   165a4:	00070463          	beqz	a4,165ac <__sprint_r+0xc>
   165a8:	f0dff06f          	j	164b4 <__sprint_r.part.0>
		uio->uio_iovcnt = 0;
   165ac:	00062423          	sw	zero,8(a2)
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
	uio->uio_iovcnt = 0;
	return (err);
}
   165b0:	00000513          	li	a0,0
   165b4:	00008067          	ret

00000000000165b8 <_vfiprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   165b8:	e6010113          	addi	sp,sp,-416
   165bc:	17513423          	sd	s5,360(sp)
   165c0:	17613023          	sd	s6,352(sp)
   165c4:	15a13023          	sd	s10,320(sp)
   165c8:	18113c23          	sd	ra,408(sp)
   165cc:	18813823          	sd	s0,400(sp)
   165d0:	18913423          	sd	s1,392(sp)
   165d4:	19213023          	sd	s2,384(sp)
   165d8:	17313c23          	sd	s3,376(sp)
   165dc:	17413823          	sd	s4,368(sp)
   165e0:	15713c23          	sd	s7,344(sp)
   165e4:	15813823          	sd	s8,336(sp)
   165e8:	15913423          	sd	s9,328(sp)
   165ec:	13b13c23          	sd	s11,312(sp)
   165f0:	00d13423          	sd	a3,8(sp)
   165f4:	00050a93          	mv	s5,a0
   165f8:	00058d13          	mv	s10,a1
   165fc:	00060b13          	mv	s6,a2
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   16600:	00050663          	beqz	a0,1660c <_vfiprintf_r+0x54>
   16604:	05052783          	lw	a5,80(a0)
   16608:	1e078c63          	beqz	a5,16800 <_vfiprintf_r+0x248>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
   1660c:	010d1683          	lh	a3,16(s10)
   16610:	03069793          	slli	a5,a3,0x30
   16614:	0307d793          	srli	a5,a5,0x30
   16618:	03279713          	slli	a4,a5,0x32
   1661c:	02074a63          	bltz	a4,16650 <_vfiprintf_r+0x98>
   16620:	000027b7          	lui	a5,0x2
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
	_newlib_flockfile_start (fp);
   16624:	0acd2603          	lw	a2,172(s10)

	ORIENT(fp, -1);
   16628:	00f6e7b3          	or	a5,a3,a5
   1662c:	0107979b          	slliw	a5,a5,0x10
   16630:	ffffe737          	lui	a4,0xffffe
   16634:	4107d79b          	sraiw	a5,a5,0x10
   16638:	fff7071b          	addiw	a4,a4,-1
   1663c:	00e67733          	and	a4,a2,a4
   16640:	00fd1823          	sh	a5,16(s10)
   16644:	03079793          	slli	a5,a5,0x30
   16648:	0aed2623          	sw	a4,172(s10)
   1664c:	0307d793          	srli	a5,a5,0x30

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   16650:	0087f713          	andi	a4,a5,8
   16654:	12070a63          	beqz	a4,16788 <_vfiprintf_r+0x1d0>
   16658:	018d3703          	ld	a4,24(s10)
   1665c:	12070663          	beqz	a4,16788 <_vfiprintf_r+0x1d0>
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   16660:	01a7f793          	andi	a5,a5,26
   16664:	00a00713          	li	a4,10
   16668:	14e78063          	beq	a5,a4,167a8 <_vfiprintf_r+0x1f0>
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   1666c:	0b010c93          	addi	s9,sp,176
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   16670:	00019c37          	lui	s8,0x19
   16674:	0af10793          	addi	a5,sp,175
   16678:	078c0713          	addi	a4,s8,120 # 19078 <__mprec_bigtens+0x28>
   1667c:	40fc87b3          	sub	a5,s9,a5
   16680:	000198b7          	lui	a7,0x19
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   16684:	07913823          	sd	s9,112(sp)
	uio.uio_resid = 0;
   16688:	08013023          	sd	zero,128(sp)
	uio.uio_iovcnt = 0;
   1668c:	06012c23          	sw	zero,120(sp)
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   16690:	000c8413          	mv	s0,s9
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   16694:	00013c23          	sd	zero,24(sp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
	uio.uio_resid = 0;
	uio.uio_iovcnt = 0;
#endif
	ret = 0;
   16698:	04012c23          	sw	zero,88(sp)
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   1669c:	00e13823          	sd	a4,16(sp)
   166a0:	1e088c13          	addi	s8,a7,480 # 191e0 <blanks.4136>
   166a4:	04f12e23          	sw	a5,92(sp)
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   166a8:	000b4783          	lbu	a5,0(s6)
   166ac:	4e078ee3          	beqz	a5,173a8 <_vfiprintf_r+0xdf0>
   166b0:	02500713          	li	a4,37
   166b4:	000b0493          	mv	s1,s6
   166b8:	00e79663          	bne	a5,a4,166c4 <_vfiprintf_r+0x10c>
   166bc:	0580006f          	j	16714 <_vfiprintf_r+0x15c>
   166c0:	00e78863          	beq	a5,a4,166d0 <_vfiprintf_r+0x118>
                    fmt += 1;
   166c4:	00148493          	addi	s1,s1,1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   166c8:	0004c783          	lbu	a5,0(s1)
   166cc:	fe079ae3          	bnez	a5,166c0 <_vfiprintf_r+0x108>
   166d0:	4164893b          	subw	s2,s1,s6
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   166d4:	04090063          	beqz	s2,16714 <_vfiprintf_r+0x15c>
			PRINT (cp, m);
   166d8:	08013703          	ld	a4,128(sp)
   166dc:	07812783          	lw	a5,120(sp)
   166e0:	00090613          	mv	a2,s2
   166e4:	00e60733          	add	a4,a2,a4
   166e8:	0017879b          	addiw	a5,a5,1
   166ec:	00c43423          	sd	a2,8(s0)
   166f0:	01643023          	sd	s6,0(s0)
   166f4:	08e13023          	sd	a4,128(sp)
   166f8:	06f12c23          	sw	a5,120(sp)
   166fc:	00700613          	li	a2,7
   16700:	01040413          	addi	s0,s0,16
   16704:	06f64463          	blt	a2,a5,1676c <_vfiprintf_r+0x1b4>
			ret += m;
   16708:	05812783          	lw	a5,88(sp)
   1670c:	012787bb          	addw	a5,a5,s2
   16710:	04f12c23          	sw	a5,88(sp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   16714:	0004c783          	lbu	a5,0(s1)
   16718:	580786e3          	beqz	a5,174a4 <_vfiprintf_r+0xeec>
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */
   1671c:	00148813          	addi	a6,s1,1

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
   16720:	060103a3          	sb	zero,103(sp)
   16724:	00000513          	li	a0,0
   16728:	00000e93          	li	t4,0
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
   1672c:	fff00493          	li	s1,-1
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
   16730:	00000913          	li	s2,0
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
   16734:	00000313          	li	t1,0
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   16738:	05800613          	li	a2,88
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			} while (is_digit (ch));
   1673c:	00900593          	li	a1,9
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   16740:	02a00f13          	li	t5,42
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   16744:	00084703          	lbu	a4,0(a6)
   16748:	00180b13          	addi	s6,a6,1
reswitch:	switch (ch) {
   1674c:	fe07079b          	addiw	a5,a4,-32
   16750:	66f66263          	bltu	a2,a5,16db4 <_vfiprintf_r+0x7fc>
   16754:	01013683          	ld	a3,16(sp)
   16758:	02079793          	slli	a5,a5,0x20
   1675c:	01e7d793          	srli	a5,a5,0x1e
   16760:	00d787b3          	add	a5,a5,a3
   16764:	0007a783          	lw	a5,0(a5) # 2000 <_ftext-0xe000>
   16768:	00078067          	jr	a5
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   1676c:	2e071ee3          	bnez	a4,17268 <_vfiprintf_r+0xcb0>
		uio->uio_iovcnt = 0;
   16770:	06012c23          	sw	zero,120(sp)
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   16774:	000c8413          	mv	s0,s9
   16778:	f91ff06f          	j	16708 <_vfiprintf_r+0x150>
			} else
#endif
				flags |= LONGINT;
			goto rflag;
		case 'q': /* extension */
			flags |= QUADINT;
   1677c:	01036313          	ori	t1,t1,16
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   16780:	000b0813          	mv	a6,s6
   16784:	fc1ff06f          	j	16744 <_vfiprintf_r+0x18c>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   16788:	000d0593          	mv	a1,s10
   1678c:	000a8513          	mv	a0,s5
   16790:	949fb0ef          	jal	120d8 <__swsetup_r>
   16794:	4e0512e3          	bnez	a0,17478 <_vfiprintf_r+0xec0>
   16798:	010d5783          	lhu	a5,16(s10)
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   1679c:	00a00713          	li	a4,10
   167a0:	01a7f793          	andi	a5,a5,26
   167a4:	ece794e3          	bne	a5,a4,1666c <_vfiprintf_r+0xb4>
   167a8:	012d1783          	lh	a5,18(s10)
   167ac:	ec07c0e3          	bltz	a5,1666c <_vfiprintf_r+0xb4>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
   167b0:	00813683          	ld	a3,8(sp)
   167b4:	000b0613          	mv	a2,s6
   167b8:	000d0593          	mv	a1,s10
   167bc:	000a8513          	mv	a0,s5
   167c0:	6a9000ef          	jal	17668 <__sbprintf>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
	/* NOTREACHED */
}
   167c4:	19813083          	ld	ra,408(sp)
   167c8:	19013403          	ld	s0,400(sp)
   167cc:	18813483          	ld	s1,392(sp)
   167d0:	18013903          	ld	s2,384(sp)
   167d4:	17813983          	ld	s3,376(sp)
   167d8:	17013a03          	ld	s4,368(sp)
   167dc:	16813a83          	ld	s5,360(sp)
   167e0:	16013b03          	ld	s6,352(sp)
   167e4:	15813b83          	ld	s7,344(sp)
   167e8:	15013c03          	ld	s8,336(sp)
   167ec:	14813c83          	ld	s9,328(sp)
   167f0:	14013d03          	ld	s10,320(sp)
   167f4:	13813d83          	ld	s11,312(sp)
   167f8:	1a010113          	addi	sp,sp,416
   167fc:	00008067          	ret
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   16800:	de4fd0ef          	jal	13de4 <__sinit>
   16804:	e09ff06f          	j	1660c <_vfiprintf_r+0x54>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   16808:	00813783          	ld	a5,8(sp)
   1680c:	0007a903          	lw	s2,0(a5)
   16810:	00878793          	addi	a5,a5,8
   16814:	00f13423          	sd	a5,8(sp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   16818:	f60954e3          	bgez	s2,16780 <_vfiprintf_r+0x1c8>
				goto rflag;
			width = -width;
   1681c:	4120093b          	negw	s2,s2
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   16820:	00436313          	ori	t1,t1,4
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   16824:	000b0813          	mv	a6,s6
   16828:	f1dff06f          	j	16744 <_vfiprintf_r+0x18c>
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
			ox[0] = '0';
   1682c:	03000793          	li	a5,48
   16830:	06f10423          	sb	a5,104(sp)
			ox[1] = ch = 'x';
   16834:	07800793          	li	a5,120
   16838:	06f104a3          	sb	a5,105(sp)
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   1683c:	00813783          	ld	a5,8(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   16840:	060103a3          	sb	zero,103(sp)
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
   16844:	00236613          	ori	a2,t1,2
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   16848:	00878713          	addi	a4,a5,8
   1684c:	0007b783          	ld	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   16850:	2e04cce3          	bltz	s1,17348 <_vfiprintf_r+0xd90>
   16854:	f7f37313          	andi	t1,t1,-129
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   16858:	00e13423          	sd	a4,8(sp)
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
				flags &= ~ZEROPAD;
   1685c:	00236313          	ori	t1,t1,2
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   16860:	32079ae3          	bnez	a5,17394 <_vfiprintf_r+0xddc>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   16864:	000197b7          	lui	a5,0x19
   16868:	24078793          	addi	a5,a5,576 # 19240 <zeroes.4137+0x50>
   1686c:	00f13c23          	sd	a5,24(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   16870:	00000593          	li	a1,0
   16874:	200498e3          	bnez	s1,17284 <_vfiprintf_r+0xccc>
   16878:	00000493          	li	s1,0
   1687c:	00000a13          	li	s4,0
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   16880:	000c8b93          	mv	s7,s9
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   16884:	00048993          	mv	s3,s1
   16888:	0144d463          	ble	s4,s1,16890 <_vfiprintf_r+0x2d8>
   1688c:	000a0993          	mv	s3,s4
		if (sign)
			realsz++;
   16890:	00b035b3          	snez	a1,a1
   16894:	00b989bb          	addw	s3,s3,a1
		if (flags & HEXPREFIX)
   16898:	00237393          	andi	t2,t1,2
   1689c:	00038463          	beqz	t2,168a4 <_vfiprintf_r+0x2ec>
			realsz+= 2;
   168a0:	0029899b          	addiw	s3,s3,2

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   168a4:	08437293          	andi	t0,t1,132
   168a8:	58029463          	bnez	t0,16e30 <_vfiprintf_r+0x878>
			PAD (width - realsz, blanks);
   168ac:	41390dbb          	subw	s11,s2,s3
   168b0:	59b05063          	blez	s11,16e30 <_vfiprintf_r+0x878>
   168b4:	01000793          	li	a5,16
   168b8:	45b7dee3          	ble	s11,a5,17514 <_vfiprintf_r+0xf5c>
   168bc:	01000e93          	li	t4,16
   168c0:	08013783          	ld	a5,128(sp)
   168c4:	07812503          	lw	a0,120(sp)
   168c8:	05813823          	sd	s8,80(sp)
   168cc:	00700f13          	li	t5,7
   168d0:	000e8f93          	mv	t6,t4
   168d4:	0180006f          	j	168ec <_vfiprintf_r+0x334>
   168d8:	0025061b          	addiw	a2,a0,2
   168dc:	01040413          	addi	s0,s0,16
   168e0:	00058513          	mv	a0,a1
   168e4:	ff0d8d9b          	addiw	s11,s11,-16
   168e8:	03bfdc63          	ble	s11,t6,16920 <_vfiprintf_r+0x368>
   168ec:	01078793          	addi	a5,a5,16
   168f0:	0015059b          	addiw	a1,a0,1
   168f4:	01843023          	sd	s8,0(s0)
   168f8:	01d43423          	sd	t4,8(s0)
   168fc:	08f13023          	sd	a5,128(sp)
   16900:	06b12c23          	sw	a1,120(sp)
   16904:	fcbf5ae3          	ble	a1,t5,168d8 <_vfiprintf_r+0x320>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   16908:	4c079863          	bnez	a5,16dd8 <_vfiprintf_r+0x820>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   1690c:	ff0d8d9b          	addiw	s11,s11,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   16910:	00000513          	li	a0,0
   16914:	00100613          	li	a2,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   16918:	000c8413          	mv	s0,s9
   1691c:	fdbfc8e3          	blt	t6,s11,168ec <_vfiprintf_r+0x334>
   16920:	05013703          	ld	a4,80(sp)
   16924:	00fd87b3          	add	a5,s11,a5
   16928:	01b43423          	sd	s11,8(s0)
   1692c:	00e43023          	sd	a4,0(s0)
   16930:	08f13023          	sd	a5,128(sp)
   16934:	06c12c23          	sw	a2,120(sp)
   16938:	00700593          	li	a1,7
   1693c:	7ac5cc63          	blt	a1,a2,170f4 <_vfiprintf_r+0xb3c>

		/* prefix */
		if (sign)
   16940:	06714503          	lbu	a0,103(sp)
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   16944:	01040413          	addi	s0,s0,16
   16948:	0016059b          	addiw	a1,a2,1

		/* prefix */
		if (sign)
   1694c:	4e051c63          	bnez	a0,16e44 <_vfiprintf_r+0x88c>
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   16950:	52038663          	beqz	t2,16e7c <_vfiprintf_r+0x8c4>
			PRINT (ox, 2);
   16954:	06810613          	addi	a2,sp,104
   16958:	00278793          	addi	a5,a5,2
   1695c:	00c43023          	sd	a2,0(s0)
   16960:	00200613          	li	a2,2
   16964:	00c43423          	sd	a2,8(s0)
   16968:	08f13023          	sd	a5,128(sp)
   1696c:	06b12c23          	sw	a1,120(sp)
   16970:	00700613          	li	a2,7
   16974:	7cb65863          	ble	a1,a2,17144 <_vfiprintf_r+0xb8c>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   16978:	10079ae3          	bnez	a5,1728c <_vfiprintf_r+0xcd4>
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   1697c:	08000513          	li	a0,128
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   16980:	00100593          	li	a1,1
   16984:	00000613          	li	a2,0

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   16988:	000c8413          	mv	s0,s9

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   1698c:	4ea29c63          	bne	t0,a0,16e84 <_vfiprintf_r+0x8cc>
			PAD (width - realsz, zeroes);
   16990:	41390ebb          	subw	t4,s2,s3
   16994:	4fd05863          	blez	t4,16e84 <_vfiprintf_r+0x8cc>
   16998:	01000513          	li	a0,16
   1699c:	3fd55ce3          	ble	t4,a0,17594 <_vfiprintf_r+0xfdc>
   169a0:	01000f13          	li	t5,16
   169a4:	00019737          	lui	a4,0x19
   169a8:	1f070d93          	addi	s11,a4,496 # 191f0 <zeroes.4137>
   169ac:	00700f93          	li	t6,7
   169b0:	000f0293          	mv	t0,t5
   169b4:	0180006f          	j	169cc <_vfiprintf_r+0x414>
   169b8:	0026051b          	addiw	a0,a2,2
   169bc:	01040413          	addi	s0,s0,16
   169c0:	00058613          	mv	a2,a1
   169c4:	ff0e8e9b          	addiw	t4,t4,-16
   169c8:	03d2dc63          	ble	t4,t0,16a00 <_vfiprintf_r+0x448>
   169cc:	01078793          	addi	a5,a5,16
   169d0:	0016059b          	addiw	a1,a2,1
   169d4:	01b43023          	sd	s11,0(s0)
   169d8:	01e43423          	sd	t5,8(s0)
   169dc:	08f13023          	sd	a5,128(sp)
   169e0:	06b12c23          	sw	a1,120(sp)
   169e4:	fcbfdae3          	ble	a1,t6,169b8 <_vfiprintf_r+0x400>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   169e8:	6a079e63          	bnez	a5,170a4 <_vfiprintf_r+0xaec>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   169ec:	ff0e8e9b          	addiw	t4,t4,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   169f0:	00100513          	li	a0,1
   169f4:	00000613          	li	a2,0
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   169f8:	000c8413          	mv	s0,s9
   169fc:	fdd2c8e3          	blt	t0,t4,169cc <_vfiprintf_r+0x414>
   16a00:	01d787b3          	add	a5,a5,t4
   16a04:	01b43023          	sd	s11,0(s0)
   16a08:	01d43423          	sd	t4,8(s0)
   16a0c:	08f13023          	sd	a5,128(sp)
   16a10:	06a12c23          	sw	a0,120(sp)
   16a14:	00700613          	li	a2,7
   16a18:	0ea646e3          	blt	a2,a0,17304 <_vfiprintf_r+0xd4c>

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   16a1c:	414484bb          	subw	s1,s1,s4
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   16a20:	01040413          	addi	s0,s0,16
   16a24:	0015059b          	addiw	a1,a0,1
   16a28:	00050613          	mv	a2,a0

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   16a2c:	46904063          	bgtz	s1,16e8c <_vfiprintf_r+0x8d4>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   16a30:	00fa07b3          	add	a5,s4,a5
   16a34:	01743023          	sd	s7,0(s0)
   16a38:	01443423          	sd	s4,8(s0)
   16a3c:	08f13023          	sd	a5,128(sp)
   16a40:	06b12c23          	sw	a1,120(sp)
   16a44:	00700713          	li	a4,7
   16a48:	4eb75a63          	ble	a1,a4,16f3c <_vfiprintf_r+0x984>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   16a4c:	7a079463          	bnez	a5,171f4 <_vfiprintf_r+0xc3c>
		uio->uio_iovcnt = 0;
   16a50:	06012c23          	sw	zero,120(sp)
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   16a54:	00437313          	andi	t1,t1,4
   16a58:	00030663          	beqz	t1,16a64 <_vfiprintf_r+0x4ac>
			PAD (width - realsz, blanks);
   16a5c:	413904bb          	subw	s1,s2,s3
   16a60:	229040e3          	bgtz	s1,17480 <_vfiprintf_r+0xec8>

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   16a64:	01395463          	ble	s3,s2,16a6c <_vfiprintf_r+0x4b4>
   16a68:	00098913          	mv	s2,s3
   16a6c:	05812783          	lw	a5,88(sp)
   16a70:	012787bb          	addw	a5,a5,s2
   16a74:	04f12c23          	sw	a5,88(sp)

		FLUSH ();	/* copy out the I/O vectors */
   16a78:	06012c23          	sw	zero,120(sp)
   16a7c:	000c8413          	mv	s0,s9
   16a80:	c29ff06f          	j	166a8 <_vfiprintf_r+0xf0>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   16a84:	00100513          	li	a0,1
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
   16a88:	02b00e93          	li	t4,43
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   16a8c:	000b0813          	mv	a6,s6
   16a90:	cb5ff06f          	j	16744 <_vfiprintf_r+0x18c>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   16a94:	08036313          	ori	t1,t1,128
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   16a98:	000b0813          	mv	a6,s6
   16a9c:	ca9ff06f          	j	16744 <_vfiprintf_r+0x18c>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   16aa0:	00000913          	li	s2,0
   16aa4:	fd07079b          	addiw	a5,a4,-48
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   16aa8:	001b0b13          	addi	s6,s6,1
   16aac:	fffb4703          	lbu	a4,-1(s6)
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
   16ab0:	00191f9b          	slliw	t6,s2,0x1
   16ab4:	0039191b          	slliw	s2,s2,0x3
   16ab8:	012f893b          	addw	s2,t6,s2
   16abc:	0127893b          	addw	s2,a5,s2
				ch = *fmt++;
			} while (is_digit (ch));
   16ac0:	fd07079b          	addiw	a5,a4,-48
   16ac4:	fef5f2e3          	bleu	a5,a1,16aa8 <_vfiprintf_r+0x4f0>
   16ac8:	c85ff06f          	j	1674c <_vfiprintf_r+0x194>
   16acc:	360518e3          	bnez	a0,1763c <_vfiprintf_r+0x1084>
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   16ad0:	01036313          	ori	t1,t1,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   16ad4:	01037793          	andi	a5,t1,16
   16ad8:	74078263          	beqz	a5,1721c <_vfiprintf_r+0xc64>
   16adc:	00813703          	ld	a4,8(sp)
   16ae0:	00073783          	ld	a5,0(a4)
   16ae4:	00870713          	addi	a4,a4,8
   16ae8:	00e13423          	sd	a4,8(sp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
#else
			if ((long) _uquad < 0)
   16aec:	0e07c6e3          	bltz	a5,173d8 <_vfiprintf_r+0xe20>
   16af0:	06714583          	lbu	a1,103(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   16af4:	6e04c063          	bltz	s1,171d4 <_vfiprintf_r+0xc1c>
				flags &= ~ZEROPAD;
   16af8:	f7f37313          	andi	t1,t1,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   16afc:	10078c63          	beqz	a5,16c14 <_vfiprintf_r+0x65c>
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   16b00:	00900613          	li	a2,9
   16b04:	000c8b93          	mv	s7,s9
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   16b08:	00a00513          	li	a0,10
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   16b0c:	10f67863          	bleu	a5,a2,16c1c <_vfiprintf_r+0x664>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   16b10:	02a7f633          	remu	a2,a5,a0
   16b14:	fffb8b93          	addi	s7,s7,-1
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
   16b18:	02a7d7b3          	divu	a5,a5,a0
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   16b1c:	0306061b          	addiw	a2,a2,48
   16b20:	00cb8023          	sb	a2,0(s7)
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
					} while (_uquad != 0);
   16b24:	fe0796e3          	bnez	a5,16b10 <_vfiprintf_r+0x558>
   16b28:	417c8a3b          	subw	s4,s9,s7
   16b2c:	d59ff06f          	j	16884 <_vfiprintf_r+0x2cc>
   16b30:	300512e3          	bnez	a0,17634 <_vfiprintf_r+0x107c>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   16b34:	01036313          	ori	t1,t1,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   16b38:	01037793          	andi	a5,t1,16
   16b3c:	6e078e63          	beqz	a5,17238 <_vfiprintf_r+0xc80>
   16b40:	00813783          	ld	a5,8(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   16b44:	060103a3          	sb	zero,103(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   16b48:	00878713          	addi	a4,a5,8
   16b4c:	0007b783          	ld	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   16b50:	7004c263          	bltz	s1,17254 <_vfiprintf_r+0xc9c>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   16b54:	00e13423          	sd	a4,8(sp)
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
				flags &= ~ZEROPAD;
   16b58:	f7f37313          	andi	t1,t1,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   16b5c:	70079263          	bnez	a5,17260 <_vfiprintf_r+0xca8>
   16b60:	00000593          	li	a1,0
   16b64:	00000793          	li	a5,0
   16b68:	2a0482e3          	beqz	s1,1760c <_vfiprintf_r+0x1054>
   16b6c:	000c8b93          	mv	s7,s9
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   16b70:	0077f613          	andi	a2,a5,7
   16b74:	fffb8b93          	addi	s7,s7,-1
   16b78:	0306061b          	addiw	a2,a2,48
   16b7c:	00cb8023          	sb	a2,0(s7)
						_uquad >>= 3;
   16b80:	0037d793          	srli	a5,a5,0x3
					} while (_uquad);
   16b84:	fe0796e3          	bnez	a5,16b70 <_vfiprintf_r+0x5b8>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   16b88:	00137793          	andi	a5,t1,1
   16b8c:	f8078ee3          	beqz	a5,16b28 <_vfiprintf_r+0x570>
   16b90:	03000793          	li	a5,48
   16b94:	f8f60ae3          	beq	a2,a5,16b28 <_vfiprintf_r+0x570>
						*--cp = '0';
   16b98:	fffb8613          	addi	a2,s7,-1
   16b9c:	40cc8a33          	sub	s4,s9,a2
   16ba0:	fefb8fa3          	sb	a5,-1(s7)
   16ba4:	000a0a1b          	sext.w	s4,s4
   16ba8:	00060b93          	mv	s7,a2
   16bac:	cd9ff06f          	j	16884 <_vfiprintf_r+0x2cc>
   16bb0:	28051ee3          	bnez	a0,1764c <_vfiprintf_r+0x1094>
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
   16bb4:	01037793          	andi	a5,t1,16
   16bb8:	040786e3          	beqz	a5,17404 <_vfiprintf_r+0xe4c>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   16bbc:	00813683          	ld	a3,8(sp)
   16bc0:	05812703          	lw	a4,88(sp)
   16bc4:	0006b783          	ld	a5,0(a3) # 7ff00000 <_gp+0x7fee4530>
   16bc8:	00868693          	addi	a3,a3,8
   16bcc:	00d13423          	sd	a3,8(sp)
   16bd0:	00e7b023          	sd	a4,0(a5)
   16bd4:	ad5ff06f          	j	166a8 <_vfiprintf_r+0xf0>
   16bd8:	260516e3          	bnez	a0,17644 <_vfiprintf_r+0x108c>
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   16bdc:	01036313          	ori	t1,t1,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   16be0:	01037793          	andi	a5,t1,16
   16be4:	5c079a63          	bnez	a5,171b8 <_vfiprintf_r+0xc00>
   16be8:	04037793          	andi	a5,t1,64

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   16bec:	060103a3          	sb	zero,103(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   16bf0:	7c078063          	beqz	a5,173b0 <_vfiprintf_r+0xdf8>
   16bf4:	00813783          	ld	a5,8(sp)
   16bf8:	00878713          	addi	a4,a5,8
   16bfc:	0007d783          	lhu	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   16c00:	5c04c663          	bltz	s1,171cc <_vfiprintf_r+0xc14>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   16c04:	00e13423          	sd	a4,8(sp)
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
				flags &= ~ZEROPAD;
   16c08:	f7f37313          	andi	t1,t1,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   16c0c:	00000593          	li	a1,0
   16c10:	ee0798e3          	bnez	a5,16b00 <_vfiprintf_r+0x548>
   16c14:	c60482e3          	beqz	s1,16878 <_vfiprintf_r+0x2c0>
   16c18:	00000793          	li	a5,0
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
						*--cp = to_char(_uquad);
   16c1c:	0307879b          	addiw	a5,a5,48
   16c20:	0af107a3          	sb	a5,175(sp)
   16c24:	05c12a03          	lw	s4,92(sp)
   16c28:	0af10b93          	addi	s7,sp,175
						break;
   16c2c:	c59ff06f          	j	16884 <_vfiprintf_r+0x2cc>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   16c30:	b40e98e3          	bnez	t4,16780 <_vfiprintf_r+0x1c8>
   16c34:	00100513          	li	a0,1
				sign = ' ';
   16c38:	02000e93          	li	t4,32
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   16c3c:	000b0813          	mv	a6,s6
   16c40:	b05ff06f          	j	16744 <_vfiprintf_r+0x18c>
			 */
			if (!sign)
				sign = ' ';
			goto rflag;
		case '#':
			flags |= ALT;
   16c44:	00136313          	ori	t1,t1,1
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   16c48:	000b0813          	mv	a6,s6
   16c4c:	af9ff06f          	j	16744 <_vfiprintf_r+0x18c>
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   16c50:	00813783          	ld	a5,8(sp)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   16c54:	060103a3          	sb	zero,103(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   16c58:	0007bb83          	ld	s7,0(a5)
   16c5c:	00878d93          	addi	s11,a5,8
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   16c60:	0e0b84e3          	beqz	s7,17548 <_vfiprintf_r+0xf90>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   16c64:	0404cee3          	bltz	s1,174c0 <_vfiprintf_r+0xf08>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   16c68:	00048613          	mv	a2,s1
   16c6c:	00000593          	li	a1,0
   16c70:	000b8513          	mv	a0,s7
   16c74:	00613423          	sd	t1,8(sp)
   16c78:	928fe0ef          	jal	14da0 <memchr>

				if (p != NULL)
   16c7c:	00813303          	ld	t1,8(sp)
   16c80:	120502e3          	beqz	a0,175a4 <_vfiprintf_r+0xfec>
					size = p - cp;
   16c84:	41750a3b          	subw	s4,a0,s7
   16c88:	06714583          	lbu	a1,103(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   16c8c:	01b13423          	sd	s11,8(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   16c90:	00000493          	li	s1,0
   16c94:	bf1ff06f          	j	16884 <_vfiprintf_r+0x2cc>
   16c98:	f40504e3          	beqz	a0,16be0 <_vfiprintf_r+0x628>
   16c9c:	07d103a3          	sb	t4,103(sp)
   16ca0:	f41ff06f          	j	16be0 <_vfiprintf_r+0x628>
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   16ca4:	00813703          	ld	a4,8(sp)
				size = 1;
			}
			sign = '\0';
			break;
   16ca8:	00100993          	li	s3,1
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
				size = 1;
			}
			sign = '\0';
   16cac:	060103a3          	sb	zero,103(sp)
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   16cb0:	00072783          	lw	a5,0(a4)
				size = 1;
   16cb4:	00098a13          	mv	s4,s3
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   16cb8:	08810b93          	addi	s7,sp,136
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   16cbc:	08f10423          	sb	a5,136(sp)
   16cc0:	00870793          	addi	a5,a4,8
   16cc4:	00f13423          	sd	a5,8(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   16cc8:	00000493          	li	s1,0
   16ccc:	bcdff06f          	j	16898 <_vfiprintf_r+0x2e0>
   16cd0:	e00502e3          	beqz	a0,16ad4 <_vfiprintf_r+0x51c>
   16cd4:	07d103a3          	sb	t4,103(sp)
   16cd8:	dfdff06f          	j	16ad4 <_vfiprintf_r+0x51c>
   16cdc:	120510e3          	bnez	a0,175fc <_vfiprintf_r+0x1044>
		case 'u':
			_uquad = UARG ();
			base = DEC;
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
   16ce0:	000197b7          	lui	a5,0x19
   16ce4:	22878793          	addi	a5,a5,552 # 19228 <zeroes.4137+0x38>
   16ce8:	00f13c23          	sd	a5,24(sp)
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   16cec:	01037793          	andi	a5,t1,16
   16cf0:	06078063          	beqz	a5,16d50 <_vfiprintf_r+0x798>
   16cf4:	00813683          	ld	a3,8(sp)
   16cf8:	0006b783          	ld	a5,0(a3)
   16cfc:	00868693          	addi	a3,a3,8
   16d00:	00d13423          	sd	a3,8(sp)
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   16d04:	00137613          	andi	a2,t1,1
   16d08:	46060863          	beqz	a2,17178 <_vfiprintf_r+0xbc0>
   16d0c:	66079063          	bnez	a5,1736c <_vfiprintf_r+0xdb4>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   16d10:	060103a3          	sb	zero,103(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   16d14:	6404c663          	bltz	s1,17360 <_vfiprintf_r+0xda8>
				flags &= ~ZEROPAD;
   16d18:	f7f37313          	andi	t1,t1,-129
   16d1c:	b55ff06f          	j	16870 <_vfiprintf_r+0x2b8>
   16d20:	e0050ce3          	beqz	a0,16b38 <_vfiprintf_r+0x580>
   16d24:	07d103a3          	sb	t4,103(sp)
   16d28:	e11ff06f          	j	16b38 <_vfiprintf_r+0x580>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
   16d2c:	04036313          	ori	t1,t1,64
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   16d30:	000b0813          	mv	a6,s6
   16d34:	a11ff06f          	j	16744 <_vfiprintf_r+0x18c>
   16d38:	0a051ee3          	bnez	a0,175f4 <_vfiprintf_r+0x103c>
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
   16d3c:	000197b7          	lui	a5,0x19
   16d40:	24078793          	addi	a5,a5,576 # 19240 <zeroes.4137+0x50>
   16d44:	00f13c23          	sd	a5,24(sp)
hex:			_uquad = UARG ();
   16d48:	01037793          	andi	a5,t1,16
   16d4c:	fa0794e3          	bnez	a5,16cf4 <_vfiprintf_r+0x73c>
   16d50:	04037793          	andi	a5,t1,64
   16d54:	00813683          	ld	a3,8(sp)
   16d58:	68078e63          	beqz	a5,173f4 <_vfiprintf_r+0xe3c>
   16d5c:	0006d783          	lhu	a5,0(a3)
   16d60:	00868693          	addi	a3,a3,8
   16d64:	00d13423          	sd	a3,8(sp)
   16d68:	f9dff06f          	j	16d04 <_vfiprintf_r+0x74c>
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   16d6c:	000b4703          	lbu	a4,0(s6)
   16d70:	001b0813          	addi	a6,s6,1
   16d74:	05e70ee3          	beq	a4,t5,175d0 <_vfiprintf_r+0x1018>
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   16d78:	fd07079b          	addiw	a5,a4,-48
   16d7c:	00000493          	li	s1,0
   16d80:	00080b13          	mv	s6,a6
   16d84:	9cf5e4e3          	bltu	a1,a5,1674c <_vfiprintf_r+0x194>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   16d88:	001b0b13          	addi	s6,s6,1
   16d8c:	fffb4703          	lbu	a4,-1(s6)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
				n = 10 * n + to_digit (ch);
   16d90:	00149f9b          	slliw	t6,s1,0x1
   16d94:	0034949b          	slliw	s1,s1,0x3
   16d98:	009f84bb          	addw	s1,t6,s1
   16d9c:	00f484bb          	addw	s1,s1,a5
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   16da0:	fd07079b          	addiw	a5,a4,-48
   16da4:	fef5f2e3          	bleu	a5,a1,16d88 <_vfiprintf_r+0x7d0>
   16da8:	9a04d2e3          	bgez	s1,1674c <_vfiprintf_r+0x194>
   16dac:	fff00493          	li	s1,-1
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
			goto reswitch;
   16db0:	99dff06f          	j	1674c <_vfiprintf_r+0x194>
   16db4:	040518e3          	bnez	a0,17604 <_vfiprintf_r+0x104c>

			size = buf + BUF - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   16db8:	6e070663          	beqz	a4,174a4 <_vfiprintf_r+0xeec>
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   16dbc:	00100993          	li	s3,1
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
   16dc0:	08e10423          	sb	a4,136(sp)
			size = 1;
			sign = '\0';
   16dc4:	060103a3          	sb	zero,103(sp)
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
   16dc8:	00098a13          	mv	s4,s3
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
   16dcc:	08810b93          	addi	s7,sp,136
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   16dd0:	00000493          	li	s1,0
   16dd4:	ac5ff06f          	j	16898 <_vfiprintf_r+0x2e0>
   16dd8:	07010613          	addi	a2,sp,112
   16ddc:	000d0593          	mv	a1,s10
   16de0:	000a8513          	mv	a0,s5
   16de4:	05f13423          	sd	t6,72(sp)
   16de8:	05e13023          	sd	t5,64(sp)
   16dec:	03d13c23          	sd	t4,56(sp)
   16df0:	02513823          	sd	t0,48(sp)
   16df4:	02713423          	sd	t2,40(sp)
   16df8:	02613023          	sd	t1,32(sp)
   16dfc:	eb8ff0ef          	jal	164b4 <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   16e00:	22051063          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   16e04:	07812503          	lw	a0,120(sp)
   16e08:	08013783          	ld	a5,128(sp)
   16e0c:	000c8413          	mv	s0,s9
   16e10:	0015061b          	addiw	a2,a0,1
   16e14:	04813f83          	ld	t6,72(sp)
   16e18:	04013f03          	ld	t5,64(sp)
   16e1c:	03813e83          	ld	t4,56(sp)
   16e20:	03013283          	ld	t0,48(sp)
   16e24:	02813383          	ld	t2,40(sp)
   16e28:	02013303          	ld	t1,32(sp)
   16e2c:	ab9ff06f          	j	168e4 <_vfiprintf_r+0x32c>
   16e30:	07812603          	lw	a2,120(sp)
   16e34:	08013783          	ld	a5,128(sp)
   16e38:	0016059b          	addiw	a1,a2,1

		/* prefix */
		if (sign)
   16e3c:	06714503          	lbu	a0,103(sp)
   16e40:	b00508e3          	beqz	a0,16950 <_vfiprintf_r+0x398>
			PRINT (&sign, 1);
   16e44:	00100513          	li	a0,1
   16e48:	06710613          	addi	a2,sp,103
   16e4c:	00a787b3          	add	a5,a5,a0
   16e50:	00c43023          	sd	a2,0(s0)
   16e54:	00a43423          	sd	a0,8(s0)
   16e58:	08f13023          	sd	a5,128(sp)
   16e5c:	06b12c23          	sw	a1,120(sp)
   16e60:	00700613          	li	a2,7
   16e64:	2ab65a63          	ble	a1,a2,17118 <_vfiprintf_r+0xb60>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   16e68:	44079e63          	bnez	a5,172c4 <_vfiprintf_r+0xd0c>
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   16e6c:	2c039063          	bnez	t2,1712c <_vfiprintf_r+0xb74>
   16e70:	00000613          	li	a2,0
   16e74:	00050593          	mv	a1,a0
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   16e78:	000c8413          	mv	s0,s9
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   16e7c:	08000513          	li	a0,128
   16e80:	b0a288e3          	beq	t0,a0,16990 <_vfiprintf_r+0x3d8>
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   16e84:	414484bb          	subw	s1,s1,s4
   16e88:	ba9054e3          	blez	s1,16a30 <_vfiprintf_r+0x478>
   16e8c:	00019737          	lui	a4,0x19
   16e90:	01000513          	li	a0,16
   16e94:	1f070d93          	addi	s11,a4,496 # 191f0 <zeroes.4137>
   16e98:	06955263          	ble	s1,a0,16efc <_vfiprintf_r+0x944>
   16e9c:	01000e93          	li	t4,16
   16ea0:	00019737          	lui	a4,0x19
   16ea4:	1f070d93          	addi	s11,a4,496 # 191f0 <zeroes.4137>
   16ea8:	00700f13          	li	t5,7
   16eac:	000e8f93          	mv	t6,t4
   16eb0:	0180006f          	j	16ec8 <_vfiprintf_r+0x910>
   16eb4:	0026059b          	addiw	a1,a2,2
   16eb8:	01040413          	addi	s0,s0,16
   16ebc:	00050613          	mv	a2,a0
   16ec0:	ff04849b          	addiw	s1,s1,-16
   16ec4:	029fdc63          	ble	s1,t6,16efc <_vfiprintf_r+0x944>
   16ec8:	01078793          	addi	a5,a5,16
   16ecc:	0016051b          	addiw	a0,a2,1
   16ed0:	01b43023          	sd	s11,0(s0)
   16ed4:	01d43423          	sd	t4,8(s0)
   16ed8:	08f13023          	sd	a5,128(sp)
   16edc:	06a12c23          	sw	a0,120(sp)
   16ee0:	fcaf5ae3          	ble	a0,t5,16eb4 <_vfiprintf_r+0x8fc>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   16ee4:	14079863          	bnez	a5,17034 <_vfiprintf_r+0xa7c>
		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   16ee8:	ff04849b          	addiw	s1,s1,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   16eec:	00100593          	li	a1,1
   16ef0:	00000613          	li	a2,0
		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   16ef4:	000c8413          	mv	s0,s9
   16ef8:	fc9fc8e3          	blt	t6,s1,16ec8 <_vfiprintf_r+0x910>
   16efc:	009787b3          	add	a5,a5,s1
   16f00:	01b43023          	sd	s11,0(s0)
   16f04:	00943423          	sd	s1,8(s0)
   16f08:	08f13023          	sd	a5,128(sp)
   16f0c:	06b12c23          	sw	a1,120(sp)
   16f10:	00700613          	li	a2,7
   16f14:	24b64063          	blt	a2,a1,17154 <_vfiprintf_r+0xb9c>
   16f18:	01040413          	addi	s0,s0,16
   16f1c:	0015859b          	addiw	a1,a1,1
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   16f20:	00fa07b3          	add	a5,s4,a5
   16f24:	01743023          	sd	s7,0(s0)
   16f28:	01443423          	sd	s4,8(s0)
   16f2c:	08f13023          	sd	a5,128(sp)
   16f30:	06b12c23          	sw	a1,120(sp)
   16f34:	00700713          	li	a4,7
   16f38:	b0b74ae3          	blt	a4,a1,16a4c <_vfiprintf_r+0x494>
   16f3c:	01040413          	addi	s0,s0,16
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   16f40:	00437313          	andi	t1,t1,4
   16f44:	0a030863          	beqz	t1,16ff4 <_vfiprintf_r+0xa3c>
			PAD (width - realsz, blanks);
   16f48:	413904bb          	subw	s1,s2,s3
   16f4c:	0a905463          	blez	s1,16ff4 <_vfiprintf_r+0xa3c>
   16f50:	01000713          	li	a4,16
   16f54:	62975863          	ble	s1,a4,17584 <_vfiprintf_r+0xfcc>
   16f58:	01000a13          	li	s4,16
   16f5c:	07812603          	lw	a2,120(sp)
   16f60:	05813823          	sd	s8,80(sp)
   16f64:	00700d93          	li	s11,7
   16f68:	000a0b93          	mv	s7,s4
   16f6c:	0180006f          	j	16f84 <_vfiprintf_r+0x9cc>
   16f70:	0026059b          	addiw	a1,a2,2
   16f74:	01040413          	addi	s0,s0,16
   16f78:	00070613          	mv	a2,a4
   16f7c:	ff04849b          	addiw	s1,s1,-16
   16f80:	029bdc63          	ble	s1,s7,16fb8 <_vfiprintf_r+0xa00>
   16f84:	01078793          	addi	a5,a5,16
   16f88:	0016071b          	addiw	a4,a2,1
   16f8c:	01843023          	sd	s8,0(s0)
   16f90:	01443423          	sd	s4,8(s0)
   16f94:	08f13023          	sd	a5,128(sp)
   16f98:	06e12c23          	sw	a4,120(sp)
   16f9c:	fceddae3          	ble	a4,s11,16f70 <_vfiprintf_r+0x9b8>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   16fa0:	0c079e63          	bnez	a5,1707c <_vfiprintf_r+0xac4>
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   16fa4:	ff04849b          	addiw	s1,s1,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   16fa8:	00100593          	li	a1,1
   16fac:	00000613          	li	a2,0
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   16fb0:	000c8413          	mv	s0,s9
   16fb4:	fc9bc8e3          	blt	s7,s1,16f84 <_vfiprintf_r+0x9cc>
   16fb8:	05013703          	ld	a4,80(sp)
   16fbc:	009787b3          	add	a5,a5,s1
   16fc0:	00943423          	sd	s1,8(s0)
   16fc4:	00e43023          	sd	a4,0(s0)
   16fc8:	08f13023          	sd	a5,128(sp)
   16fcc:	06b12c23          	sw	a1,120(sp)
   16fd0:	00700713          	li	a4,7
   16fd4:	02b75063          	ble	a1,a4,16ff4 <_vfiprintf_r+0xa3c>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   16fd8:	a80786e3          	beqz	a5,16a64 <_vfiprintf_r+0x4ac>
   16fdc:	07010613          	addi	a2,sp,112
   16fe0:	000d0593          	mv	a1,s10
   16fe4:	000a8513          	mv	a0,s5
   16fe8:	cccff0ef          	jal	164b4 <__sprint_r.part.0>
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   16fec:	02051a63          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   16ff0:	08013783          	ld	a5,128(sp)

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   16ff4:	01395463          	ble	s3,s2,16ffc <_vfiprintf_r+0xa44>
   16ff8:	00098913          	mv	s2,s3
   16ffc:	05812703          	lw	a4,88(sp)
   17000:	0127073b          	addw	a4,a4,s2
   17004:	04e12c23          	sw	a4,88(sp)

		FLUSH ();	/* copy out the I/O vectors */
   17008:	a60788e3          	beqz	a5,16a78 <_vfiprintf_r+0x4c0>
   1700c:	07010613          	addi	a2,sp,112
   17010:	000d0593          	mv	a1,s10
   17014:	000a8513          	mv	a0,s5
   17018:	c9cff0ef          	jal	164b4 <__sprint_r.part.0>
   1701c:	a4050ee3          	beqz	a0,16a78 <_vfiprintf_r+0x4c0>
	if (malloc_buf != NULL)
		_free_r (data, malloc_buf);
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   17020:	010d5783          	lhu	a5,16(s10)
   17024:	0407f793          	andi	a5,a5,64
   17028:	44079863          	bnez	a5,17478 <_vfiprintf_r+0xec0>
   1702c:	05812503          	lw	a0,88(sp)
   17030:	f94ff06f          	j	167c4 <_vfiprintf_r+0x20c>
   17034:	07010613          	addi	a2,sp,112
   17038:	000d0593          	mv	a1,s10
   1703c:	000a8513          	mv	a0,s5
   17040:	03f13c23          	sd	t6,56(sp)
   17044:	03e13823          	sd	t5,48(sp)
   17048:	03d13423          	sd	t4,40(sp)
   1704c:	02613023          	sd	t1,32(sp)
   17050:	c64ff0ef          	jal	164b4 <__sprint_r.part.0>
		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   17054:	fc0516e3          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   17058:	07812603          	lw	a2,120(sp)
   1705c:	08013783          	ld	a5,128(sp)
   17060:	000c8413          	mv	s0,s9
   17064:	0016059b          	addiw	a1,a2,1
   17068:	03813f83          	ld	t6,56(sp)
   1706c:	03013f03          	ld	t5,48(sp)
   17070:	02813e83          	ld	t4,40(sp)
   17074:	02013303          	ld	t1,32(sp)
   17078:	e49ff06f          	j	16ec0 <_vfiprintf_r+0x908>
   1707c:	07010613          	addi	a2,sp,112
   17080:	000d0593          	mv	a1,s10
   17084:	000a8513          	mv	a0,s5
   17088:	c2cff0ef          	jal	164b4 <__sprint_r.part.0>
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   1708c:	f8051ae3          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   17090:	07812603          	lw	a2,120(sp)
   17094:	08013783          	ld	a5,128(sp)
   17098:	000c8413          	mv	s0,s9
   1709c:	0016059b          	addiw	a1,a2,1
   170a0:	eddff06f          	j	16f7c <_vfiprintf_r+0x9c4>
   170a4:	07010613          	addi	a2,sp,112
   170a8:	000d0593          	mv	a1,s10
   170ac:	000a8513          	mv	a0,s5
   170b0:	04513023          	sd	t0,64(sp)
   170b4:	03f13c23          	sd	t6,56(sp)
   170b8:	03e13823          	sd	t5,48(sp)
   170bc:	03d13423          	sd	t4,40(sp)
   170c0:	02613023          	sd	t1,32(sp)
   170c4:	bf0ff0ef          	jal	164b4 <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   170c8:	f4051ce3          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   170cc:	07812603          	lw	a2,120(sp)
   170d0:	08013783          	ld	a5,128(sp)
   170d4:	000c8413          	mv	s0,s9
   170d8:	0016051b          	addiw	a0,a2,1
   170dc:	04013283          	ld	t0,64(sp)
   170e0:	03813f83          	ld	t6,56(sp)
   170e4:	03013f03          	ld	t5,48(sp)
   170e8:	02813e83          	ld	t4,40(sp)
   170ec:	02013303          	ld	t1,32(sp)
   170f0:	8d5ff06f          	j	169c4 <_vfiprintf_r+0x40c>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   170f4:	34079263          	bnez	a5,17438 <_vfiprintf_r+0xe80>
		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
   170f8:	06714603          	lbu	a2,103(sp)
   170fc:	02060663          	beqz	a2,17128 <_vfiprintf_r+0xb70>
			PRINT (&sign, 1);
   17100:	00100793          	li	a5,1
   17104:	06710613          	addi	a2,sp,103
   17108:	0ac13823          	sd	a2,176(sp)
   1710c:	0af13c23          	sd	a5,184(sp)
   17110:	00078593          	mv	a1,a5
   17114:	000c8413          	mv	s0,s9
   17118:	00058613          	mv	a2,a1
   1711c:	01040413          	addi	s0,s0,16
   17120:	0015859b          	addiw	a1,a1,1
   17124:	82dff06f          	j	16950 <_vfiprintf_r+0x398>
		if (flags & HEXPREFIX)
   17128:	36038063          	beqz	t2,17488 <_vfiprintf_r+0xed0>
			PRINT (ox, 2);
   1712c:	00200793          	li	a5,2
   17130:	06810613          	addi	a2,sp,104
   17134:	0ac13823          	sd	a2,176(sp)
   17138:	0af13c23          	sd	a5,184(sp)
   1713c:	00100593          	li	a1,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   17140:	000c8413          	mv	s0,s9

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   17144:	00058613          	mv	a2,a1
   17148:	01040413          	addi	s0,s0,16
   1714c:	0015859b          	addiw	a1,a1,1
   17150:	d2dff06f          	j	16e7c <_vfiprintf_r+0x8c4>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   17154:	1c079263          	bnez	a5,17318 <_vfiprintf_r+0xd60>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   17158:	00100713          	li	a4,1
   1715c:	000a0793          	mv	a5,s4
   17160:	0b713823          	sd	s7,176(sp)
   17164:	0b413c23          	sd	s4,184(sp)
   17168:	09413023          	sd	s4,128(sp)
   1716c:	06e12c23          	sw	a4,120(sp)
   17170:	000c8413          	mv	s0,s9
   17174:	dc9ff06f          	j	16f3c <_vfiprintf_r+0x984>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   17178:	060103a3          	sb	zero,103(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1717c:	1e04c063          	bltz	s1,1735c <_vfiprintf_r+0xda4>
				flags &= ~ZEROPAD;
   17180:	f7f37313          	andi	t1,t1,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   17184:	ee078663          	beqz	a5,16870 <_vfiprintf_r+0x2b8>
   17188:	00000593          	li	a1,0
   1718c:	000c8b93          	mv	s7,s9
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   17190:	01813703          	ld	a4,24(sp)
   17194:	00f7f613          	andi	a2,a5,15
   17198:	fffb8b93          	addi	s7,s7,-1
   1719c:	00c70633          	add	a2,a4,a2
   171a0:	00064603          	lbu	a2,0(a2)
						_uquad >>= 4;
   171a4:	0047d793          	srli	a5,a5,0x4
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   171a8:	00cb8023          	sb	a2,0(s7)
						_uquad >>= 4;
					} while (_uquad);
   171ac:	fe0792e3          	bnez	a5,17190 <_vfiprintf_r+0xbd8>
   171b0:	417c8a3b          	subw	s4,s9,s7
   171b4:	ed0ff06f          	j	16884 <_vfiprintf_r+0x2cc>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   171b8:	00813783          	ld	a5,8(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   171bc:	060103a3          	sb	zero,103(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   171c0:	00878713          	addi	a4,a5,8
   171c4:	0007b783          	ld	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   171c8:	a204dee3          	bgez	s1,16c04 <_vfiprintf_r+0x64c>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   171cc:	00e13423          	sd	a4,8(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   171d0:	00000593          	li	a1,0
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   171d4:	920796e3          	bnez	a5,16b00 <_vfiprintf_r+0x548>
   171d8:	00100793          	li	a5,1
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   171dc:	00100713          	li	a4,1
   171e0:	a2e78ce3          	beq	a5,a4,16c18 <_vfiprintf_r+0x660>
   171e4:	00200713          	li	a4,2
   171e8:	08e78e63          	beq	a5,a4,17284 <_vfiprintf_r+0xccc>
   171ec:	00000793          	li	a5,0
   171f0:	97dff06f          	j	16b6c <_vfiprintf_r+0x5b4>
   171f4:	07010613          	addi	a2,sp,112
   171f8:	000d0593          	mv	a1,s10
   171fc:	000a8513          	mv	a0,s5
   17200:	02613023          	sd	t1,32(sp)
   17204:	ab0ff0ef          	jal	164b4 <__sprint_r.part.0>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   17208:	e0051ce3          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   1720c:	08013783          	ld	a5,128(sp)
   17210:	000c8413          	mv	s0,s9
   17214:	02013303          	ld	t1,32(sp)
   17218:	d29ff06f          	j	16f40 <_vfiprintf_r+0x988>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   1721c:	04037793          	andi	a5,t1,64
   17220:	00813703          	ld	a4,8(sp)
   17224:	20078263          	beqz	a5,17428 <_vfiprintf_r+0xe70>
   17228:	00071783          	lh	a5,0(a4)
   1722c:	00870713          	addi	a4,a4,8
   17230:	00e13423          	sd	a4,8(sp)
   17234:	8b9ff06f          	j	16aec <_vfiprintf_r+0x534>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   17238:	04037793          	andi	a5,t1,64

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1723c:	060103a3          	sb	zero,103(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   17240:	18078263          	beqz	a5,173c4 <_vfiprintf_r+0xe0c>
   17244:	00813783          	ld	a5,8(sp)
   17248:	00878713          	addi	a4,a5,8
   1724c:	0007d783          	lhu	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   17250:	9004d2e3          	bgez	s1,16b54 <_vfiprintf_r+0x59c>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   17254:	00e13423          	sd	a4,8(sp)
   17258:	00000593          	li	a1,0
   1725c:	f80780e3          	beqz	a5,171dc <_vfiprintf_r+0xc24>
   17260:	00000593          	li	a1,0
   17264:	909ff06f          	j	16b6c <_vfiprintf_r+0x5b4>
   17268:	07010613          	addi	a2,sp,112
   1726c:	000d0593          	mv	a1,s10
   17270:	000a8513          	mv	a0,s5
   17274:	a40ff0ef          	jal	164b4 <__sprint_r.part.0>
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   17278:	da0514e3          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   1727c:	000c8413          	mv	s0,s9
   17280:	c88ff06f          	j	16708 <_vfiprintf_r+0x150>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   17284:	00000793          	li	a5,0
   17288:	f05ff06f          	j	1718c <_vfiprintf_r+0xbd4>
   1728c:	07010613          	addi	a2,sp,112
   17290:	000d0593          	mv	a1,s10
   17294:	000a8513          	mv	a0,s5
   17298:	02513423          	sd	t0,40(sp)
   1729c:	02613023          	sd	t1,32(sp)
   172a0:	a14ff0ef          	jal	164b4 <__sprint_r.part.0>

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   172a4:	d6051ee3          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   172a8:	07812603          	lw	a2,120(sp)
   172ac:	08013783          	ld	a5,128(sp)
   172b0:	000c8413          	mv	s0,s9
   172b4:	0016059b          	addiw	a1,a2,1
   172b8:	02813283          	ld	t0,40(sp)
   172bc:	02013303          	ld	t1,32(sp)
   172c0:	bbdff06f          	j	16e7c <_vfiprintf_r+0x8c4>
   172c4:	07010613          	addi	a2,sp,112
   172c8:	000d0593          	mv	a1,s10
   172cc:	000a8513          	mv	a0,s5
   172d0:	02513823          	sd	t0,48(sp)
   172d4:	02713423          	sd	t2,40(sp)
   172d8:	02613023          	sd	t1,32(sp)
   172dc:	9d8ff0ef          	jal	164b4 <__sprint_r.part.0>
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   172e0:	d40510e3          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   172e4:	07812603          	lw	a2,120(sp)
   172e8:	08013783          	ld	a5,128(sp)
   172ec:	000c8413          	mv	s0,s9
   172f0:	0016059b          	addiw	a1,a2,1
   172f4:	03013283          	ld	t0,48(sp)
   172f8:	02813383          	ld	t2,40(sp)
   172fc:	02013303          	ld	t1,32(sp)
   17300:	e50ff06f          	j	16950 <_vfiprintf_r+0x398>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   17304:	1e079063          	bnez	a5,174e4 <_vfiprintf_r+0xf2c>
		uio->uio_iovcnt = 0;
   17308:	00100593          	li	a1,1
   1730c:	00000613          	li	a2,0
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   17310:	000c8413          	mv	s0,s9
   17314:	b71ff06f          	j	16e84 <_vfiprintf_r+0x8cc>
   17318:	07010613          	addi	a2,sp,112
   1731c:	000d0593          	mv	a1,s10
   17320:	000a8513          	mv	a0,s5
   17324:	02613023          	sd	t1,32(sp)
   17328:	98cff0ef          	jal	164b4 <__sprint_r.part.0>

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   1732c:	ce051ae3          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   17330:	07812583          	lw	a1,120(sp)
   17334:	08013783          	ld	a5,128(sp)
   17338:	000c8413          	mv	s0,s9
   1733c:	0015859b          	addiw	a1,a1,1
   17340:	02013303          	ld	t1,32(sp)
   17344:	eecff06f          	j	16a30 <_vfiprintf_r+0x478>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   17348:	00e13423          	sd	a4,8(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
   1734c:	00019737          	lui	a4,0x19
   17350:	24070713          	addi	a4,a4,576 # 19240 <zeroes.4137+0x50>
			flags |= HEXPREFIX;
   17354:	00060313          	mv	t1,a2
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   17358:	00e13c23          	sd	a4,24(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1735c:	e20796e3          	bnez	a5,17188 <_vfiprintf_r+0xbd0>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   17360:	00000593          	li	a1,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   17364:	00200793          	li	a5,2
   17368:	e75ff06f          	j	171dc <_vfiprintf_r+0xc24>
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
   1736c:	03000613          	li	a2,48
				ox[1] = ch;
   17370:	06e104a3          	sb	a4,105(sp)
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
   17374:	06c10423          	sb	a2,104(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   17378:	060103a3          	sb	zero,103(sp)
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
				ox[1] = ch;
				flags |= HEXPREFIX;
   1737c:	00236713          	ori	a4,t1,2
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   17380:	1a04c463          	bltz	s1,17528 <_vfiprintf_r+0xf70>
   17384:	f7f37313          	andi	t1,t1,-129
				flags &= ~ZEROPAD;
   17388:	00236313          	ori	t1,t1,2
   1738c:	00000593          	li	a1,0
   17390:	dfdff06f          	j	1718c <_vfiprintf_r+0xbd4>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   17394:	00019737          	lui	a4,0x19
   17398:	24070713          	addi	a4,a4,576 # 19240 <zeroes.4137+0x50>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1739c:	00000593          	li	a1,0
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   173a0:	00e13c23          	sd	a4,24(sp)
   173a4:	de9ff06f          	j	1718c <_vfiprintf_r+0xbd4>
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   173a8:	000b0493          	mv	s1,s6
   173ac:	b68ff06f          	j	16714 <_vfiprintf_r+0x15c>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   173b0:	00813783          	ld	a5,8(sp)
   173b4:	00878713          	addi	a4,a5,8
   173b8:	0007e783          	lwu	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   173bc:	8404d4e3          	bgez	s1,16c04 <_vfiprintf_r+0x64c>
   173c0:	e0dff06f          	j	171cc <_vfiprintf_r+0xc14>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   173c4:	00813783          	ld	a5,8(sp)
   173c8:	00878713          	addi	a4,a5,8
   173cc:	0007e783          	lwu	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   173d0:	f804d263          	bgez	s1,16b54 <_vfiprintf_r+0x59c>
   173d4:	e81ff06f          	j	17254 <_vfiprintf_r+0xc9c>
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
				sign = '-';
   173d8:	02d00713          	li	a4,45
   173dc:	06e103a3          	sb	a4,103(sp)
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   173e0:	40f007b3          	neg	a5,a5
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   173e4:	1804c863          	bltz	s1,17574 <_vfiprintf_r+0xfbc>
				flags &= ~ZEROPAD;
   173e8:	f7f37313          	andi	t1,t1,-129
   173ec:	02d00593          	li	a1,45
   173f0:	f10ff06f          	j	16b00 <_vfiprintf_r+0x548>
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   173f4:	0006e783          	lwu	a5,0(a3)
   173f8:	00868693          	addi	a3,a3,8
   173fc:	00d13423          	sd	a3,8(sp)
   17400:	905ff06f          	j	16d04 <_vfiprintf_r+0x74c>
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
				*GET_ARG (N, ap, short_ptr_t) = ret;
   17404:	00813703          	ld	a4,8(sp)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
   17408:	04037313          	andi	t1,t1,64
				*GET_ARG (N, ap, short_ptr_t) = ret;
   1740c:	00073783          	ld	a5,0(a4)
   17410:	00870713          	addi	a4,a4,8
   17414:	00e13423          	sd	a4,8(sp)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
   17418:	08030063          	beqz	t1,17498 <_vfiprintf_r+0xee0>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   1741c:	05815703          	lhu	a4,88(sp)
   17420:	00e79023          	sh	a4,0(a5)
   17424:	a84ff06f          	j	166a8 <_vfiprintf_r+0xf0>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   17428:	00072783          	lw	a5,0(a4)
   1742c:	00870713          	addi	a4,a4,8
   17430:	00e13423          	sd	a4,8(sp)
   17434:	eb8ff06f          	j	16aec <_vfiprintf_r+0x534>
   17438:	07010613          	addi	a2,sp,112
   1743c:	000d0593          	mv	a1,s10
   17440:	000a8513          	mv	a0,s5
   17444:	02513823          	sd	t0,48(sp)
   17448:	02713423          	sd	t2,40(sp)
   1744c:	02613023          	sd	t1,32(sp)
   17450:	864ff0ef          	jal	164b4 <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   17454:	bc0516e3          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   17458:	07812603          	lw	a2,120(sp)
   1745c:	08013783          	ld	a5,128(sp)
   17460:	000c8413          	mv	s0,s9
   17464:	0016059b          	addiw	a1,a2,1
   17468:	03013283          	ld	t0,48(sp)
   1746c:	02813383          	ld	t2,40(sp)
   17470:	02013303          	ld	t1,32(sp)
   17474:	9c9ff06f          	j	16e3c <_vfiprintf_r+0x884>
	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
		_newlib_flockfile_exit (fp);
		return (EOF);
   17478:	fff00513          	li	a0,-1
   1747c:	b48ff06f          	j	167c4 <_vfiprintf_r+0x20c>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   17480:	000c8413          	mv	s0,s9
   17484:	acdff06f          	j	16f50 <_vfiprintf_r+0x998>
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   17488:	00000613          	li	a2,0
   1748c:	00100593          	li	a1,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   17490:	000c8413          	mv	s0,s9
   17494:	9e9ff06f          	j	16e7c <_vfiprintf_r+0x8c4>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   17498:	05812703          	lw	a4,88(sp)
   1749c:	00e7a023          	sw	a4,0(a5)
   174a0:	a08ff06f          	j	166a8 <_vfiprintf_r+0xf0>
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
   174a4:	08013783          	ld	a5,128(sp)
   174a8:	b6078ce3          	beqz	a5,17020 <_vfiprintf_r+0xa68>
   174ac:	07010613          	addi	a2,sp,112
   174b0:	000d0593          	mv	a1,s10
   174b4:	000a8513          	mv	a0,s5
   174b8:	ffdfe0ef          	jal	164b4 <__sprint_r.part.0>
   174bc:	b65ff06f          	j	17020 <_vfiprintf_r+0xa68>
				if (p != NULL)
					size = p - cp;
				else
					size = prec;
			} else
				size = strlen (cp);
   174c0:	000b8513          	mv	a0,s7
   174c4:	02613023          	sd	t1,32(sp)
   174c8:	f1dfe0ef          	jal	163e4 <strlen>
   174cc:	00050a1b          	sext.w	s4,a0
   174d0:	06714583          	lbu	a1,103(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   174d4:	01b13423          	sd	s11,8(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   174d8:	00000493          	li	s1,0
   174dc:	02013303          	ld	t1,32(sp)
   174e0:	ba4ff06f          	j	16884 <_vfiprintf_r+0x2cc>
   174e4:	07010613          	addi	a2,sp,112
   174e8:	000d0593          	mv	a1,s10
   174ec:	000a8513          	mv	a0,s5
   174f0:	02613023          	sd	t1,32(sp)
   174f4:	fc1fe0ef          	jal	164b4 <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   174f8:	b20514e3          	bnez	a0,17020 <_vfiprintf_r+0xa68>
   174fc:	07812603          	lw	a2,120(sp)
   17500:	08013783          	ld	a5,128(sp)
   17504:	000c8413          	mv	s0,s9
   17508:	0016059b          	addiw	a1,a2,1
   1750c:	02013303          	ld	t1,32(sp)
   17510:	975ff06f          	j	16e84 <_vfiprintf_r+0x8cc>
   17514:	07812603          	lw	a2,120(sp)
   17518:	08013783          	ld	a5,128(sp)
   1751c:	05813823          	sd	s8,80(sp)
   17520:	0016061b          	addiw	a2,a2,1
   17524:	bfcff06f          	j	16920 <_vfiprintf_r+0x368>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   17528:	00000593          	li	a1,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   1752c:	00200613          	li	a2,2
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   17530:	00100513          	li	a0,1
   17534:	08a60263          	beq	a2,a0,175b8 <_vfiprintf_r+0x1000>
   17538:	00200513          	li	a0,2
   1753c:	08a61263          	bne	a2,a0,175c0 <_vfiprintf_r+0x1008>
   17540:	00070313          	mv	t1,a4
   17544:	c49ff06f          	j	1718c <_vfiprintf_r+0xbd4>
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
				size = ((unsigned) prec > 6U) ? 6 : prec;
   17548:	00600793          	li	a5,6
   1754c:	0097f463          	bleu	s1,a5,17554 <_vfiprintf_r+0xf9c>
   17550:	00078493          	mv	s1,a5
   17554:	00048a13          	mv	s4,s1
   17558:	00048993          	mv	s3,s1
   1755c:	0604c663          	bltz	s1,175c8 <_vfiprintf_r+0x1010>
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   17560:	00019737          	lui	a4,0x19
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   17564:	01b13423          	sd	s11,8(sp)
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   17568:	25870b93          	addi	s7,a4,600 # 19258 <zeroes.4137+0x68>
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   1756c:	00000493          	li	s1,0
   17570:	b28ff06f          	j	16898 <_vfiprintf_r+0x2e0>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   17574:	00030713          	mv	a4,t1
   17578:	02d00593          	li	a1,45
			{

				_uquad = -_uquad;
				sign = '-';
			}
			base = DEC;
   1757c:	00100613          	li	a2,1
   17580:	fb1ff06f          	j	17530 <_vfiprintf_r+0xf78>
   17584:	07812583          	lw	a1,120(sp)
   17588:	05813823          	sd	s8,80(sp)
   1758c:	0015859b          	addiw	a1,a1,1
   17590:	a29ff06f          	j	16fb8 <_vfiprintf_r+0xa00>
   17594:	00019737          	lui	a4,0x19
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   17598:	00058513          	mv	a0,a1
   1759c:	1f070d93          	addi	s11,a4,496 # 191f0 <zeroes.4137>
   175a0:	c60ff06f          	j	16a00 <_vfiprintf_r+0x448>
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
   175a4:	00048a13          	mv	s4,s1
   175a8:	06714583          	lbu	a1,103(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   175ac:	01b13423          	sd	s11,8(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   175b0:	00000493          	li	s1,0
   175b4:	ad0ff06f          	j	16884 <_vfiprintf_r+0x2cc>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   175b8:	00070313          	mv	t1,a4
   175bc:	d44ff06f          	j	16b00 <_vfiprintf_r+0x548>
   175c0:	00070313          	mv	t1,a4
   175c4:	da8ff06f          	j	16b6c <_vfiprintf_r+0x5b4>
   175c8:	00000993          	li	s3,0
   175cc:	f95ff06f          	j	17560 <_vfiprintf_r+0xfa8>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   175d0:	00813783          	ld	a5,8(sp)
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   175d4:	00080b13          	mv	s6,a6
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   175d8:	0007a483          	lw	s1,0(a5)
   175dc:	00878b93          	addi	s7,a5,8
   175e0:	01713423          	sd	s7,8(sp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   175e4:	9804de63          	bgez	s1,16780 <_vfiprintf_r+0x1c8>
					prec = -1;
   175e8:	fff00493          	li	s1,-1
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   175ec:	000b0813          	mv	a6,s6
   175f0:	954ff06f          	j	16744 <_vfiprintf_r+0x18c>
   175f4:	07d103a3          	sb	t4,103(sp)
   175f8:	f44ff06f          	j	16d3c <_vfiprintf_r+0x784>
   175fc:	07d103a3          	sb	t4,103(sp)
   17600:	ee0ff06f          	j	16ce0 <_vfiprintf_r+0x728>
   17604:	07d103a3          	sb	t4,103(sp)
   17608:	fb0ff06f          	j	16db8 <_vfiprintf_r+0x800>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   1760c:	00137793          	andi	a5,t1,1
   17610:	00078c63          	beqz	a5,17628 <_vfiprintf_r+0x1070>
                         *--cp = '0';
   17614:	03000793          	li	a5,48
   17618:	0af107a3          	sb	a5,175(sp)
   1761c:	05c12a03          	lw	s4,92(sp)
   17620:	0af10b93          	addi	s7,sp,175
   17624:	a60ff06f          	j	16884 <_vfiprintf_r+0x2cc>
   17628:	00000a13          	li	s4,0
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   1762c:	000c8b93          	mv	s7,s9
   17630:	a54ff06f          	j	16884 <_vfiprintf_r+0x2cc>
   17634:	07d103a3          	sb	t4,103(sp)
   17638:	cfcff06f          	j	16b34 <_vfiprintf_r+0x57c>
   1763c:	07d103a3          	sb	t4,103(sp)
   17640:	c90ff06f          	j	16ad0 <_vfiprintf_r+0x518>
   17644:	07d103a3          	sb	t4,103(sp)
   17648:	d94ff06f          	j	16bdc <_vfiprintf_r+0x624>
   1764c:	07d103a3          	sb	t4,103(sp)
   17650:	d64ff06f          	j	16bb4 <_vfiprintf_r+0x5fc>

0000000000017654 <vfiprintf>:
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   17654:	00060693          	mv	a3,a2
   17658:	00058613          	mv	a2,a1
   1765c:	00050593          	mv	a1,a0
   17660:	8101b503          	ld	a0,-2032(gp) # 1b2e0 <_impure_ptr>
   17664:	f55fe06f          	j	165b8 <_vfiprintf_r>

0000000000017668 <__sbprintf>:
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   17668:	0105d783          	lhu	a5,16(a1)
	fake._flags2 = fp->_flags2;
   1766c:	0ac5ae03          	lw	t3,172(a1)
	fake._file = fp->_file;
   17670:	0125d303          	lhu	t1,18(a1)
	fake._cookie = fp->_cookie;
   17674:	0305b883          	ld	a7,48(a1)
	fake._write = fp->_write;
   17678:	0405b803          	ld	a6,64(a1)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1767c:	b3010113          	addi	sp,sp,-1232
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   17680:	ffd7f793          	andi	a5,a5,-3
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
	fake._bf._size = fake._w = sizeof (buf);
   17684:	40000713          	li	a4,1024
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   17688:	4c813023          	sd	s0,1216(sp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   1768c:	00f11823          	sh	a5,16(sp)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   17690:	00058413          	mv	s0,a1
	fake._file = fp->_file;
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   17694:	0b010793          	addi	a5,sp,176
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   17698:	00010593          	mv	a1,sp
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1769c:	4a913c23          	sd	s1,1208(sp)
   176a0:	4b213823          	sd	s2,1200(sp)
   176a4:	4c113423          	sd	ra,1224(sp)
   176a8:	00050913          	mv	s2,a0
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
	fake._flags2 = fp->_flags2;
   176ac:	0bc12623          	sw	t3,172(sp)
	fake._file = fp->_file;
   176b0:	00611923          	sh	t1,18(sp)
	fake._cookie = fp->_cookie;
   176b4:	03113823          	sd	a7,48(sp)
	fake._write = fp->_write;
   176b8:	05013023          	sd	a6,64(sp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   176bc:	00f13023          	sd	a5,0(sp)
   176c0:	00f13c23          	sd	a5,24(sp)
	fake._bf._size = fake._w = sizeof (buf);
   176c4:	00e12623          	sw	a4,12(sp)
   176c8:	02e12023          	sw	a4,32(sp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   176cc:	02012423          	sw	zero,40(sp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   176d0:	ee9fe0ef          	jal	165b8 <_vfiprintf_r>
   176d4:	00050493          	mv	s1,a0
	if (ret >= 0 && _fflush_r (rptr, &fake))
   176d8:	00054a63          	bltz	a0,176ec <__sbprintf+0x84>
   176dc:	00010593          	mv	a1,sp
   176e0:	00090513          	mv	a0,s2
   176e4:	b54fc0ef          	jal	13a38 <_fflush_r>
   176e8:	02051c63          	bnez	a0,17720 <__sbprintf+0xb8>
		ret = EOF;
	if (fake._flags & __SERR)
   176ec:	01015783          	lhu	a5,16(sp)
   176f0:	0407f793          	andi	a5,a5,64
   176f4:	00078863          	beqz	a5,17704 <__sbprintf+0x9c>
		fp->_flags |= __SERR;
   176f8:	01045783          	lhu	a5,16(s0)
   176fc:	0407e793          	ori	a5,a5,64
   17700:	00f41823          	sh	a5,16(s0)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
}
   17704:	4c813083          	ld	ra,1224(sp)
   17708:	00048513          	mv	a0,s1
   1770c:	4c013403          	ld	s0,1216(sp)
   17710:	4b813483          	ld	s1,1208(sp)
   17714:	4b013903          	ld	s2,1200(sp)
   17718:	4d010113          	addi	sp,sp,1232
   1771c:	00008067          	ret
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
	if (ret >= 0 && _fflush_r (rptr, &fake))
		ret = EOF;
   17720:	fff00493          	li	s1,-1
   17724:	fc9ff06f          	j	176ec <__sbprintf+0x84>

0000000000017728 <_calloc_r>:
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
   17728:	02c585b3          	mul	a1,a1,a2
#if __STD_C
Void_t* cALLOc(RARG size_t n, size_t elem_size)
#else
Void_t* cALLOc(RARG n, elem_size) RDECL size_t n; size_t elem_size;
#endif
{
   1772c:	ff010113          	addi	sp,sp,-16
   17730:	00113423          	sd	ra,8(sp)
   17734:	00813023          	sd	s0,0(sp)
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
   17738:	ef9fc0ef          	jal	14630 <_malloc_r>

  if (mem == 0) 
   1773c:	08050c63          	beqz	a0,177d4 <_calloc_r+0xac>
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   17740:	ff853603          	ld	a2,-8(a0)
   17744:	04800713          	li	a4,72
   17748:	00050413          	mv	s0,a0
   1774c:	ffc67613          	andi	a2,a2,-4
   17750:	ff860613          	addi	a2,a2,-8
   17754:	04c76e63          	bltu	a4,a2,177b0 <_calloc_r+0x88>
   17758:	02700693          	li	a3,39
   1775c:	00050793          	mv	a5,a0
   17760:	02c6f863          	bleu	a2,a3,17790 <_calloc_r+0x68>
   17764:	00053023          	sd	zero,0(a0)
   17768:	00053423          	sd	zero,8(a0)
   1776c:	03700793          	li	a5,55
   17770:	04c7fe63          	bleu	a2,a5,177cc <_calloc_r+0xa4>
   17774:	00053823          	sd	zero,16(a0)
   17778:	00053c23          	sd	zero,24(a0)
   1777c:	02050793          	addi	a5,a0,32
   17780:	00e61863          	bne	a2,a4,17790 <_calloc_r+0x68>
   17784:	02053023          	sd	zero,32(a0)
   17788:	03050793          	addi	a5,a0,48
   1778c:	02053423          	sd	zero,40(a0)
   17790:	0007b023          	sd	zero,0(a5)
   17794:	0007b423          	sd	zero,8(a5)
   17798:	0007b823          	sd	zero,16(a5)
   1779c:	00040513          	mv	a0,s0
    return mem;
  }
}
   177a0:	00813083          	ld	ra,8(sp)
   177a4:	00013403          	ld	s0,0(sp)
   177a8:	01010113          	addi	sp,sp,16
   177ac:	00008067          	ret
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   177b0:	00000593          	li	a1,0
   177b4:	ff4fd0ef          	jal	14fa8 <memset>
    return mem;
  }
}
   177b8:	00813083          	ld	ra,8(sp)
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   177bc:	00040513          	mv	a0,s0
    return mem;
  }
}
   177c0:	00013403          	ld	s0,0(sp)
   177c4:	01010113          	addi	sp,sp,16
   177c8:	00008067          	ret
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   177cc:	01050793          	addi	a5,a0,16
   177d0:	fc1ff06f          	j	17790 <_calloc_r+0x68>
  if (mem == 0) 
  {
#if MORECORE_CLEARS
    MALLOC_UNLOCK;
#endif
    return 0;
   177d4:	00000513          	li	a0,0
   177d8:	fc9ff06f          	j	177a0 <_calloc_r+0x78>

00000000000177dc <_fclose_r>:
      struct _reent *rptr _AND
      register FILE * fp)
{
  int r;

  if (fp == NULL)
   177dc:	0e058e63          	beqz	a1,178d8 <_fclose_r+0xfc>

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
   177e0:	fe010113          	addi	sp,sp,-32
   177e4:	00813823          	sd	s0,16(sp)
   177e8:	00913423          	sd	s1,8(sp)
   177ec:	00113c23          	sd	ra,24(sp)
   177f0:	01213023          	sd	s2,0(sp)
   177f4:	00050493          	mv	s1,a0
   177f8:	00058413          	mv	s0,a1
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   177fc:	00050663          	beqz	a0,17808 <_fclose_r+0x2c>
   17800:	05052783          	lw	a5,80(a0)
   17804:	0a078a63          	beqz	a5,178b8 <_fclose_r+0xdc>
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   17808:	01041783          	lh	a5,16(s0)
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   1780c:	00000513          	li	a0,0
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   17810:	00079e63          	bnez	a5,1782c <_fclose_r+0x50>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   17814:	01813083          	ld	ra,24(sp)
   17818:	01013403          	ld	s0,16(sp)
   1781c:	00813483          	ld	s1,8(sp)
   17820:	00013903          	ld	s2,0(sp)
   17824:	02010113          	addi	sp,sp,32
   17828:	00008067          	ret
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   1782c:	00040593          	mv	a1,s0
   17830:	00048513          	mv	a0,s1
   17834:	f99fb0ef          	jal	137cc <__sflush_r>
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   17838:	05043783          	ld	a5,80(s0)
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   1783c:	00050913          	mv	s2,a0
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   17840:	00078a63          	beqz	a5,17854 <_fclose_r+0x78>
   17844:	03043583          	ld	a1,48(s0)
   17848:	00048513          	mv	a0,s1
   1784c:	000780e7          	jalr	a5
   17850:	06054863          	bltz	a0,178c0 <_fclose_r+0xe4>
    r = EOF;
  if (fp->_flags & __SMBF)
   17854:	01045783          	lhu	a5,16(s0)
   17858:	0807f793          	andi	a5,a5,128
   1785c:	06079663          	bnez	a5,178c8 <_fclose_r+0xec>
    _free_r (rptr, (char *) fp->_bf._base);
  if (HASUB (fp))
   17860:	05843583          	ld	a1,88(s0)
   17864:	00058c63          	beqz	a1,1787c <_fclose_r+0xa0>
    FREEUB (rptr, fp);
   17868:	07440793          	addi	a5,s0,116
   1786c:	00f58663          	beq	a1,a5,17878 <_fclose_r+0x9c>
   17870:	00048513          	mv	a0,s1
   17874:	ec8fc0ef          	jal	13f3c <_free_r>
   17878:	04043c23          	sd	zero,88(s0)
  if (HASLB (fp))
   1787c:	07843583          	ld	a1,120(s0)
   17880:	00058863          	beqz	a1,17890 <_fclose_r+0xb4>
    FREELB (rptr, fp);
   17884:	00048513          	mv	a0,s1
   17888:	eb4fc0ef          	jal	13f3c <_free_r>
   1788c:	06043c23          	sd	zero,120(s0)
  __sfp_lock_acquire ();
   17890:	d64fc0ef          	jal	13df4 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
   17894:	00041823          	sh	zero,16(s0)
  _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
   17898:	d60fc0ef          	jal	13df8 <__sfp_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   1789c:	01813083          	ld	ra,24(sp)
  _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
   178a0:	00090513          	mv	a0,s2
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   178a4:	01013403          	ld	s0,16(sp)
   178a8:	00813483          	ld	s1,8(sp)
   178ac:	00013903          	ld	s2,0(sp)
   178b0:	02010113          	addi	sp,sp,32
   178b4:	00008067          	ret
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   178b8:	d2cfc0ef          	jal	13de4 <__sinit>
   178bc:	f4dff06f          	j	17808 <_fclose_r+0x2c>
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
    r = EOF;
   178c0:	fff00913          	li	s2,-1
   178c4:	f91ff06f          	j	17854 <_fclose_r+0x78>
  if (fp->_flags & __SMBF)
    _free_r (rptr, (char *) fp->_bf._base);
   178c8:	01843583          	ld	a1,24(s0)
   178cc:	00048513          	mv	a0,s1
   178d0:	e6cfc0ef          	jal	13f3c <_free_r>
   178d4:	f8dff06f          	j	17860 <_fclose_r+0x84>
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   178d8:	00000513          	li	a0,0
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   178dc:	00008067          	ret

00000000000178e0 <fclose>:

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
  return _fclose_r(_REENT, fp);
   178e0:	00050593          	mv	a1,a0
   178e4:	8101b503          	ld	a0,-2032(gp) # 1b2e0 <_impure_ptr>
   178e8:	ef5ff06f          	j	177dc <_fclose_r>

00000000000178ec <__fputwc>:
wint_t
_DEFUN(__fputwc, (ptr, wc, fp),
	struct _reent *ptr _AND
	wchar_t wc _AND
	FILE *fp)
{
   178ec:	fb010113          	addi	sp,sp,-80
   178f0:	04813023          	sd	s0,64(sp)
   178f4:	03413023          	sd	s4,32(sp)
   178f8:	01513c23          	sd	s5,24(sp)
   178fc:	04113423          	sd	ra,72(sp)
   17900:	02913c23          	sd	s1,56(sp)
   17904:	03213823          	sd	s2,48(sp)
   17908:	03313423          	sd	s3,40(sp)
   1790c:	01613823          	sd	s6,16(sp)
   17910:	00050a93          	mv	s5,a0
   17914:	00058a13          	mv	s4,a1
   17918:	00060413          	mv	s0,a2
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
   1791c:	b25fc0ef          	jal	14440 <__locale_mb_cur_max>
   17920:	00100793          	li	a5,1
   17924:	10f50663          	beq	a0,a5,17a30 <__fputwc+0x144>
      *buf = (unsigned char)wc;
      len = 1;
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
   17928:	00810493          	addi	s1,sp,8
   1792c:	0a440693          	addi	a3,s0,164
   17930:	000a0613          	mv	a2,s4
   17934:	00048593          	mv	a1,s1
   17938:	000a8513          	mv	a0,s5
   1793c:	699000ef          	jal	187d4 <_wcrtomb_r>
   17940:	fff00793          	li	a5,-1
   17944:	00050993          	mv	s3,a0
   17948:	08f50e63          	beq	a0,a5,179e4 <__fputwc+0xf8>
	  fp->_flags |= __SERR;
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
   1794c:	10050263          	beqz	a0,17a50 <__fputwc+0x164>
   17950:	00814583          	lbu	a1,8(sp)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   17954:	00c42783          	lw	a5,12(s0)
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
      len = 1;
   17958:	00000913          	li	s2,0
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   1795c:	00a00b13          	li	s6,10
   17960:	fff7879b          	addiw	a5,a5,-1
   17964:	00f42623          	sw	a5,12(s0)
   17968:	0207cc63          	bltz	a5,179a0 <__fputwc+0xb4>
   1796c:	00043783          	ld	a5,0(s0)
   17970:	00b78023          	sb	a1,0(a5)
   17974:	00043783          	ld	a5,0(s0)
   17978:	00178793          	addi	a5,a5,1
   1797c:	00f43023          	sd	a5,0(s0)
	  fp->_flags |= __SERR;
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
   17980:	00190913          	addi	s2,s2,1
   17984:	00148493          	addi	s1,s1,1
   17988:	0d397463          	bleu	s3,s2,17a50 <__fputwc+0x164>
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   1798c:	00c42783          	lw	a5,12(s0)
   17990:	0004c583          	lbu	a1,0(s1)
   17994:	fff7879b          	addiw	a5,a5,-1
   17998:	00f42623          	sw	a5,12(s0)
   1799c:	fc07d8e3          	bgez	a5,1796c <__fputwc+0x80>
   179a0:	02842703          	lw	a4,40(s0)
   179a4:	06e7ca63          	blt	a5,a4,17a18 <__fputwc+0x12c>
   179a8:	00043783          	ld	a5,0(s0)
   179ac:	00b78023          	sb	a1,0(a5)
   179b0:	00043783          	ld	a5,0(s0)
   179b4:	0007c703          	lbu	a4,0(a5)
   179b8:	00178793          	addi	a5,a5,1
   179bc:	fd6710e3          	bne	a4,s6,1797c <__fputwc+0x90>
   179c0:	00040613          	mv	a2,s0
   179c4:	000b0593          	mv	a1,s6
   179c8:	000a8513          	mv	a0,s5
   179cc:	481000ef          	jal	1864c <__swbuf_r>
   179d0:	0015051b          	addiw	a0,a0,1
   179d4:	00153513          	seqz	a0,a0
   179d8:	fa0504e3          	beqz	a0,17980 <__fputwc+0x94>
      return WEOF;
   179dc:	fff00513          	li	a0,-1
   179e0:	0100006f          	j	179f0 <__fputwc+0x104>
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
	{
	  fp->_flags |= __SERR;
   179e4:	01045783          	lhu	a5,16(s0)
   179e8:	0407e793          	ori	a5,a5,64
   179ec:	00f41823          	sh	a5,16(s0)
  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
      return WEOF;

  return (wint_t) wc;
}
   179f0:	04813083          	ld	ra,72(sp)
   179f4:	04013403          	ld	s0,64(sp)
   179f8:	03813483          	ld	s1,56(sp)
   179fc:	03013903          	ld	s2,48(sp)
   17a00:	02813983          	ld	s3,40(sp)
   17a04:	02013a03          	ld	s4,32(sp)
   17a08:	01813a83          	ld	s5,24(sp)
   17a0c:	01013b03          	ld	s6,16(sp)
   17a10:	05010113          	addi	sp,sp,80
   17a14:	00008067          	ret
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   17a18:	00040613          	mv	a2,s0
   17a1c:	000a8513          	mv	a0,s5
   17a20:	42d000ef          	jal	1864c <__swbuf_r>
   17a24:	0015051b          	addiw	a0,a0,1
   17a28:	00153513          	seqz	a0,a0
   17a2c:	fadff06f          	j	179d8 <__fputwc+0xec>
	FILE *fp)
{
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
   17a30:	fffa079b          	addiw	a5,s4,-1
   17a34:	0fe00713          	li	a4,254
   17a38:	eef768e3          	bltu	a4,a5,17928 <__fputwc+0x3c>
      /*
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
   17a3c:	0ffa7593          	andi	a1,s4,255
   17a40:	00b10423          	sb	a1,8(sp)
      len = 1;
   17a44:	00100993          	li	s3,1
   17a48:	00810493          	addi	s1,sp,8
   17a4c:	f09ff06f          	j	17954 <__fputwc+0x68>

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
      return WEOF;

  return (wint_t) wc;
   17a50:	000a0513          	mv	a0,s4
   17a54:	f9dff06f          	j	179f0 <__fputwc+0x104>

0000000000017a58 <_fputwc_r>:
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
   17a58:	01061783          	lh	a5,16(a2)
   17a5c:	00002737          	lui	a4,0x2
   17a60:	03279693          	slli	a3,a5,0x32
   17a64:	0006cc63          	bltz	a3,17a7c <_fputwc_r+0x24>
	wchar_t wc _AND
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
   17a68:	0ac62683          	lw	a3,172(a2)
  ORIENT(fp, 1);
   17a6c:	00e7e7b3          	or	a5,a5,a4
   17a70:	00f61823          	sh	a5,16(a2)
   17a74:	00e6e733          	or	a4,a3,a4
   17a78:	0ae62623          	sw	a4,172(a2)
  r = __fputwc(ptr, wc, fp);
   17a7c:	e71ff06f          	j	178ec <__fputwc>

0000000000017a80 <fputwc>:

wint_t
_DEFUN(fputwc, (wc, fp),
	wchar_t wc _AND
	FILE *fp)
{
   17a80:	fd010113          	addi	sp,sp,-48
   17a84:	02813023          	sd	s0,32(sp)
  struct _reent *reent = _REENT;
   17a88:	8101b403          	ld	s0,-2032(gp) # 1b2e0 <_impure_ptr>

wint_t
_DEFUN(fputwc, (wc, fp),
	wchar_t wc _AND
	FILE *fp)
{
   17a8c:	00913c23          	sd	s1,24(sp)
   17a90:	02113423          	sd	ra,40(sp)
   17a94:	00050493          	mv	s1,a0
   17a98:	00058613          	mv	a2,a1
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
   17a9c:	00040663          	beqz	s0,17aa8 <fputwc+0x28>
   17aa0:	05042783          	lw	a5,80(s0)
   17aa4:	04078263          	beqz	a5,17ae8 <fputwc+0x68>
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
   17aa8:	01061783          	lh	a5,16(a2)
   17aac:	00002737          	lui	a4,0x2
   17ab0:	03279693          	slli	a3,a5,0x32
   17ab4:	0006cc63          	bltz	a3,17acc <fputwc+0x4c>
	wchar_t wc _AND
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
   17ab8:	0ac62683          	lw	a3,172(a2)
  ORIENT(fp, 1);
   17abc:	00e7e7b3          	or	a5,a5,a4
   17ac0:	00f61823          	sh	a5,16(a2)
   17ac4:	00e6e733          	or	a4,a3,a4
   17ac8:	0ae62623          	sw	a4,172(a2)
  r = __fputwc(ptr, wc, fp);
   17acc:	00048593          	mv	a1,s1
   17ad0:	00040513          	mv	a0,s0
{
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
  return _fputwc_r (reent, wc, fp);
}
   17ad4:	02813083          	ld	ra,40(sp)
   17ad8:	02013403          	ld	s0,32(sp)
   17adc:	01813483          	ld	s1,24(sp)
   17ae0:	03010113          	addi	sp,sp,48
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
  r = __fputwc(ptr, wc, fp);
   17ae4:	e09ff06f          	j	178ec <__fputwc>
	wchar_t wc _AND
	FILE *fp)
{
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
   17ae8:	00040513          	mv	a0,s0
   17aec:	00b13423          	sd	a1,8(sp)
   17af0:	af4fc0ef          	jal	13de4 <__sinit>
   17af4:	00813603          	ld	a2,8(sp)
   17af8:	fb1ff06f          	j	17aa8 <fputwc+0x28>

0000000000017afc <__sfvwrite_r>:
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
   17afc:	01063783          	ld	a5,16(a2)
   17b00:	26078a63          	beqz	a5,17d74 <__sfvwrite_r+0x278>
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   17b04:	0105d703          	lhu	a4,16(a1)
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   17b08:	f9010113          	addi	sp,sp,-112
   17b0c:	06813023          	sd	s0,96(sp)
   17b10:	03513c23          	sd	s5,56(sp)
   17b14:	03613823          	sd	s6,48(sp)
   17b18:	06113423          	sd	ra,104(sp)
   17b1c:	04913c23          	sd	s1,88(sp)
   17b20:	05213823          	sd	s2,80(sp)
   17b24:	05313423          	sd	s3,72(sp)
   17b28:	05413023          	sd	s4,64(sp)
   17b2c:	03713423          	sd	s7,40(sp)
   17b30:	03813023          	sd	s8,32(sp)
   17b34:	01913c23          	sd	s9,24(sp)
   17b38:	01a13823          	sd	s10,16(sp)
   17b3c:	01b13423          	sd	s11,8(sp)

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   17b40:	00877793          	andi	a5,a4,8
   17b44:	00058413          	mv	s0,a1
   17b48:	00050b13          	mv	s6,a0
   17b4c:	00060a93          	mv	s5,a2
   17b50:	0a078863          	beqz	a5,17c00 <__sfvwrite_r+0x104>
   17b54:	0185b783          	ld	a5,24(a1)
   17b58:	0a078463          	beqz	a5,17c00 <__sfvwrite_r+0x104>
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   17b5c:	00277793          	andi	a5,a4,2

  /* make sure we can write */
  if (cantwrite (ptr, fp))
    return EOF;

  iov = uio->uio_iov;
   17b60:	000ab483          	ld	s1,0(s5)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   17b64:	0c078063          	beqz	a5,17c24 <__sfvwrite_r+0x128>
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
   17b68:	80000a37          	lui	s4,0x80000
   17b6c:	00000993          	li	s3,0
   17b70:	00000913          	li	s2,0
   17b74:	c00a4a13          	xori	s4,s4,-1024
   17b78:	00098613          	mv	a2,s3
   17b7c:	000b0513          	mv	a0,s6
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   17b80:	1e090263          	beqz	s2,17d64 <__sfvwrite_r+0x268>
	  w = fp->_write (ptr, fp->_cookie, p,
   17b84:	00090693          	mv	a3,s2
   17b88:	012a7463          	bleu	s2,s4,17b90 <__sfvwrite_r+0x94>
   17b8c:	000a0693          	mv	a3,s4
   17b90:	04043783          	ld	a5,64(s0)
   17b94:	03043583          	ld	a1,48(s0)
   17b98:	0006869b          	sext.w	a3,a3
   17b9c:	000780e7          	jalr	a5
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
   17ba0:	22a05063          	blez	a0,17dc0 <__sfvwrite_r+0x2c4>
	    goto err;
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   17ba4:	010ab783          	ld	a5,16(s5)
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
	    goto err;
	  p += w;
   17ba8:	00a989b3          	add	s3,s3,a0
	  len -= w;
   17bac:	40a90933          	sub	s2,s2,a0
	}
      while ((uio->uio_resid -= w) != 0);
   17bb0:	40a78533          	sub	a0,a5,a0
   17bb4:	00aab823          	sd	a0,16(s5)
   17bb8:	fc0510e3          	bnez	a0,17b78 <__sfvwrite_r+0x7c>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   17bbc:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   17bc0:	06813083          	ld	ra,104(sp)
   17bc4:	00078513          	mv	a0,a5
   17bc8:	06013403          	ld	s0,96(sp)
   17bcc:	05813483          	ld	s1,88(sp)
   17bd0:	05013903          	ld	s2,80(sp)
   17bd4:	04813983          	ld	s3,72(sp)
   17bd8:	04013a03          	ld	s4,64(sp)
   17bdc:	03813a83          	ld	s5,56(sp)
   17be0:	03013b03          	ld	s6,48(sp)
   17be4:	02813b83          	ld	s7,40(sp)
   17be8:	02013c03          	ld	s8,32(sp)
   17bec:	01813c83          	ld	s9,24(sp)
   17bf0:	01013d03          	ld	s10,16(sp)
   17bf4:	00813d83          	ld	s11,8(sp)
   17bf8:	07010113          	addi	sp,sp,112
   17bfc:	00008067          	ret

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   17c00:	00040593          	mv	a1,s0
   17c04:	000b0513          	mv	a0,s6
   17c08:	cd0fa0ef          	jal	120d8 <__swsetup_r>
    return EOF;
   17c0c:	fff00793          	li	a5,-1

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   17c10:	fa0518e3          	bnez	a0,17bc0 <__sfvwrite_r+0xc4>
   17c14:	01045703          	lhu	a4,16(s0)
    return EOF;

  iov = uio->uio_iov;
   17c18:	000ab483          	ld	s1,0(s5)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   17c1c:	00277793          	andi	a5,a4,2
   17c20:	f40794e3          	bnez	a5,17b68 <__sfvwrite_r+0x6c>
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
    }
  else if ((fp->_flags & __SLBF) == 0)
   17c24:	00177793          	andi	a5,a4,1
   17c28:	1a079663          	bnez	a5,17dd4 <__sfvwrite_r+0x2d8>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   17c2c:	80000bb7          	lui	s7,0x80000
   17c30:	ffebcc13          	xori	s8,s7,-2
   17c34:	00000c93          	li	s9,0
   17c38:	00000913          	li	s2,0
   17c3c:	fffbcb93          	not	s7,s7
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   17c40:	10090a63          	beqz	s2,17d54 <__sfvwrite_r+0x258>
	  w = fp->_w;
   17c44:	00c42983          	lw	s3,12(s0)
	  if (fp->_flags & __SSTR)
   17c48:	20077793          	andi	a5,a4,512
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_w;
   17c4c:	00098a13          	mv	s4,s3
	  if (fp->_flags & __SSTR)
   17c50:	26078863          	beqz	a5,17ec0 <__sfvwrite_r+0x3c4>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
   17c54:	2b396a63          	bltu	s2,s3,17f08 <__sfvwrite_r+0x40c>
   17c58:	48077793          	andi	a5,a4,1152
   17c5c:	2a078663          	beqz	a5,17f08 <__sfvwrite_r+0x40c>
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   17c60:	02042a03          	lw	s4,32(s0)
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   17c64:	01843583          	ld	a1,24(s0)
   17c68:	00043d03          	ld	s10,0(s0)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   17c6c:	001a179b          	slliw	a5,s4,0x1
   17c70:	01478a3b          	addw	s4,a5,s4
   17c74:	01fa579b          	srliw	a5,s4,0x1f
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   17c78:	40bd0d3b          	subw	s10,s10,a1
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   17c7c:	01478a3b          	addw	s4,a5,s4
		  if (newsize < curpos + len + 1)
   17c80:	000d0993          	mv	s3,s10
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   17c84:	401a5a1b          	sraiw	s4,s4,0x1
		  if (newsize < curpos + len + 1)
   17c88:	00198793          	addi	a5,s3,1
   17c8c:	000a0613          	mv	a2,s4
   17c90:	012787b3          	add	a5,a5,s2
   17c94:	00f67863          	bleu	a5,a2,17ca4 <__sfvwrite_r+0x1a8>
		    newsize = curpos + len + 1;
   17c98:	001d0a1b          	addiw	s4,s10,1
   17c9c:	01490a3b          	addw	s4,s2,s4
   17ca0:	000a0613          	mv	a2,s4
		  if (fp->_flags & __SOPT)
   17ca4:	40077713          	andi	a4,a4,1024
   17ca8:	2a070a63          	beqz	a4,17f5c <__sfvwrite_r+0x460>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
   17cac:	00060593          	mv	a1,a2
   17cb0:	000b0513          	mv	a0,s6
   17cb4:	97dfc0ef          	jal	14630 <_malloc_r>
   17cb8:	00050d93          	mv	s11,a0
		      if (!str)
   17cbc:	2e050263          	beqz	a0,17fa0 <__sfvwrite_r+0x4a4>
			{
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		      memcpy (str, fp->_bf._base, curpos);
   17cc0:	01843583          	ld	a1,24(s0)
   17cc4:	00098613          	mv	a2,s3
   17cc8:	9c0fd0ef          	jal	14e88 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   17ccc:	01045783          	lhu	a5,16(s0)
   17cd0:	b7f7f793          	andi	a5,a5,-1153
   17cd4:	0807e793          	ori	a5,a5,128
   17cd8:	00f41823          	sh	a5,16(s0)
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
   17cdc:	41aa0d3b          	subw	s10,s4,s10
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
   17ce0:	013d8533          	add	a0,s11,s3
		  fp->_bf._size = newsize;
   17ce4:	03442023          	sw	s4,32(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
   17ce8:	01b43c23          	sd	s11,24(s0)
		  fp->_p = str + curpos;
   17cec:	00a43023          	sd	a0,0(s0)
		  fp->_bf._size = newsize;
		  w = len;
   17cf0:	00090a13          	mv	s4,s2
		  fp->_w = newsize - curpos;
   17cf4:	01a42623          	sw	s10,12(s0)
		}
	      if (len < w)
   17cf8:	000a0d13          	mv	s10,s4
   17cfc:	00090993          	mv	s3,s2
   17d00:	01497863          	bleu	s4,s2,17d10 <__sfvwrite_r+0x214>
   17d04:	00090d13          	mv	s10,s2
   17d08:	00090993          	mv	s3,s2
		w = len;
   17d0c:	00090a13          	mv	s4,s2
	      COPY (w);		/* copy MIN(fp->_w,len), */
   17d10:	000d0613          	mv	a2,s10
   17d14:	000c8593          	mv	a1,s9
   17d18:	298000ef          	jal	17fb0 <memmove>
	      fp->_w -= w;
   17d1c:	00c42783          	lw	a5,12(s0)
	      fp->_p += w;
   17d20:	00043603          	ld	a2,0(s0)
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   17d24:	41478a3b          	subw	s4,a5,s4
	      fp->_p += w;
   17d28:	01a60633          	add	a2,a2,s10
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   17d2c:	01442623          	sw	s4,12(s0)
	      fp->_p += w;
   17d30:	00c43023          	sd	a2,0(s0)
		goto err;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   17d34:	010ab503          	ld	a0,16(s5)
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
	    }
	  p += w;
   17d38:	013c8cb3          	add	s9,s9,s3
	  len -= w;
   17d3c:	41390933          	sub	s2,s2,s3
	}
      while ((uio->uio_resid -= w) != 0);
   17d40:	413509b3          	sub	s3,a0,s3
   17d44:	013ab823          	sd	s3,16(s5)
   17d48:	e6098ae3          	beqz	s3,17bbc <__sfvwrite_r+0xc0>
   17d4c:	01045703          	lhu	a4,16(s0)
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   17d50:	ee091ae3          	bnez	s2,17c44 <__sfvwrite_r+0x148>
   17d54:	0004bc83          	ld	s9,0(s1)
   17d58:	0084b903          	ld	s2,8(s1)
   17d5c:	01048493          	addi	s1,s1,16
   17d60:	ee1ff06f          	j	17c40 <__sfvwrite_r+0x144>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   17d64:	0004b983          	ld	s3,0(s1)
   17d68:	0084b903          	ld	s2,8(s1)
   17d6c:	01048493          	addi	s1,s1,16
   17d70:	e09ff06f          	j	17b78 <__sfvwrite_r+0x7c>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   17d74:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   17d78:	00078513          	mv	a0,a5
   17d7c:	00008067          	ret
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
   17d80:	01397463          	bleu	s3,s2,17d88 <__sfvwrite_r+0x28c>
   17d84:	00090993          	mv	s3,s2
	      COPY (w);
   17d88:	00098613          	mv	a2,s3
   17d8c:	000c8593          	mv	a1,s9
   17d90:	220000ef          	jal	17fb0 <memmove>
	      fp->_w -= w;
   17d94:	00c42783          	lw	a5,12(s0)
	      fp->_p += w;
   17d98:	00043703          	ld	a4,0(s0)
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   17d9c:	413787bb          	subw	a5,a5,s3
	      fp->_p += w;
   17da0:	01370733          	add	a4,a4,s3
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   17da4:	00f42623          	sw	a5,12(s0)
	      fp->_p += w;
   17da8:	00e43023          	sd	a4,0(s0)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
   17dac:	f80794e3          	bnez	a5,17d34 <__sfvwrite_r+0x238>
   17db0:	00040593          	mv	a1,s0
   17db4:	000b0513          	mv	a0,s6
   17db8:	c81fb0ef          	jal	13a38 <_fflush_r>
   17dbc:	f6050ce3          	beqz	a0,17d34 <__sfvwrite_r+0x238>
   17dc0:	01041783          	lh	a5,16(s0)
      while ((uio->uio_resid -= w) != 0);
    }
  return 0;

err:
  fp->_flags |= __SERR;
   17dc4:	0407e793          	ori	a5,a5,64
   17dc8:	00f41823          	sh	a5,16(s0)
  return EOF;
   17dcc:	fff00793          	li	a5,-1
   17dd0:	df1ff06f          	j	17bc0 <__sfvwrite_r+0xc4>
   17dd4:	00000a13          	li	s4,0
   17dd8:	00000c13          	li	s8,0
   17ddc:	00000d13          	li	s10,0
   17de0:	00000913          	li	s2,0
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   17de4:	06090e63          	beqz	s2,17e60 <__sfvwrite_r+0x364>
	  if (!nlknown)
   17de8:	140c0863          	beqz	s8,17f38 <__sfvwrite_r+0x43c>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   17dec:	000a0993          	mv	s3,s4
   17df0:	01497463          	bleu	s4,s2,17df8 <__sfvwrite_r+0x2fc>
   17df4:	00090993          	mv	s3,s2
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
   17df8:	00043503          	ld	a0,0(s0)
   17dfc:	01843783          	ld	a5,24(s0)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   17e00:	00098b93          	mv	s7,s3
	  w = fp->_w + fp->_bf._size;
   17e04:	02042683          	lw	a3,32(s0)
	  if (fp->_p > fp->_bf._base && s > w)
   17e08:	00a7fa63          	bleu	a0,a5,17e1c <__sfvwrite_r+0x320>
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
   17e0c:	00c42c83          	lw	s9,12(s0)
   17e10:	01968cbb          	addw	s9,a3,s9
   17e14:	000c8d93          	mv	s11,s9
	  if (fp->_p > fp->_bf._base && s > w)
   17e18:	053dce63          	blt	s11,s3,17e74 <__sfvwrite_r+0x378>
	      /* fp->_w -= w; */
	      fp->_p += w;
	      if (_fflush_r (ptr, fp))
		goto err;
	    }
	  else if (s >= (w = fp->_bf._size))
   17e1c:	0ed9ca63          	blt	s3,a3,17f10 <__sfvwrite_r+0x414>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
   17e20:	04043783          	ld	a5,64(s0)
   17e24:	03043583          	ld	a1,48(s0)
   17e28:	000d0613          	mv	a2,s10
   17e2c:	000b0513          	mv	a0,s6
   17e30:	000780e7          	jalr	a5
   17e34:	00050b93          	mv	s7,a0
	      if (w <= 0)
   17e38:	f8a054e3          	blez	a0,17dc0 <__sfvwrite_r+0x2c4>
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   17e3c:	417a0a3b          	subw	s4,s4,s7
   17e40:	060a0463          	beqz	s4,17ea8 <__sfvwrite_r+0x3ac>
	      nlknown = 0;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   17e44:	010ab783          	ld	a5,16(s5)
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
		goto err;
	      nlknown = 0;
	    }
	  p += w;
   17e48:	017d0d33          	add	s10,s10,s7
	  len -= w;
   17e4c:	41790933          	sub	s2,s2,s7
	}
      while ((uio->uio_resid -= w) != 0);
   17e50:	41778bb3          	sub	s7,a5,s7
   17e54:	017ab823          	sd	s7,16(s5)
   17e58:	d60b82e3          	beqz	s7,17bbc <__sfvwrite_r+0xc0>
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   17e5c:	f80916e3          	bnez	s2,17de8 <__sfvwrite_r+0x2ec>
   17e60:	0004bd03          	ld	s10,0(s1)
   17e64:	0084b903          	ld	s2,8(s1)
   17e68:	00000c13          	li	s8,0
   17e6c:	01048493          	addi	s1,s1,16
   17e70:	f75ff06f          	j	17de4 <__sfvwrite_r+0x2e8>
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
   17e74:	000d0593          	mv	a1,s10
   17e78:	000c8613          	mv	a2,s9
   17e7c:	134000ef          	jal	17fb0 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
   17e80:	00043783          	ld	a5,0(s0)
	      if (_fflush_r (ptr, fp))
   17e84:	00040593          	mv	a1,s0
   17e88:	000b0513          	mv	a0,s6
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
	      /* fp->_w -= w; */
	      fp->_p += w;
   17e8c:	01b78db3          	add	s11,a5,s11
   17e90:	01b43023          	sd	s11,0(s0)
	      if (_fflush_r (ptr, fp))
   17e94:	ba5fb0ef          	jal	13a38 <_fflush_r>
   17e98:	f20514e3          	bnez	a0,17dc0 <__sfvwrite_r+0x2c4>
   17e9c:	000c8b93          	mv	s7,s9
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   17ea0:	417a0a3b          	subw	s4,s4,s7
   17ea4:	fa0a10e3          	bnez	s4,17e44 <__sfvwrite_r+0x348>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
   17ea8:	00040593          	mv	a1,s0
   17eac:	000b0513          	mv	a0,s6
   17eb0:	b89fb0ef          	jal	13a38 <_fflush_r>
   17eb4:	f00516e3          	bnez	a0,17dc0 <__sfvwrite_r+0x2c4>
		goto err;
	      nlknown = 0;
   17eb8:	00000c13          	li	s8,0
   17ebc:	f89ff06f          	j	17e44 <__sfvwrite_r+0x348>
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
	      fp->_p += w;
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
   17ec0:	00043503          	ld	a0,0(s0)
   17ec4:	01843783          	ld	a5,24(s0)
   17ec8:	eaa7ece3          	bltu	a5,a0,17d80 <__sfvwrite_r+0x284>
   17ecc:	02042783          	lw	a5,32(s0)
   17ed0:	eaf968e3          	bltu	s2,a5,17d80 <__sfvwrite_r+0x284>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   17ed4:	000b8693          	mv	a3,s7
   17ed8:	012c6463          	bltu	s8,s2,17ee0 <__sfvwrite_r+0x3e4>
   17edc:	0009069b          	sext.w	a3,s2
	      w = fp->_write (ptr, fp->_cookie, p, w);
   17ee0:	02f6c6bb          	divw	a3,a3,a5
   17ee4:	04043703          	ld	a4,64(s0)
   17ee8:	03043583          	ld	a1,48(s0)
   17eec:	000c8613          	mv	a2,s9
   17ef0:	000b0513          	mv	a0,s6
   17ef4:	02f686bb          	mulw	a3,a3,a5
   17ef8:	000700e7          	jalr	a4
	      if (w <= 0)
   17efc:	eca052e3          	blez	a0,17dc0 <__sfvwrite_r+0x2c4>
   17f00:	00050993          	mv	s3,a0
   17f04:	e31ff06f          	j	17d34 <__sfvwrite_r+0x238>
   17f08:	00043503          	ld	a0,0(s0)
   17f0c:	dedff06f          	j	17cf8 <__sfvwrite_r+0x1fc>
		goto err;
	    }
	  else
	    {
	      w = s;
	      COPY (w);
   17f10:	00098613          	mv	a2,s3
   17f14:	000d0593          	mv	a1,s10
   17f18:	098000ef          	jal	17fb0 <memmove>
	      fp->_w -= w;
   17f1c:	00c42703          	lw	a4,12(s0)
	      fp->_p += w;
   17f20:	00043783          	ld	a5,0(s0)
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   17f24:	4137073b          	subw	a4,a4,s3
	      fp->_p += w;
   17f28:	013789b3          	add	s3,a5,s3
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   17f2c:	00e42623          	sw	a4,12(s0)
	      fp->_p += w;
   17f30:	01343023          	sd	s3,0(s0)
   17f34:	f09ff06f          	j	17e3c <__sfvwrite_r+0x340>
      do
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
   17f38:	00090613          	mv	a2,s2
   17f3c:	00a00593          	li	a1,10
   17f40:	000d0513          	mv	a0,s10
   17f44:	e5dfc0ef          	jal	14da0 <memchr>
	      nldist = nl ? nl + 1 - p : len + 1;
   17f48:	04050663          	beqz	a0,17f94 <__sfvwrite_r+0x498>
   17f4c:	00150a13          	addi	s4,a0,1
   17f50:	41aa0a3b          	subw	s4,s4,s10
	      nlknown = 1;
   17f54:	00100c13          	li	s8,1
   17f58:	e95ff06f          	j	17dec <__sfvwrite_r+0x2f0>
		      memcpy (str, fp->_bf._base, curpos);
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   17f5c:	000b0513          	mv	a0,s6
   17f60:	170000ef          	jal	180d0 <_realloc_r>
   17f64:	00050d93          	mv	s11,a0
							 newsize);
		      if (!str)
   17f68:	d6051ae3          	bnez	a0,17cdc <__sfvwrite_r+0x1e0>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
   17f6c:	01843583          	ld	a1,24(s0)
   17f70:	000b0513          	mv	a0,s6
   17f74:	fc9fb0ef          	jal	13f3c <_free_r>
			  fp->_flags &=  ~__SMBF;
   17f78:	01045783          	lhu	a5,16(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
   17f7c:	00c00713          	li	a4,12
   17f80:	00eb2023          	sw	a4,0(s6)
		      if (!str)
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
			  fp->_flags &=  ~__SMBF;
   17f84:	f7f7f793          	andi	a5,a5,-129
   17f88:	0107979b          	slliw	a5,a5,0x10
   17f8c:	4107d79b          	sraiw	a5,a5,0x10
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
   17f90:	e35ff06f          	j	17dc4 <__sfvwrite_r+0x2c8>
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
   17f94:	00190a1b          	addiw	s4,s2,1
	      nlknown = 1;
   17f98:	00100c13          	li	s8,1
   17f9c:	e51ff06f          	j	17dec <__sfvwrite_r+0x2f0>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
		      if (!str)
			{
			  ptr->_errno = ENOMEM;
   17fa0:	00c00793          	li	a5,12
   17fa4:	00fb2023          	sw	a5,0(s6)
   17fa8:	01041783          	lh	a5,16(s0)
			  goto err;
   17fac:	e19ff06f          	j	17dc4 <__sfvwrite_r+0x2c8>

0000000000017fb0 <memmove>:
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
   17fb0:	02a5f863          	bleu	a0,a1,17fe0 <memmove+0x30>
   17fb4:	00c58733          	add	a4,a1,a2
   17fb8:	02e57463          	bleu	a4,a0,17fe0 <memmove+0x30>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
   17fbc:	00c507b3          	add	a5,a0,a2
   17fc0:	40c785b3          	sub	a1,a5,a2
      while (length--)
   17fc4:	0e060263          	beqz	a2,180a8 <memmove+0xf8>
	{
	  *--dst = *--src;
   17fc8:	fff70713          	addi	a4,a4,-1 # 1fff <_ftext-0xe001>
   17fcc:	00074683          	lbu	a3,0(a4)
   17fd0:	fff78793          	addi	a5,a5,-1
   17fd4:	00d78023          	sb	a3,0(a5)
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
   17fd8:	fef598e3          	bne	a1,a5,17fc8 <memmove+0x18>
   17fdc:	00008067          	ret
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
   17fe0:	01f00893          	li	a7,31
   17fe4:	0cc8f463          	bleu	a2,a7,180ac <memmove+0xfc>
   17fe8:	00a5e7b3          	or	a5,a1,a0
   17fec:	0077f793          	andi	a5,a5,7
   17ff0:	0c079463          	bnez	a5,180b8 <memmove+0x108>
   17ff4:	00058713          	mv	a4,a1
   17ff8:	00050793          	mv	a5,a0
   17ffc:	00060693          	mv	a3,a2
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   18000:	00073803          	ld	a6,0(a4)
   18004:	02078793          	addi	a5,a5,32
   18008:	02070713          	addi	a4,a4,32
   1800c:	ff07b023          	sd	a6,-32(a5)
              *aligned_dst++ = *aligned_src++;
   18010:	fe873803          	ld	a6,-24(a4)
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
   18014:	fe068693          	addi	a3,a3,-32

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
   18018:	ff07b423          	sd	a6,-24(a5)
              *aligned_dst++ = *aligned_src++;
   1801c:	ff073803          	ld	a6,-16(a4)
   18020:	ff07b823          	sd	a6,-16(a5)
              *aligned_dst++ = *aligned_src++;
   18024:	ff873803          	ld	a6,-8(a4)
   18028:	ff07bc23          	sd	a6,-8(a5)
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
   1802c:	fcd8eae3          	bltu	a7,a3,18000 <memmove+0x50>
   18030:	fe060713          	addi	a4,a2,-32
   18034:	fe077713          	andi	a4,a4,-32
   18038:	02070713          	addi	a4,a4,32
   1803c:	01f67e13          	andi	t3,a2,31
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   18040:	00700313          	li	t1,7
   18044:	00e507b3          	add	a5,a0,a4
   18048:	00e585b3          	add	a1,a1,a4
   1804c:	07c37c63          	bleu	t3,t1,180c4 <memmove+0x114>
   18050:	00058813          	mv	a6,a1
   18054:	00078693          	mv	a3,a5
   18058:	000e0713          	mv	a4,t3
            {
              *aligned_dst++ = *aligned_src++;
   1805c:	00880813          	addi	a6,a6,8
   18060:	ff883883          	ld	a7,-8(a6)
   18064:	00868693          	addi	a3,a3,8
              length -= LITTLEBLOCKSIZE;
   18068:	ff870713          	addi	a4,a4,-8
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   1806c:	ff16bc23          	sd	a7,-8(a3)
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   18070:	fee366e3          	bltu	t1,a4,1805c <memmove+0xac>
   18074:	ff8e0713          	addi	a4,t3,-8
   18078:	ff877713          	andi	a4,a4,-8
   1807c:	00870713          	addi	a4,a4,8
   18080:	00767613          	andi	a2,a2,7
   18084:	00e787b3          	add	a5,a5,a4
   18088:	00e585b3          	add	a1,a1,a4
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   1808c:	02060a63          	beqz	a2,180c0 <memmove+0x110>
   18090:	00c78633          	add	a2,a5,a2
        {
          *dst++ = *src++;
   18094:	00158593          	addi	a1,a1,1
   18098:	fff5c703          	lbu	a4,-1(a1)
   1809c:	00178793          	addi	a5,a5,1
   180a0:	fee78fa3          	sb	a4,-1(a5)
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   180a4:	fec798e3          	bne	a5,a2,18094 <memmove+0xe4>
        }
    }

  return dst_void;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   180a8:	00008067          	ret
   180ac:	00050793          	mv	a5,a0
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   180b0:	fe0610e3          	bnez	a2,18090 <memmove+0xe0>
   180b4:	00c0006f          	j	180c0 <memmove+0x110>
   180b8:	00050793          	mv	a5,a0
   180bc:	fd5ff06f          	j	18090 <memmove+0xe0>
   180c0:	00008067          	ret
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   180c4:	000e0613          	mv	a2,t3
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   180c8:	fc0614e3          	bnez	a2,18090 <memmove+0xe0>
   180cc:	ff5ff06f          	j	180c0 <memmove+0x110>

00000000000180d0 <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
   180d0:	fb010113          	addi	sp,sp,-80
   180d4:	02913c23          	sd	s1,56(sp)
   180d8:	04113423          	sd	ra,72(sp)
   180dc:	04813023          	sd	s0,64(sp)
   180e0:	03213823          	sd	s2,48(sp)
   180e4:	03313423          	sd	s3,40(sp)
   180e8:	03413023          	sd	s4,32(sp)
   180ec:	01513c23          	sd	s5,24(sp)
   180f0:	01613823          	sd	s6,16(sp)
   180f4:	01713423          	sd	s7,8(sp)
   180f8:	01813023          	sd	s8,0(sp)
   180fc:	00060493          	mv	s1,a2
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   18100:	1c058a63          	beqz	a1,182d4 <_realloc_r+0x204>
   18104:	00058993          	mv	s3,a1
   18108:	00050913          	mv	s2,a0

  MALLOC_LOCK;
   1810c:	f79fc0ef          	jal	15084 <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
   18110:	ff89b783          	ld	a5,-8(s3)


  nb = request2size(bytes);
   18114:	01748413          	addi	s0,s1,23
   18118:	02e00713          	li	a4,46
  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);

  MALLOC_LOCK;

  newp    = oldp    = mem2chunk(oldmem);
   1811c:	ff098a93          	addi	s5,s3,-16
  newsize = oldsize = chunksize(oldp);
   18120:	ffc7fa13          	andi	s4,a5,-4


  nb = request2size(bytes);
   18124:	0c877463          	bleu	s0,a4,181ec <_realloc_r+0x11c>

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   18128:	80000737          	lui	a4,0x80000

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
   1812c:	ff047413          	andi	s0,s0,-16

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   18130:	fff74713          	not	a4,a4
   18134:	14876a63          	bltu	a4,s0,18288 <_realloc_r+0x1b8>
   18138:	14946863          	bltu	s0,s1,18288 <_realloc_r+0x1b8>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   1813c:	0a8a5c63          	ble	s0,s4,181f4 <_realloc_r+0x124>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next)) 
   18140:	0001bb37          	lui	s6,0x1b
   18144:	ab8b0b13          	addi	s6,s6,-1352 # 1aab8 <__malloc_av_>
   18148:	010b3703          	ld	a4,16(s6)
  if ((long)(oldsize) < (long)(nb))  
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
   1814c:	014a86b3          	add	a3,s5,s4
    if (next == top || !inuse(next)) 
   18150:	2ee68e63          	beq	a3,a4,1844c <_realloc_r+0x37c>
   18154:	0086b703          	ld	a4,8(a3)
   18158:	ffe77613          	andi	a2,a4,-2
   1815c:	00c68633          	add	a2,a3,a2
   18160:	00863603          	ld	a2,8(a2)
   18164:	00167613          	andi	a2,a2,1
   18168:	0e060c63          	beqz	a2,18260 <_realloc_r+0x190>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   1816c:	0017f793          	andi	a5,a5,1
   18170:	26078063          	beqz	a5,183d0 <_realloc_r+0x300>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
   18174:	00048593          	mv	a1,s1
   18178:	00090513          	mv	a0,s2
   1817c:	cb4fc0ef          	jal	14630 <_malloc_r>
   18180:	00050493          	mv	s1,a0

    if (newmem == 0)  /* propagate failure */
   18184:	48050e63          	beqz	a0,18620 <_realloc_r+0x550>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
   18188:	ff89b783          	ld	a5,-8(s3)
   1818c:	ff050713          	addi	a4,a0,-16
   18190:	ffe7f793          	andi	a5,a5,-2
   18194:	00fa87b3          	add	a5,s5,a5
   18198:	40f70e63          	beq	a4,a5,185b4 <_realloc_r+0x4e4>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1819c:	ff8a0613          	addi	a2,s4,-8 # ffffffff7ffffff8 <_gp+0xffffffff7ffe4528>
   181a0:	04800793          	li	a5,72
   181a4:	3ec7e263          	bltu	a5,a2,18588 <_realloc_r+0x4b8>
   181a8:	02700713          	li	a4,39
   181ac:	36c76663          	bltu	a4,a2,18518 <_realloc_r+0x448>
   181b0:	00050793          	mv	a5,a0
   181b4:	00098713          	mv	a4,s3
   181b8:	00073683          	ld	a3,0(a4) # ffffffff80000000 <_gp+0xffffffff7ffe4530>
   181bc:	00d7b023          	sd	a3,0(a5)
   181c0:	00873683          	ld	a3,8(a4)
   181c4:	00d7b423          	sd	a3,8(a5)
   181c8:	01073703          	ld	a4,16(a4)
   181cc:	00e7b823          	sd	a4,16(a5)
    fREe(RCALL oldmem);
   181d0:	00098593          	mv	a1,s3
   181d4:	00090513          	mv	a0,s2
   181d8:	d65fb0ef          	jal	13f3c <_free_r>
    MALLOC_UNLOCK;
   181dc:	00090513          	mv	a0,s2
   181e0:	ea9fc0ef          	jal	15088 <__malloc_unlock>
    return newmem;
   181e4:	00048513          	mv	a0,s1
   181e8:	0480006f          	j	18230 <_realloc_r+0x160>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
   181ec:	02000413          	li	s0,32
   181f0:	f49ff06f          	j	18138 <_realloc_r+0x68>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   181f4:	00098493          	mv	s1,s3
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
   181f8:	408a07b3          	sub	a5,s4,s0

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
   181fc:	01f00713          	li	a4,31
   18200:	08f76c63          	bltu	a4,a5,18298 <_realloc_r+0x1c8>
    set_inuse_bit_at_offset(remainder, remainder_size);
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
  }
  else
  {
    set_head_size(newp, newsize);
   18204:	008ab783          	ld	a5,8(s5)
    set_inuse_bit_at_offset(newp, newsize);
   18208:	014a8733          	add	a4,s5,s4
    set_inuse_bit_at_offset(remainder, remainder_size);
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
  }
  else
  {
    set_head_size(newp, newsize);
   1820c:	0017f793          	andi	a5,a5,1
   18210:	0147e633          	or	a2,a5,s4
   18214:	00cab423          	sd	a2,8(s5)
    set_inuse_bit_at_offset(newp, newsize);
   18218:	00873783          	ld	a5,8(a4)
   1821c:	0017e793          	ori	a5,a5,1
   18220:	00f73423          	sd	a5,8(a4)
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
   18224:	00090513          	mv	a0,s2
   18228:	e61fc0ef          	jal	15088 <__malloc_unlock>
  return chunk2mem(newp);
   1822c:	00048513          	mv	a0,s1

#endif /* MALLOC_PROVIDED */
}
   18230:	04813083          	ld	ra,72(sp)
   18234:	04013403          	ld	s0,64(sp)
   18238:	03813483          	ld	s1,56(sp)
   1823c:	03013903          	ld	s2,48(sp)
   18240:	02813983          	ld	s3,40(sp)
   18244:	02013a03          	ld	s4,32(sp)
   18248:	01813a83          	ld	s5,24(sp)
   1824c:	01013b03          	ld	s6,16(sp)
   18250:	00813b83          	ld	s7,8(sp)
   18254:	00013c03          	ld	s8,0(sp)
   18258:	05010113          	addi	sp,sp,80
   1825c:	00008067          	ret
          return chunk2mem(oldp);
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
   18260:	ffc77713          	andi	a4,a4,-4
   18264:	01470733          	add	a4,a4,s4
   18268:	0a874063          	blt	a4,s0,18308 <_realloc_r+0x238>
      { 
        unlink(next, bck, fwd);
   1826c:	0186b783          	ld	a5,24(a3)
   18270:	0106b683          	ld	a3,16(a3)
        newsize  += nextsize;
        goto split;
   18274:	00098493          	mv	s1,s3

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
        newsize  += nextsize;
   18278:	00070a13          	mv	s4,a4
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
   1827c:	00f6bc23          	sd	a5,24(a3)
   18280:	00d7b823          	sd	a3,16(a5)
        newsize  += nextsize;
        goto split;
   18284:	f75ff06f          	j	181f8 <_realloc_r+0x128>
  nb = request2size(bytes);

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   18288:	00c00793          	li	a5,12
   1828c:	00f92023          	sw	a5,0(s2)
    return 0;
   18290:	00000513          	li	a0,0
   18294:	f9dff06f          	j	18230 <_realloc_r+0x160>
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   18298:	008ab703          	ld	a4,8(s5)

  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
   1829c:	008a85b3          	add	a1,s5,s0
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
   182a0:	0017e693          	ori	a3,a5,1
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   182a4:	00177713          	andi	a4,a4,1
   182a8:	00876433          	or	s0,a4,s0
   182ac:	008ab423          	sd	s0,8(s5)
    set_head(remainder, remainder_size | PREV_INUSE);
   182b0:	00d5b423          	sd	a3,8(a1)
    set_inuse_bit_at_offset(remainder, remainder_size);
   182b4:	00f587b3          	add	a5,a1,a5
   182b8:	0087b703          	ld	a4,8(a5)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   182bc:	01058593          	addi	a1,a1,16
   182c0:	00090513          	mv	a0,s2
  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
   182c4:	00176713          	ori	a4,a4,1
   182c8:	00e7b423          	sd	a4,8(a5)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   182cc:	c71fb0ef          	jal	13f3c <_free_r>
   182d0:	f55ff06f          	j	18224 <_realloc_r+0x154>
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   182d4:	04813083          	ld	ra,72(sp)
   182d8:	04013403          	ld	s0,64(sp)
   182dc:	03813483          	ld	s1,56(sp)
   182e0:	03013903          	ld	s2,48(sp)
   182e4:	02813983          	ld	s3,40(sp)
   182e8:	02013a03          	ld	s4,32(sp)
   182ec:	01813a83          	ld	s5,24(sp)
   182f0:	01013b03          	ld	s6,16(sp)
   182f4:	00813b83          	ld	s7,8(sp)
   182f8:	00013c03          	ld	s8,0(sp)
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   182fc:	00060593          	mv	a1,a2
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   18300:	05010113          	addi	sp,sp,80
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   18304:	b2cfc06f          	j	14630 <_malloc_r>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   18308:	0017f793          	andi	a5,a5,1
   1830c:	e60794e3          	bnez	a5,18174 <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   18310:	ff09bb83          	ld	s7,-16(s3)
   18314:	417a8bb3          	sub	s7,s5,s7
      prevsize = chunksize(prev);
   18318:	008bb783          	ld	a5,8(s7) # ffffffff80000008 <_gp+0xffffffff7ffe4538>
   1831c:	ffc7f793          	andi	a5,a5,-4
            return newmem;
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
   18320:	00f70b33          	add	s6,a4,a5
   18324:	0a8b4e63          	blt	s6,s0,183e0 <_realloc_r+0x310>
        {
          unlink(next, bck, fwd);
   18328:	0186b783          	ld	a5,24(a3)
   1832c:	0106b703          	ld	a4,16(a3)
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18330:	ff8a0613          	addi	a2,s4,-8
        {
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
   18334:	010b8493          	addi	s1,s7,16
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
        {
          unlink(next, bck, fwd);
   18338:	00f73c23          	sd	a5,24(a4)
   1833c:	00e7b823          	sd	a4,16(a5)
          unlink(prev, bck, fwd);
   18340:	010bb703          	ld	a4,16(s7)
   18344:	018bb783          	ld	a5,24(s7)
   18348:	00f73c23          	sd	a5,24(a4)
   1834c:	00e7b823          	sd	a4,16(a5)
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18350:	04800793          	li	a5,72
   18354:	1ec7e463          	bltu	a5,a2,1853c <_realloc_r+0x46c>
   18358:	02700713          	li	a4,39
   1835c:	00048793          	mv	a5,s1
   18360:	04c77663          	bleu	a2,a4,183ac <_realloc_r+0x2dc>
   18364:	0009b783          	ld	a5,0(s3)
   18368:	00fbb823          	sd	a5,16(s7)
   1836c:	0089b783          	ld	a5,8(s3)
   18370:	00fbbc23          	sd	a5,24(s7)
   18374:	03700793          	li	a5,55
   18378:	24c7f863          	bleu	a2,a5,185c8 <_realloc_r+0x4f8>
   1837c:	0109b783          	ld	a5,16(s3)
   18380:	02fbb023          	sd	a5,32(s7)
   18384:	0189b783          	ld	a5,24(s3)
   18388:	02fbb423          	sd	a5,40(s7)
   1838c:	04800793          	li	a5,72
   18390:	0af61863          	bne	a2,a5,18440 <_realloc_r+0x370>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18394:	0209b703          	ld	a4,32(s3)
   18398:	040b8793          	addi	a5,s7,64
   1839c:	03098993          	addi	s3,s3,48
   183a0:	02ebb823          	sd	a4,48(s7)
   183a4:	ff89b703          	ld	a4,-8(s3)
   183a8:	02ebbc23          	sd	a4,56(s7)
   183ac:	0009b703          	ld	a4,0(s3)
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   183b0:	000b0a13          	mv	s4,s6
   183b4:	000b8a93          	mv	s5,s7
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   183b8:	00e7b023          	sd	a4,0(a5)
   183bc:	0089b703          	ld	a4,8(s3)
   183c0:	00e7b423          	sd	a4,8(a5)
   183c4:	0109b703          	ld	a4,16(s3)
   183c8:	00e7b823          	sd	a4,16(a5)
   183cc:	e2dff06f          	j	181f8 <_realloc_r+0x128>

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
   183d0:	ff09bb83          	ld	s7,-16(s3)
   183d4:	417a8bb3          	sub	s7,s5,s7
      prevsize = chunksize(prev);
   183d8:	008bb783          	ld	a5,8(s7)
   183dc:	ffc7f793          	andi	a5,a5,-4
          goto split;
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
   183e0:	00fa0b33          	add	s6,s4,a5
   183e4:	d88b48e3          	blt	s6,s0,18174 <_realloc_r+0xa4>
      {
        unlink(prev, bck, fwd);
   183e8:	018bb783          	ld	a5,24(s7)
   183ec:	010bb703          	ld	a4,16(s7)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   183f0:	ff8a0613          	addi	a2,s4,-8
   183f4:	04800693          	li	a3,72
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   183f8:	00f73c23          	sd	a5,24(a4)
   183fc:	00e7b823          	sd	a4,16(a5)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
   18400:	010b8493          	addi	s1,s7,16
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18404:	12c6ec63          	bltu	a3,a2,1853c <_realloc_r+0x46c>
   18408:	02700713          	li	a4,39
   1840c:	00048793          	mv	a5,s1
   18410:	f8c77ee3          	bleu	a2,a4,183ac <_realloc_r+0x2dc>
   18414:	0009b783          	ld	a5,0(s3)
   18418:	00fbb823          	sd	a5,16(s7)
   1841c:	0089b783          	ld	a5,8(s3)
   18420:	00fbbc23          	sd	a5,24(s7)
   18424:	03700793          	li	a5,55
   18428:	1ac7f063          	bleu	a2,a5,185c8 <_realloc_r+0x4f8>
   1842c:	0109b783          	ld	a5,16(s3)
   18430:	02fbb023          	sd	a5,32(s7)
   18434:	0189b783          	ld	a5,24(s3)
   18438:	02fbb423          	sd	a5,40(s7)
   1843c:	f4d60ce3          	beq	a2,a3,18394 <_realloc_r+0x2c4>
   18440:	030b8793          	addi	a5,s7,48
   18444:	02098993          	addi	s3,s3,32
   18448:	f65ff06f          	j	183ac <_realloc_r+0x2dc>
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
   1844c:	0086b703          	ld	a4,8(a3)
   18450:	02040693          	addi	a3,s0,32
   18454:	ffc77713          	andi	a4,a4,-4
   18458:	01470733          	add	a4,a4,s4
   1845c:	0ed75c63          	ble	a3,a4,18554 <_realloc_r+0x484>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   18460:	0017f793          	andi	a5,a5,1
   18464:	d00798e3          	bnez	a5,18174 <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   18468:	ff09bb83          	ld	s7,-16(s3)
   1846c:	417a8bb3          	sub	s7,s5,s7
      prevsize = chunksize(prev);
   18470:	008bb783          	ld	a5,8(s7)
   18474:	ffc7f793          	andi	a5,a5,-4
      if (next != 0)
      {
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
   18478:	00e78c33          	add	s8,a5,a4
   1847c:	f6dc42e3          	blt	s8,a3,183e0 <_realloc_r+0x310>
          {
            unlink(prev, bck, fwd);
   18480:	018bb783          	ld	a5,24(s7)
   18484:	010bb703          	ld	a4,16(s7)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18488:	ff8a0613          	addi	a2,s4,-8
   1848c:	04800693          	li	a3,72
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   18490:	00f73c23          	sd	a5,24(a4)
   18494:	00e7b823          	sd	a4,16(a5)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
   18498:	010b8493          	addi	s1,s7,16
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1849c:	14c6ea63          	bltu	a3,a2,185f0 <_realloc_r+0x520>
   184a0:	02700713          	li	a4,39
   184a4:	00048793          	mv	a5,s1
   184a8:	02c77263          	bleu	a2,a4,184cc <_realloc_r+0x3fc>
   184ac:	0009b783          	ld	a5,0(s3)
   184b0:	00fbb823          	sd	a5,16(s7)
   184b4:	0089b783          	ld	a5,8(s3)
   184b8:	00fbbc23          	sd	a5,24(s7)
   184bc:	03700793          	li	a5,55
   184c0:	14c7e063          	bltu	a5,a2,18600 <_realloc_r+0x530>
   184c4:	020b8793          	addi	a5,s7,32
   184c8:	01098993          	addi	s3,s3,16
   184cc:	0009b703          	ld	a4,0(s3)
   184d0:	00e7b023          	sd	a4,0(a5)
   184d4:	0089b703          	ld	a4,8(s3)
   184d8:	00e7b423          	sd	a4,8(a5)
   184dc:	0109b703          	ld	a4,16(s3)
   184e0:	00e7b823          	sd	a4,16(a5)
            top = chunk_at_offset(newp, nb);
   184e4:	008b8733          	add	a4,s7,s0
            set_head(top, (newsize - nb) | PREV_INUSE);
   184e8:	408c07b3          	sub	a5,s8,s0
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   184ec:	00eb3823          	sd	a4,16(s6)
            set_head(top, (newsize - nb) | PREV_INUSE);
   184f0:	0017e793          	ori	a5,a5,1
   184f4:	00f73423          	sd	a5,8(a4)
            set_head_size(newp, nb);
   184f8:	008bb783          	ld	a5,8(s7)
	    MALLOC_UNLOCK;
   184fc:	00090513          	mv	a0,s2
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
            set_head_size(newp, nb);
   18500:	0017f793          	andi	a5,a5,1
   18504:	0087e433          	or	s0,a5,s0
   18508:	008bb423          	sd	s0,8(s7)
	    MALLOC_UNLOCK;
   1850c:	b7dfc0ef          	jal	15088 <__malloc_unlock>
            return newmem;
   18510:	00048513          	mv	a0,s1
   18514:	d1dff06f          	j	18230 <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18518:	0009b703          	ld	a4,0(s3)
   1851c:	00e53023          	sd	a4,0(a0)
   18520:	0089b703          	ld	a4,8(s3)
   18524:	00e53423          	sd	a4,8(a0)
   18528:	03700713          	li	a4,55
   1852c:	06c76463          	bltu	a4,a2,18594 <_realloc_r+0x4c4>
   18530:	01050793          	addi	a5,a0,16
   18534:	01098713          	addi	a4,s3,16
   18538:	c81ff06f          	j	181b8 <_realloc_r+0xe8>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1853c:	00098593          	mv	a1,s3
   18540:	00048513          	mv	a0,s1
   18544:	a6dff0ef          	jal	17fb0 <memmove>
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   18548:	000b0a13          	mv	s4,s6
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1854c:	000b8a93          	mv	s5,s7
   18550:	ca9ff06f          	j	181f8 <_realloc_r+0x128>
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   18554:	008a8ab3          	add	s5,s5,s0
          set_head(top, (newsize - nb) | PREV_INUSE);
   18558:	408707b3          	sub	a5,a4,s0
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   1855c:	015b3823          	sd	s5,16(s6)
          set_head(top, (newsize - nb) | PREV_INUSE);
   18560:	0017e793          	ori	a5,a5,1
   18564:	00fab423          	sd	a5,8(s5)
          set_head_size(oldp, nb);
   18568:	ff89b783          	ld	a5,-8(s3)
	  MALLOC_UNLOCK;
   1856c:	00090513          	mv	a0,s2
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
          set_head_size(oldp, nb);
   18570:	0017f793          	andi	a5,a5,1
   18574:	0087e433          	or	s0,a5,s0
   18578:	fe89bc23          	sd	s0,-8(s3)
	  MALLOC_UNLOCK;
   1857c:	b0dfc0ef          	jal	15088 <__malloc_unlock>
          return chunk2mem(oldp);
   18580:	00098513          	mv	a0,s3
   18584:	cadff06f          	j	18230 <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18588:	00098593          	mv	a1,s3
   1858c:	a25ff0ef          	jal	17fb0 <memmove>
   18590:	c41ff06f          	j	181d0 <_realloc_r+0x100>
   18594:	0109b703          	ld	a4,16(s3)
   18598:	00e53823          	sd	a4,16(a0)
   1859c:	0189b703          	ld	a4,24(s3)
   185a0:	00e53c23          	sd	a4,24(a0)
   185a4:	02f60863          	beq	a2,a5,185d4 <_realloc_r+0x504>
   185a8:	02050793          	addi	a5,a0,32
   185ac:	02098713          	addi	a4,s3,32
   185b0:	c09ff06f          	j	181b8 <_realloc_r+0xe8>
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   185b4:	ff853783          	ld	a5,-8(a0)
      newp = oldp;
      goto split;
   185b8:	00098493          	mv	s1,s3
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   185bc:	ffc7f793          	andi	a5,a5,-4
   185c0:	00fa0a33          	add	s4,s4,a5
      newp = oldp;
      goto split;
   185c4:	c35ff06f          	j	181f8 <_realloc_r+0x128>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   185c8:	020b8793          	addi	a5,s7,32
   185cc:	01098993          	addi	s3,s3,16
   185d0:	dddff06f          	j	183ac <_realloc_r+0x2dc>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   185d4:	0209b683          	ld	a3,32(s3)
   185d8:	03050793          	addi	a5,a0,48
   185dc:	03098713          	addi	a4,s3,48
   185e0:	02d53023          	sd	a3,32(a0)
   185e4:	0289b683          	ld	a3,40(s3)
   185e8:	02d53423          	sd	a3,40(a0)
   185ec:	bcdff06f          	j	181b8 <_realloc_r+0xe8>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   185f0:	00098593          	mv	a1,s3
   185f4:	00048513          	mv	a0,s1
   185f8:	9b9ff0ef          	jal	17fb0 <memmove>
   185fc:	ee9ff06f          	j	184e4 <_realloc_r+0x414>
   18600:	0109b783          	ld	a5,16(s3)
   18604:	02fbb023          	sd	a5,32(s7)
   18608:	0189b783          	ld	a5,24(s3)
   1860c:	02fbb423          	sd	a5,40(s7)
   18610:	02d60063          	beq	a2,a3,18630 <_realloc_r+0x560>
   18614:	030b8793          	addi	a5,s7,48
   18618:	02098993          	addi	s3,s3,32
   1861c:	eb1ff06f          	j	184cc <_realloc_r+0x3fc>

    newmem = mALLOc (RCALL bytes);

    if (newmem == 0)  /* propagate failure */
    {
      MALLOC_UNLOCK;
   18620:	00090513          	mv	a0,s2
   18624:	a65fc0ef          	jal	15088 <__malloc_unlock>
      return 0;
   18628:	00000513          	li	a0,0
   1862c:	c05ff06f          	j	18230 <_realloc_r+0x160>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18630:	0209b703          	ld	a4,32(s3)
   18634:	040b8793          	addi	a5,s7,64
   18638:	03098993          	addi	s3,s3,48
   1863c:	02ebb823          	sd	a4,48(s7)
   18640:	ff89b703          	ld	a4,-8(s3)
   18644:	02ebbc23          	sd	a4,56(s7)
   18648:	e85ff06f          	j	184cc <_realloc_r+0x3fc>

000000000001864c <__swbuf_r>:
int
_DEFUN(__swbuf_r, (ptr, c, fp),
       struct _reent *ptr _AND
       register int c _AND
       register FILE *fp)
{
   1864c:	fd010113          	addi	sp,sp,-48
   18650:	02813023          	sd	s0,32(sp)
   18654:	00913c23          	sd	s1,24(sp)
   18658:	01313423          	sd	s3,8(sp)
   1865c:	02113423          	sd	ra,40(sp)
   18660:	01213823          	sd	s2,16(sp)
   18664:	00050493          	mv	s1,a0
   18668:	00058993          	mv	s3,a1
   1866c:	00060413          	mv	s0,a2
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
   18670:	00050663          	beqz	a0,1867c <__swbuf_r+0x30>
   18674:	05052783          	lw	a5,80(a0)
   18678:	12078e63          	beqz	a5,187b4 <__swbuf_r+0x168>
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
   1867c:	01041683          	lh	a3,16(s0)
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
   18680:	02842783          	lw	a5,40(s0)
  if (cantwrite (ptr, fp))
   18684:	03069713          	slli	a4,a3,0x30
   18688:	03075713          	srli	a4,a4,0x30
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
   1868c:	00f42623          	sw	a5,12(s0)
  if (cantwrite (ptr, fp))
   18690:	00877793          	andi	a5,a4,8
   18694:	0e078e63          	beqz	a5,18790 <__swbuf_r+0x144>
   18698:	01843783          	ld	a5,24(s0)
   1869c:	0e078a63          	beqz	a5,18790 <__swbuf_r+0x144>
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   186a0:	03271613          	slli	a2,a4,0x32
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   186a4:	0ff9f913          	andi	s2,s3,255

  ORIENT (fp, -1);
   186a8:	06065663          	bgez	a2,18714 <__swbuf_r+0xc8>
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   186ac:	00043703          	ld	a4,0(s0)
  if (n >= fp->_bf._size)
   186b0:	02042683          	lw	a3,32(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   186b4:	40f707bb          	subw	a5,a4,a5
  if (n >= fp->_bf._size)
   186b8:	08d7d663          	ble	a3,a5,18744 <__swbuf_r+0xf8>
   186bc:	0017879b          	addiw	a5,a5,1
    {
      if (_fflush_r (ptr, fp))
	return EOF;
      n = 0;
    }
  fp->_w--;
   186c0:	00c42683          	lw	a3,12(s0)
  *fp->_p++ = c;
   186c4:	00170613          	addi	a2,a4,1
   186c8:	00c43023          	sd	a2,0(s0)
    {
      if (_fflush_r (ptr, fp))
	return EOF;
      n = 0;
    }
  fp->_w--;
   186cc:	fff6869b          	addiw	a3,a3,-1
   186d0:	00d42623          	sw	a3,12(s0)
  *fp->_p++ = c;
   186d4:	01370023          	sb	s3,0(a4)
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   186d8:	02042703          	lw	a4,32(s0)
   186dc:	08f70263          	beq	a4,a5,18760 <__swbuf_r+0x114>
   186e0:	01045783          	lhu	a5,16(s0)
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   186e4:	00090513          	mv	a0,s2
	return EOF;
      n = 0;
    }
  fp->_w--;
  *fp->_p++ = c;
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   186e8:	0017f793          	andi	a5,a5,1
   186ec:	00078663          	beqz	a5,186f8 <__swbuf_r+0xac>
   186f0:	00a00793          	li	a5,10
   186f4:	06f90663          	beq	s2,a5,18760 <__swbuf_r+0x114>
    if (_fflush_r (ptr, fp))
      return EOF;
  return c;
}
   186f8:	02813083          	ld	ra,40(sp)
   186fc:	02013403          	ld	s0,32(sp)
   18700:	01813483          	ld	s1,24(sp)
   18704:	01013903          	ld	s2,16(sp)
   18708:	00813983          	ld	s3,8(sp)
   1870c:	03010113          	addi	sp,sp,48
   18710:	00008067          	ret
  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   18714:	0ac42583          	lw	a1,172(s0)
   18718:	ffffe737          	lui	a4,0xffffe
   1871c:	fff7071b          	addiw	a4,a4,-1
   18720:	00e5f733          	and	a4,a1,a4
   18724:	00002637          	lui	a2,0x2
   18728:	00c6e6b3          	or	a3,a3,a2
   1872c:	0ae42623          	sw	a4,172(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   18730:	00043703          	ld	a4,0(s0)
  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   18734:	00d41823          	sh	a3,16(s0)
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
  if (n >= fp->_bf._size)
   18738:	02042683          	lw	a3,32(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   1873c:	40f707bb          	subw	a5,a4,a5
  if (n >= fp->_bf._size)
   18740:	f6d7cee3          	blt	a5,a3,186bc <__swbuf_r+0x70>
    {
      if (_fflush_r (ptr, fp))
   18744:	00040593          	mv	a1,s0
   18748:	00048513          	mv	a0,s1
   1874c:	aecfb0ef          	jal	13a38 <_fflush_r>
   18750:	06051663          	bnez	a0,187bc <__swbuf_r+0x170>
   18754:	00043703          	ld	a4,0(s0)
   18758:	00100793          	li	a5,1
   1875c:	f65ff06f          	j	186c0 <__swbuf_r+0x74>
      n = 0;
    }
  fp->_w--;
  *fp->_p++ = c;
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
    if (_fflush_r (ptr, fp))
   18760:	00040593          	mv	a1,s0
   18764:	00048513          	mv	a0,s1
   18768:	ad0fb0ef          	jal	13a38 <_fflush_r>
   1876c:	04051863          	bnez	a0,187bc <__swbuf_r+0x170>
      return EOF;
  return c;
}
   18770:	02813083          	ld	ra,40(sp)
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   18774:	00090513          	mv	a0,s2
  *fp->_p++ = c;
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
    if (_fflush_r (ptr, fp))
      return EOF;
  return c;
}
   18778:	02013403          	ld	s0,32(sp)
   1877c:	01813483          	ld	s1,24(sp)
   18780:	01013903          	ld	s2,16(sp)
   18784:	00813983          	ld	s3,8(sp)
   18788:	03010113          	addi	sp,sp,48
   1878c:	00008067          	ret
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
   18790:	00040593          	mv	a1,s0
   18794:	00048513          	mv	a0,s1
   18798:	941f90ef          	jal	120d8 <__swsetup_r>
   1879c:	02051063          	bnez	a0,187bc <__swbuf_r+0x170>
   187a0:	01041683          	lh	a3,16(s0)
   187a4:	01843783          	ld	a5,24(s0)
   187a8:	03069713          	slli	a4,a3,0x30
   187ac:	03075713          	srli	a4,a4,0x30
   187b0:	ef1ff06f          	j	186a0 <__swbuf_r+0x54>
{
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
   187b4:	e30fb0ef          	jal	13de4 <__sinit>
   187b8:	ec5ff06f          	j	1867c <__swbuf_r+0x30>
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
   187bc:	fff00513          	li	a0,-1
   187c0:	f39ff06f          	j	186f8 <__swbuf_r+0xac>

00000000000187c4 <__swbuf>:
int
_DEFUN(__swbuf, (c, fp),
       register int c _AND
       register FILE *fp)
{
  return __swbuf_r (_REENT, c, fp);
   187c4:	00058613          	mv	a2,a1
   187c8:	00050593          	mv	a1,a0
   187cc:	8101b503          	ld	a0,-2032(gp) # 1b2e0 <_impure_ptr>
   187d0:	e7dff06f          	j	1864c <__swbuf_r>

00000000000187d4 <_wcrtomb_r>:
_DEFUN (_wcrtomb_r, (ptr, s, wc, ps),
	struct _reent *ptr _AND
	char *s _AND
	wchar_t wc _AND
	mbstate_t *ps)
{
   187d4:	fc010113          	addi	sp,sp,-64
   187d8:	02913423          	sd	s1,40(sp)
   187dc:	03213023          	sd	s2,32(sp)
   187e0:	02113c23          	sd	ra,56(sp)
   187e4:	02813823          	sd	s0,48(sp)
   187e8:	01313c23          	sd	s3,24(sp)
   187ec:	01413823          	sd	s4,16(sp)
   187f0:	00050493          	mv	s1,a0
   187f4:	00068913          	mv	s2,a3
      _REENT_CHECK_MISC(ptr);
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
   187f8:	06058663          	beqz	a1,18864 <_wcrtomb_r+0x90>
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
  else
    retval = __wctomb (ptr, s, wc, __locale_charset (), ps);
   187fc:	8301ba03          	ld	s4,-2000(gp) # 1b300 <__wctomb>
   18800:	00058413          	mv	s0,a1
   18804:	00060993          	mv	s3,a2
   18808:	c2dfb0ef          	jal	14434 <__locale_charset>
   1880c:	00050693          	mv	a3,a0
   18810:	00090713          	mv	a4,s2
   18814:	00098613          	mv	a2,s3
   18818:	00040593          	mv	a1,s0
   1881c:	00048513          	mv	a0,s1
   18820:	000a00e7          	jalr	s4
   18824:	00050793          	mv	a5,a0

  if (retval == -1)
   18828:	fff00713          	li	a4,-1
      ps->__count = 0;
      ptr->_errno = EILSEQ;
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
   1882c:	00078513          	mv	a0,a5
  if (s == NULL)
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
  else
    retval = __wctomb (ptr, s, wc, __locale_charset (), ps);

  if (retval == -1)
   18830:	00e79a63          	bne	a5,a4,18844 <_wcrtomb_r+0x70>
    {
      ps->__count = 0;
   18834:	00092023          	sw	zero,0(s2)
      ptr->_errno = EILSEQ;
   18838:	08a00793          	li	a5,138
   1883c:	00f4a023          	sw	a5,0(s1)
      return (size_t)(-1);
   18840:	fff00513          	li	a0,-1
    }
  else
    return (size_t)retval;
}
   18844:	03813083          	ld	ra,56(sp)
   18848:	03013403          	ld	s0,48(sp)
   1884c:	02813483          	ld	s1,40(sp)
   18850:	02013903          	ld	s2,32(sp)
   18854:	01813983          	ld	s3,24(sp)
   18858:	01013a03          	ld	s4,16(sp)
   1885c:	04010113          	addi	sp,sp,64
   18860:	00008067          	ret
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
   18864:	8301b403          	ld	s0,-2000(gp) # 1b300 <__wctomb>
   18868:	bcdfb0ef          	jal	14434 <__locale_charset>
   1886c:	00050693          	mv	a3,a0
   18870:	00090713          	mv	a4,s2
   18874:	00000613          	li	a2,0
   18878:	00010593          	mv	a1,sp
   1887c:	00048513          	mv	a0,s1
   18880:	000400e7          	jalr	s0
   18884:	00050793          	mv	a5,a0
   18888:	fa1ff06f          	j	18828 <_wcrtomb_r+0x54>

000000000001888c <wcrtomb>:
size_t
_DEFUN (wcrtomb, (s, wc, ps),
	char *__restrict s _AND
	wchar_t wc _AND
	mbstate_t *__restrict ps)
{
   1888c:	fc010113          	addi	sp,sp,-64
   18890:	02913423          	sd	s1,40(sp)
   18894:	03213023          	sd	s2,32(sp)
   18898:	02113c23          	sd	ra,56(sp)
   1889c:	02813823          	sd	s0,48(sp)
   188a0:	01313c23          	sd	s3,24(sp)
   188a4:	01413823          	sd	s4,16(sp)
   188a8:	00060913          	mv	s2,a2
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  return _wcrtomb_r (_REENT, s, wc, ps);
#else
  int retval = 0;
  struct _reent *reent = _REENT;
   188ac:	8101b483          	ld	s1,-2032(gp) # 1b2e0 <_impure_ptr>
      _REENT_CHECK_MISC(reent);
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
   188b0:	06050663          	beqz	a0,1891c <wcrtomb+0x90>
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
  else
    retval = __wctomb (reent, s, wc, __locale_charset (), ps);
   188b4:	8301ba03          	ld	s4,-2000(gp) # 1b300 <__wctomb>
   188b8:	00058993          	mv	s3,a1
   188bc:	00050413          	mv	s0,a0
   188c0:	b75fb0ef          	jal	14434 <__locale_charset>
   188c4:	00050693          	mv	a3,a0
   188c8:	00090713          	mv	a4,s2
   188cc:	00098613          	mv	a2,s3
   188d0:	00040593          	mv	a1,s0
   188d4:	00048513          	mv	a0,s1
   188d8:	000a00e7          	jalr	s4
   188dc:	00050793          	mv	a5,a0

  if (retval == -1)
   188e0:	fff00713          	li	a4,-1
      ps->__count = 0;
      reent->_errno = EILSEQ;
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
   188e4:	00078513          	mv	a0,a5
  if (s == NULL)
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
  else
    retval = __wctomb (reent, s, wc, __locale_charset (), ps);

  if (retval == -1)
   188e8:	00e79a63          	bne	a5,a4,188fc <wcrtomb+0x70>
    {
      ps->__count = 0;
   188ec:	00092023          	sw	zero,0(s2)
      reent->_errno = EILSEQ;
   188f0:	08a00793          	li	a5,138
   188f4:	00f4a023          	sw	a5,0(s1)
      return (size_t)(-1);
   188f8:	fff00513          	li	a0,-1
    }
  else
    return (size_t)retval;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   188fc:	03813083          	ld	ra,56(sp)
   18900:	03013403          	ld	s0,48(sp)
   18904:	02813483          	ld	s1,40(sp)
   18908:	02013903          	ld	s2,32(sp)
   1890c:	01813983          	ld	s3,24(sp)
   18910:	01013a03          	ld	s4,16(sp)
   18914:	04010113          	addi	sp,sp,64
   18918:	00008067          	ret
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
   1891c:	8301b403          	ld	s0,-2000(gp) # 1b300 <__wctomb>
   18920:	b15fb0ef          	jal	14434 <__locale_charset>
   18924:	00050693          	mv	a3,a0
   18928:	00090713          	mv	a4,s2
   1892c:	00000613          	li	a2,0
   18930:	00010593          	mv	a1,sp
   18934:	00048513          	mv	a0,s1
   18938:	000400e7          	jalr	s0
   1893c:	00050793          	mv	a5,a0
   18940:	fa1ff06f          	j	188e0 <wcrtomb+0x54>

0000000000018944 <__ascii_wctomb>:
  /* Avoids compiler warnings about comparisons that are always false
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;

  if (s == NULL)
   18944:	00058c63          	beqz	a1,1895c <__ascii_wctomb+0x18>
    return 0;
 
#ifdef __CYGWIN__
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
   18948:	0ff00793          	li	a5,255
   1894c:	00c7ec63          	bltu	a5,a2,18964 <__ascii_wctomb+0x20>
    {
      r->_errno = EILSEQ;
      return -1;
    }

  *s = (char) wchar;
   18950:	00c58023          	sb	a2,0(a1)
  return 1;
   18954:	00100513          	li	a0,1
   18958:	00008067          	ret
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;

  if (s == NULL)
    return 0;
   1895c:	00000513          	li	a0,0
      return -1;
    }

  *s = (char) wchar;
  return 1;
}
   18960:	00008067          	ret
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
#endif
    {
      r->_errno = EILSEQ;
   18964:	08a00793          	li	a5,138
   18968:	00f52023          	sw	a5,0(a0)
      return -1;
   1896c:	fff00513          	li	a0,-1
   18970:	00008067          	ret

0000000000018974 <_wctomb_r>:
_DEFUN (_wctomb_r, (r, s, wchar, state),
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
   18974:	fd010113          	addi	sp,sp,-48
   18978:	02813023          	sd	s0,32(sp)
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   1897c:	8301b403          	ld	s0,-2000(gp) # 1b300 <__wctomb>
_DEFUN (_wctomb_r, (r, s, wchar, state),
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
   18980:	02113423          	sd	ra,40(sp)
   18984:	00913c23          	sd	s1,24(sp)
   18988:	01213823          	sd	s2,16(sp)
   1898c:	01313423          	sd	s3,8(sp)
   18990:	01413023          	sd	s4,0(sp)
   18994:	00050493          	mv	s1,a0
   18998:	00068a13          	mv	s4,a3
   1899c:	00058913          	mv	s2,a1
   189a0:	00060993          	mv	s3,a2
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   189a4:	a91fb0ef          	jal	14434 <__locale_charset>
   189a8:	000a0713          	mv	a4,s4
   189ac:	00050693          	mv	a3,a0
   189b0:	00098613          	mv	a2,s3
   189b4:	00090593          	mv	a1,s2
   189b8:	00048513          	mv	a0,s1
   189bc:	00040313          	mv	t1,s0
}
   189c0:	02813083          	ld	ra,40(sp)
   189c4:	02013403          	ld	s0,32(sp)
   189c8:	01813483          	ld	s1,24(sp)
   189cc:	01013903          	ld	s2,16(sp)
   189d0:	00813983          	ld	s3,8(sp)
   189d4:	00013a03          	ld	s4,0(sp)
   189d8:	03010113          	addi	sp,sp,48
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   189dc:	00030067          	jr	t1

00000000000189e0 <__syscall_error>:

#define syscall_errno(n, a, b, c, d) \
        __internal_syscall(n, (long)(a), (long)(b), (long)(c), (long)(d))

long __syscall_error(long a0)
{
   189e0:	ff010113          	addi	sp,sp,-16
   189e4:	00113423          	sd	ra,8(sp)
   189e8:	00813023          	sd	s0,0(sp)
   189ec:	00050413          	mv	s0,a0
  errno = -a0;
   189f0:	3c0000ef          	jal	18db0 <__errno>
  return -1;
}
   189f4:	00813083          	ld	ra,8(sp)
#define syscall_errno(n, a, b, c, d) \
        __internal_syscall(n, (long)(a), (long)(b), (long)(c), (long)(d))

long __syscall_error(long a0)
{
  errno = -a0;
   189f8:	408007bb          	negw	a5,s0
   189fc:	00f52023          	sw	a5,0(a0)
  return -1;
}
   18a00:	00013403          	ld	s0,0(sp)
   18a04:	fff00513          	li	a0,-1
   18a08:	01010113          	addi	sp,sp,16
   18a0c:	00008067          	ret

0000000000018a10 <open>:
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
  register long a3 asm("a3") = _a3;
   18a10:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18a14:	40000893          	li	a7,1024

  asm volatile ("scall\n"
   18a18:	00000073          	ecall
   18a1c:	fc0542e3          	bltz	a0,189e0 <__syscall_error>

int open(const char* name, int flags, int mode)
{
  return syscall_errno(SYS_open, name, flags, mode, 0);
}
   18a20:	0005051b          	sext.w	a0,a0
   18a24:	00008067          	ret

0000000000018a28 <openat>:
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
  register long a3 asm("a3") = _a3;
  register long a7 asm("a7") = n;
   18a28:	03800893          	li	a7,56

  asm volatile ("scall\n"
   18a2c:	00000073          	ecall
   18a30:	fa0548e3          	bltz	a0,189e0 <__syscall_error>
//------------------------------------------------------------------------
// Open file relative to given directory
int openat(int dirfd, const char* name, int flags, int mode)
{
  return syscall_errno(SYS_openat, dirfd, name, flags, mode);
}
   18a34:	0005051b          	sext.w	a0,a0
   18a38:	00008067          	ret

0000000000018a3c <lseek>:
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
  register long a3 asm("a3") = _a3;
   18a3c:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18a40:	03e00893          	li	a7,62

  asm volatile ("scall\n"
   18a44:	00000073          	ecall
   18a48:	f8054ce3          	bltz	a0,189e0 <__syscall_error>
// Set position in a file.

off_t lseek(int file, off_t ptr, int dir)
{
  return syscall_errno(SYS_lseek, file, ptr, dir, 0);
}
   18a4c:	00008067          	ret

0000000000018a50 <read>:
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
  register long a3 asm("a3") = _a3;
   18a50:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18a54:	03f00893          	li	a7,63

  asm volatile ("scall\n"
   18a58:	00000073          	ecall
   18a5c:	f80542e3          	bltz	a0,189e0 <__syscall_error>
// Read from a file.

ssize_t read(int file, void* ptr, size_t len)
{
  return syscall_errno(SYS_read, file, ptr, len, 0);
}
   18a60:	00008067          	ret

0000000000018a64 <write>:
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
  register long a3 asm("a3") = _a3;
   18a64:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18a68:	04000893          	li	a7,64

  asm volatile ("scall\n"
   18a6c:	00000073          	ecall
   18a70:	f60548e3          	bltz	a0,189e0 <__syscall_error>
// Write to a file.

ssize_t write(int file, const void* ptr, size_t len)
{
  return syscall_errno(SYS_write, file, ptr, len, 0);
}
   18a74:	00008067          	ret

0000000000018a78 <fstat>:
static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
   18a78:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18a7c:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18a80:	05000893          	li	a7,80

  asm volatile ("scall\n"
   18a84:	00000073          	ecall
   18a88:	f4054ce3          	bltz	a0,189e0 <__syscall_error>
// distributed in the include subdirectory for this C library.

int fstat(int file, struct stat* st)
{
  return syscall_errno(SYS_fstat, file, st, 0, 0);
}
   18a8c:	0005051b          	sext.w	a0,a0
   18a90:	00008067          	ret

0000000000018a94 <stat>:
static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
   18a94:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18a98:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18a9c:	40e00893          	li	a7,1038

  asm volatile ("scall\n"
   18aa0:	00000073          	ecall
   18aa4:	f2054ee3          	bltz	a0,189e0 <__syscall_error>
// Status of a file (by name).

int stat(const char* file, struct stat* st)
{
  return syscall_errno(SYS_stat, file, st, 0, 0);
}
   18aa8:	0005051b          	sext.w	a0,a0
   18aac:	00008067          	ret

0000000000018ab0 <lstat>:
static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
   18ab0:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18ab4:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18ab8:	40f00893          	li	a7,1039

  asm volatile ("scall\n"
   18abc:	00000073          	ecall
   18ac0:	f20540e3          	bltz	a0,189e0 <__syscall_error>
// Status of a link (by name).

int lstat(const char* file, struct stat* st)
{
  return syscall_errno(SYS_lstat, file, st, 0, 0);
}
   18ac4:	0005051b          	sext.w	a0,a0
   18ac8:	00008067          	ret

0000000000018acc <fstatat>:
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
  register long a3 asm("a3") = _a3;
  register long a7 asm("a7") = n;
   18acc:	04f00893          	li	a7,79

  asm volatile ("scall\n"
   18ad0:	00000073          	ecall
   18ad4:	f00546e3          	bltz	a0,189e0 <__syscall_error>
// Status of a file (by name) in a given directory.

int fstatat(int dirfd, const char* file, struct stat* st, int flags)
{
  return syscall_errno(SYS_fstatat, dirfd, file, st, flags);
}
   18ad8:	0005051b          	sext.w	a0,a0
   18adc:	00008067          	ret

0000000000018ae0 <access>:
static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
   18ae0:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18ae4:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18ae8:	40900893          	li	a7,1033

  asm volatile ("scall\n"
   18aec:	00000073          	ecall
   18af0:	ee0548e3          	bltz	a0,189e0 <__syscall_error>
// Permissions of a file (by name).

int access(const char* file, int mode)
{
  return syscall_errno(SYS_access, file, mode, 0, 0);
}
   18af4:	0005051b          	sext.w	a0,a0
   18af8:	00008067          	ret

0000000000018afc <faccessat>:
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
  register long a3 asm("a3") = _a3;
  register long a7 asm("a7") = n;
   18afc:	03000893          	li	a7,48

  asm volatile ("scall\n"
   18b00:	00000073          	ecall
   18b04:	ec054ee3          	bltz	a0,189e0 <__syscall_error>
// Permissions of a file (by name) in a given directory.

int faccessat(int dirfd, const char* file, int mode, int flags)
{
  return syscall_errno(SYS_faccessat, dirfd, file, mode, flags);
}
   18b08:	0005051b          	sext.w	a0,a0
   18b0c:	00008067          	ret

0000000000018b10 <close>:

static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
   18b10:	00000593          	li	a1,0
  register long a2 asm("a2") = _a2;
   18b14:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18b18:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18b1c:	03900893          	li	a7,57

  asm volatile ("scall\n"
   18b20:	00000073          	ecall
   18b24:	ea054ee3          	bltz	a0,189e0 <__syscall_error>
// Close a file.

int close(int file) 
{
  return syscall_errno(SYS_close, file, 0, 0, 0);
}
   18b28:	0005051b          	sext.w	a0,a0
   18b2c:	00008067          	ret

0000000000018b30 <link>:
static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
   18b30:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18b34:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18b38:	40100893          	li	a7,1025

  asm volatile ("scall\n"
   18b3c:	00000073          	ecall
   18b40:	ea0540e3          	bltz	a0,189e0 <__syscall_error>
// Establish a new name for an existing file.

int link(const char* old_name, const char* new_name)
{
  return syscall_errno(SYS_link, old_name, new_name, 0, 0);
}
   18b44:	0005051b          	sext.w	a0,a0
   18b48:	00008067          	ret

0000000000018b4c <unlink>:

static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
   18b4c:	00000593          	li	a1,0
  register long a2 asm("a2") = _a2;
   18b50:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18b54:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18b58:	40200893          	li	a7,1026

  asm volatile ("scall\n"
   18b5c:	00000073          	ecall
   18b60:	e80540e3          	bltz	a0,189e0 <__syscall_error>
// Remove a file's directory entry.

int unlink(const char* name)
{
  return syscall_errno(SYS_unlink, name, 0, 0, 0);
}
   18b64:	0005051b          	sext.w	a0,a0
   18b68:	00008067          	ret

0000000000018b6c <execve>:
//------------------------------------------------------------------------
// Transfer control to a new process. Minimal implementation for a
// system without processes from newlib documentation.

int execve(const char* name, char* const argv[], char* const env[])
{
   18b6c:	ff010113          	addi	sp,sp,-16
   18b70:	00113423          	sd	ra,8(sp)
  errno = ENOMEM;
   18b74:	23c000ef          	jal	18db0 <__errno>
  return -1;
}
   18b78:	00813083          	ld	ra,8(sp)
// Transfer control to a new process. Minimal implementation for a
// system without processes from newlib documentation.

int execve(const char* name, char* const argv[], char* const env[])
{
  errno = ENOMEM;
   18b7c:	00c00793          	li	a5,12
   18b80:	00f52023          	sw	a5,0(a0)
  return -1;
}
   18b84:	01010113          	addi	sp,sp,16
   18b88:	fff00513          	li	a0,-1
   18b8c:	00008067          	ret

0000000000018b90 <fork>:
//------------------------------------------------------------------------
// Create a new process. Minimal implementation for a system without
// processes from newlib documentation.

int fork() 
{
   18b90:	ff010113          	addi	sp,sp,-16
   18b94:	00113423          	sd	ra,8(sp)
  errno = EAGAIN;
   18b98:	218000ef          	jal	18db0 <__errno>
  return -1;
}
   18b9c:	00813083          	ld	ra,8(sp)
// Create a new process. Minimal implementation for a system without
// processes from newlib documentation.

int fork() 
{
  errno = EAGAIN;
   18ba0:	00b00793          	li	a5,11
   18ba4:	00f52023          	sw	a5,0(a0)
  return -1;
}
   18ba8:	01010113          	addi	sp,sp,16
   18bac:	fff00513          	li	a0,-1
   18bb0:	00008067          	ret

0000000000018bb4 <getpid>:
// system without processes just returns 1.

int getpid() 
{
  return 1;
}
   18bb4:	00100513          	li	a0,1
   18bb8:	00008067          	ret

0000000000018bbc <kill>:
//------------------------------------------------------------------------
// Send a signal. Minimal implementation for a system without processes
// just causes an error.

int kill(int pid, int sig)
{
   18bbc:	ff010113          	addi	sp,sp,-16
   18bc0:	00113423          	sd	ra,8(sp)
  errno = EINVAL;
   18bc4:	1ec000ef          	jal	18db0 <__errno>
  return -1;
}
   18bc8:	00813083          	ld	ra,8(sp)
// Send a signal. Minimal implementation for a system without processes
// just causes an error.

int kill(int pid, int sig)
{
  errno = EINVAL;
   18bcc:	01600793          	li	a5,22
   18bd0:	00f52023          	sw	a5,0(a0)
  return -1;
}
   18bd4:	01010113          	addi	sp,sp,16
   18bd8:	fff00513          	li	a0,-1
   18bdc:	00008067          	ret

0000000000018be0 <wait>:
//------------------------------------------------------------------------
// Wait for a child process. Minimal implementation for a system without
// processes just causes an error.

int wait(int* status)
{
   18be0:	ff010113          	addi	sp,sp,-16
   18be4:	00113423          	sd	ra,8(sp)
  errno = ECHILD;
   18be8:	1c8000ef          	jal	18db0 <__errno>
  return -1;
}
   18bec:	00813083          	ld	ra,8(sp)
// Wait for a child process. Minimal implementation for a system without
// processes just causes an error.

int wait(int* status)
{
  errno = ECHILD;
   18bf0:	00a00793          	li	a5,10
   18bf4:	00f52023          	sw	a5,0(a0)
  return -1;
}
   18bf8:	01010113          	addi	sp,sp,16
   18bfc:	fff00513          	li	a0,-1
   18c00:	00008067          	ret

0000000000018c04 <isatty>:
// Query whether output stream is a terminal. For consistency with the
// other minimal implementations, which only support output to stdout,
// this minimal implementation is suggested by the newlib docs.

int isatty(int file)
{
   18c04:	f8010113          	addi	sp,sp,-128

static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
   18c08:	00010593          	mv	a1,sp
  register long a2 asm("a2") = _a2;
   18c0c:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18c10:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18c14:	05000893          	li	a7,80

  asm volatile ("scall\n"
   18c18:	00000073          	ecall
   18c1c:	dc0542e3          	bltz	a0,189e0 <__syscall_error>
  struct stat s;
  int ret = fstat(file,&s);
  return ret == -1 ? -1 : !!(s.st_mode & S_IFCHR);
   18c20:	fff00793          	li	a5,-1
// Status of an open file. The sys/stat.h header file required is
// distributed in the include subdirectory for this C library.

int fstat(int file, struct stat* st)
{
  return syscall_errno(SYS_fstat, file, st, 0, 0);
   18c24:	0005051b          	sext.w	a0,a0

int isatty(int file)
{
  struct stat s;
  int ret = fstat(file,&s);
  return ret == -1 ? -1 : !!(s.st_mode & S_IFCHR);
   18c28:	00f50863          	beq	a0,a5,18c38 <isatty+0x34>
   18c2c:	01012503          	lw	a0,16(sp)
   18c30:	40d5551b          	sraiw	a0,a0,0xd
   18c34:	00157513          	andi	a0,a0,1
}
   18c38:	08010113          	addi	sp,sp,128
   18c3c:	00008067          	ret

0000000000018c40 <times>:

clock_t times(struct tms* buf)
{
  // when called for the first time, initialize t0
  static struct timeval t0;
  if(t0.tv_sec == 0)
   18c40:	92818313          	addi	t1,gp,-1752 # 1b3f8 <t0.2343>
   18c44:	00033703          	ld	a4,0(t1)
// children's times to zero. Eventually we might want to separately
// account for user vs system time, but for now we just return the total
// number of cycles since starting the program.

clock_t times(struct tms* buf)
{
   18c48:	ff010113          	addi	sp,sp,-16
   18c4c:	00050813          	mv	a6,a0
  // when called for the first time, initialize t0
  static struct timeval t0;
  if(t0.tv_sec == 0)
   18c50:	02071063          	bnez	a4,18c70 <times+0x30>
#define SYS_dup 23

static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
   18c54:	92818513          	addi	a0,gp,-1752 # 1b3f8 <t0.2343>
  register long a1 asm("a1") = _a1;
   18c58:	00000593          	li	a1,0
  register long a2 asm("a2") = _a2;
   18c5c:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18c60:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18c64:	0a900893          	li	a7,169

  asm volatile ("scall\n"
   18c68:	00000073          	ecall
   18c6c:	d6054ae3          	bltz	a0,189e0 <__syscall_error>
#define SYS_dup 23

static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
   18c70:	00010513          	mv	a0,sp
  register long a1 asm("a1") = _a1;
   18c74:	00000593          	li	a1,0
  register long a2 asm("a2") = _a2;
   18c78:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18c7c:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18c80:	0a900893          	li	a7,169

  asm volatile ("scall\n"
   18c84:	00000073          	ecall
   18c88:	d4054ce3          	bltz	a0,189e0 <__syscall_error>

  struct timeval t;
  gettimeofday(&t,0);

  long long utime = (t.tv_sec-t0.tv_sec)*1000000 + (t.tv_usec-t0.tv_usec);
  buf->tms_utime = utime*CLOCKS_PER_SEC/1000000;
   18c8c:	00033703          	ld	a4,0(t1)
   18c90:	00013783          	ld	a5,0(sp)
  buf->tms_stime = buf->tms_cstime = buf->tms_cutime = 0;
  
  return -1;
}
   18c94:	fff00513          	li	a0,-1
  struct timeval t;
  gettimeofday(&t,0);

  long long utime = (t.tv_sec-t0.tv_sec)*1000000 + (t.tv_usec-t0.tv_usec);
  buf->tms_utime = utime*CLOCKS_PER_SEC/1000000;
  buf->tms_stime = buf->tms_cstime = buf->tms_cutime = 0;
   18c98:	00083823          	sd	zero,16(a6)

  struct timeval t;
  gettimeofday(&t,0);

  long long utime = (t.tv_sec-t0.tv_sec)*1000000 + (t.tv_usec-t0.tv_usec);
  buf->tms_utime = utime*CLOCKS_PER_SEC/1000000;
   18c9c:	40e786b3          	sub	a3,a5,a4
   18ca0:	000f47b7          	lui	a5,0xf4
   18ca4:	24078793          	addi	a5,a5,576 # f4240 <_gp+0xd8770>
   18ca8:	02f68733          	mul	a4,a3,a5
   18cac:	00833683          	ld	a3,8(t1)
   18cb0:	00813783          	ld	a5,8(sp)
  buf->tms_stime = buf->tms_cstime = buf->tms_cutime = 0;
   18cb4:	00083c23          	sd	zero,24(a6)
   18cb8:	00083423          	sd	zero,8(a6)

  struct timeval t;
  gettimeofday(&t,0);

  long long utime = (t.tv_sec-t0.tv_sec)*1000000 + (t.tv_usec-t0.tv_usec);
  buf->tms_utime = utime*CLOCKS_PER_SEC/1000000;
   18cbc:	40d787b3          	sub	a5,a5,a3
  buf->tms_stime = buf->tms_cstime = buf->tms_cutime = 0;
  
  return -1;
}
   18cc0:	01010113          	addi	sp,sp,16

  struct timeval t;
  gettimeofday(&t,0);

  long long utime = (t.tv_sec-t0.tv_sec)*1000000 + (t.tv_usec-t0.tv_usec);
  buf->tms_utime = utime*CLOCKS_PER_SEC/1000000;
   18cc4:	00f707b3          	add	a5,a4,a5
   18cc8:	00f83023          	sd	a5,0(a6)
  buf->tms_stime = buf->tms_cstime = buf->tms_cutime = 0;
  
  return -1;
}
   18ccc:	00008067          	ret

0000000000018cd0 <gettimeofday>:

static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
   18cd0:	00000593          	li	a1,0
  register long a2 asm("a2") = _a2;
   18cd4:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18cd8:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18cdc:	0a900893          	li	a7,169

  asm volatile ("scall\n"
   18ce0:	00000073          	ecall
   18ce4:	ce054ee3          	bltz	a0,189e0 <__syscall_error>
// Get the current time.  Only relatively correct.

int gettimeofday(struct timeval* tp, void* tzp)
{
  return syscall_errno(SYS_gettimeofday, tp, 0, 0, 0);
}
   18ce8:	0005051b          	sext.w	a0,a0
   18cec:	00008067          	ret

0000000000018cf0 <ftime>:
//----------------------------------------------------------------------
// Get the current time.  Only relatively correct.

int ftime(struct timeb* tp)
{
  tp->time = tp->millitm = 0;
   18cf0:	00051423          	sh	zero,8(a0)
   18cf4:	00053023          	sd	zero,0(a0)
  return 0;
}
   18cf8:	00000513          	li	a0,0
   18cfc:	00008067          	ret

0000000000018d00 <utime>:
// Stub.

int utime(const char* path, const struct utimbuf* times)
{
  return -1;
}
   18d00:	fff00513          	li	a0,-1
   18d04:	00008067          	ret

0000000000018d08 <chown>:
// Stub.

int chown(const char* path, uid_t owner, gid_t group)
{
  return -1;
}
   18d08:	fff00513          	li	a0,-1
   18d0c:	00008067          	ret

0000000000018d10 <chmod>:
// Stub.

int chmod(const char* path, mode_t mode)
{
  return -1;
}
   18d10:	fff00513          	li	a0,-1
   18d14:	00008067          	ret

0000000000018d18 <chdir>:
// Stub.

int chdir(const char* path)
{
  return -1;
}
   18d18:	fff00513          	li	a0,-1
   18d1c:	00008067          	ret

0000000000018d20 <getcwd>:
// Stub.

char* getcwd(char* buf, size_t size)
{
  return NULL;
}
   18d20:	00000513          	li	a0,0
   18d24:	00008067          	ret

0000000000018d28 <sysconf>:
//----------------------------------------------------------------------
// Get configurable system variables

long sysconf(int name)
{
  switch(name)
   18d28:	00200793          	li	a5,2
   18d2c:	00f51863          	bne	a0,a5,18d3c <sysconf+0x14>
  {
    case _SC_CLK_TCK:
      return CLOCKS_PER_SEC;
   18d30:	000f4537          	lui	a0,0xf4
   18d34:	24050513          	addi	a0,a0,576 # f4240 <_gp+0xd8770>
  }

  return -1;
}
   18d38:	00008067          	ret
  {
    case _SC_CLK_TCK:
      return CLOCKS_PER_SEC;
  }

  return -1;
   18d3c:	fff00513          	li	a0,-1
   18d40:	00008067          	ret

0000000000018d44 <sbrk>:
void* sbrk(ptrdiff_t incr)
{
  extern unsigned char _end[]; // Defined by linker
  static unsigned long heap_end;

  if (heap_end == 0)
   18d44:	8c01b703          	ld	a4,-1856(gp) # 1b390 <heap_end.2381>
// on this, it is useful to have a working implementation. The following
// is suggested by the newlib docs and suffices for a standalone
// system.

void* sbrk(ptrdiff_t incr)
{
   18d48:	00050793          	mv	a5,a0
  extern unsigned char _end[]; // Defined by linker
  static unsigned long heap_end;

  if (heap_end == 0)
   18d4c:	00071663          	bnez	a4,18d58 <sbrk+0x14>
    heap_end = (long)_end;
   18d50:	93818713          	addi	a4,gp,-1736 # 1b408 <_end>
   18d54:	8ce1b023          	sd	a4,-1856(gp) # 1b390 <heap_end.2381>
#define SYS_dup 23

static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
   18d58:	00e78533          	add	a0,a5,a4
  register long a1 asm("a1") = _a1;
   18d5c:	00000593          	li	a1,0
  register long a2 asm("a2") = _a2;
   18d60:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18d64:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18d68:	0d600893          	li	a7,214

  asm volatile ("scall\n"
   18d6c:	00000073          	ecall
   18d70:	c60548e3          	bltz	a0,189e0 <__syscall_error>
  if (syscall_errno(SYS_brk, heap_end + incr, 0, 0, 0) != heap_end + incr)
   18d74:	8c01b683          	ld	a3,-1856(gp) # 1b390 <heap_end.2381>
    return (void*)-1;
   18d78:	fff00713          	li	a4,-1
  extern unsigned char _end[]; // Defined by linker
  static unsigned long heap_end;

  if (heap_end == 0)
    heap_end = (long)_end;
  if (syscall_errno(SYS_brk, heap_end + incr, 0, 0, 0) != heap_end + incr)
   18d7c:	00d787b3          	add	a5,a5,a3
   18d80:	00f51663          	bne	a0,a5,18d8c <sbrk+0x48>
    return (void*)-1;

  heap_end += incr;
   18d84:	8ca1b023          	sd	a0,-1856(gp) # 1b390 <heap_end.2381>
  return heap_end - incr;
   18d88:	00068713          	mv	a4,a3
}
   18d8c:	00070513          	mv	a0,a4
   18d90:	00008067          	ret

0000000000018d94 <_exit>:

static inline long
__internal_syscall(long n, long _a0, long _a1, long _a2, long _a3)
{
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
   18d94:	00000593          	li	a1,0
  register long a2 asm("a2") = _a2;
   18d98:	00000613          	li	a2,0
  register long a3 asm("a3") = _a3;
   18d9c:	00000693          	li	a3,0
  register long a7 asm("a7") = n;
   18da0:	05d00893          	li	a7,93

  asm volatile ("scall\n"
   18da4:	00000073          	ecall
   18da8:	c2054ce3          	bltz	a0,189e0 <__syscall_error>
   18dac:	0000006f          	j	18dac <_exit+0x18>

0000000000018db0 <__errno>:

int *
__errno ()
{
  return &_REENT->_errno;
}
   18db0:	8101b503          	ld	a0,-2032(gp) # 1b2e0 <_impure_ptr>
   18db4:	00008067          	ret
